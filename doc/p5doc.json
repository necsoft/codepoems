[{
    "name": "[] (array access)",
    "description": "\nThe array access operator is used to specify a location within an array. The data at this location can be defined with the syntax array[element] = value and read with the syntax value = array[element] as shown in the above example.\n",
    "syntax": "\ndatatype[]\narray[element]\n",
    "returns": "",
    "examples": ["\nint[] numbers = new int[3]; \nnumbers[0] = 90; \nnumbers[1] = 150; \nnumbers[2] = 30; \nint a = numbers[0] + numbers[1]; // Sets variable 'a' to 240 \nint b = numbers[1] + numbers[2]; // Sets variable 'b' to 180 \n"],
    "examples_img": [],
    "parameters": [{
        "name": "datatype",
        "description": "any primitive or compound datatype, including user-defined classes"
    }, {
        "name": "array",
        "description": "any valid variable name"
    }, {
        "name": "element",
        "description": "int: must not exceed the length of the array minus 1"
    }]
}, {
    "name": "draw()",
    "description": "\nCalled directly after setup(), the draw() function continuously executes the lines of code contained inside its block until the program is stopped or noLoop() is called. draw() is called automatically and should never be called explicitly.\n\nIt should always be controlled with noLoop(), redraw() and loop(). If noLoop() is used to stop the code in draw() from executing, then redraw() will cause the code inside draw() to be executed a single time, and loop() will cause the code inside draw() to resume executing continuously.\n\nThe number of times draw() executes in each second may be controlled with the frameRate() function.\n\nIt is common to call background() near the beginning of the draw() loop to clear the contents of the window, as shown in the first example above.  Since pixels drawn to the window are cumulative, omitting background() may result in unintended results, especially when drawing anti-aliased shapes or text.\n\nThere can only be one draw() function for each sketch, and draw() must exist if you want the code to run continuously, or to process events such as mousePressed(). Sometimes, you might have an empty call to draw() in your program, as shown in the second example above. \n",
    "syntax": "draw()",
    "returns": "void",
    "examples": ["\nfloat yPos = 0.0;\n\nvoid setup() {  // setup() runs once\n  size(200, 200);\n  frameRate(30);\n}\n \nvoid draw() {  // draw() loops forever, until stopped\n  background(204);\n  yPos = yPos - 1.0;\n  if (yPos < 0) {\n    yPos = height;\n  }\n  line(0, yPos, width, yPos);\n}\n", "\nvoid setup() {\n  size(200, 200);\n}\n\n// Although empty here, draw() is needed so\n// the sketch can process user input events\n// (mouse presses in this case).\nvoid draw() { }\n\nvoid mousePressed() {\n  line(mouseX, 10, mouseX, 90);\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "{} (curly braces)",
    "description": "\nDefine the beginning and end of functions blocks and statement blocks such as the for and if structures. Curly braces are also used for defining inital values in array declarations.\n",
    "syntax": "\n{ statements }\n{ ele0, ..., eleN }\n",
    "returns": "",
    "examples": ["\nint[] a = { 5, 20, 25, 45, 70 };\n\nvoid setup() {\n  size(100, 100);\n}\n\nvoid draw() {\n  for (int i=0; i < a.length; i++) {\n    line(0, a[i], 50, a[i]);\n  }\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "statements",
        "description": "any sequence of valid statements"
    }, {
        "name": "ele0, ..., eleN",
        "description": "list of elements separated by commas"
    }]
}, {
    "name": "focused",
    "description": "\nConfirms if a Processing program is \"focused,\" meaning that it is active and will accept mouse or keyboard input. This variable is \"true\" if it is focused and \"false\" if not.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nif (focused) {  // or \"if (focused == true)\"\n  ellipse(25, 25, 50, 50);\n} else {\n  line(0, 0, 100, 100);\n  line(100, 0, 0, 100);\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "= (assign)",
    "description": "\nAssigns a value to a variable. The \"=\" sign does not mean \"equals\", but is used to place data within a variable. The \"=\" operator is formally called the assignment operator. There are many different types of variables (int, floats, strings, etc.) and the assignment operator can only assign values which are the same type as the variable it is assigning. For example, if the variable is of type int, the value must also be an int.\n",
    "syntax": "\nvar = value\n",
    "returns": "",
    "examples": ["\nint a;\na = 30;  // Assigns for value 30 to the variable 'a'\na = a + 40;  // Assigns the value 70 to the variable 'a'\n"],
    "examples_img": [],
    "parameters": [{
        "name": "var",
        "description": "any valid variable name"
    }, {
        "name": "value",
        "description": "any value of the same type as the variable. For example, if the variable is of type \"int\", the value must also be an int"
    }]
}, {
    "name": "byte",
    "description": "\nDatatype for bytes, 8 bits of information storing numerical values from 127 to -128. Bytes are a convenient datatype for sending information to and from the serial port and for representing letters in a simpler format than the char datatype. The first time a variable is written, it must be declared with a statement expressing its datatype. Subsequent uses of this variable must not reference the datatype because Processing will think the variable is being declared again.\n",
    "syntax": "\nbyte var\nbyte var = value\n",
    "returns": "",
    "examples": [" \n// Declare variable 'a' of type byte\nbyte a;\n\n// Assign 23 to 'a'\na = 23;\n\n// Declare variable 'b' and assign it the value -128\nbyte b = -128;\n\n// Declare variable 'c' and assign it the sum of 'a' and 'b'.\n// By default, when two bytes are added, they are converted\n// to an integer. To keep the answer as a byte, cast them\n// to a byte with the byte() conversion function\nbyte c = byte(a + b);\n"],
    "examples_img": [],
    "parameters": [{
        "name": "var",
        "description": "variable name referencing the value"
    }, {
        "name": "value",
        "description": "a number between 127 to -128"
    }]
}, {
    "name": "catch",
    "description": "\nThe catch keyword is used with try to handle exceptions. Sun's Java documentation defines an exception as \"an event, which occurs during the execution of a program, that disrupts the normal flow of the program's instructions.\" This could be, for example, an error while a file is read.\n",
    "syntax": "\ntry {\n  tryStatements\n} catch (exception) {\n  catchStatements\n} \n",
    "returns": "",
    "examples": ["\nBufferedReader reader;\nString line;\n \nvoid setup() {\n  // Open the file from the createWriter() example\n  reader = createReader(\"positions.txt\");    \n}\n \nvoid draw() {\n  try {\n    line = reader.readLine();\n  } catch (IOException e) {\n    e.printStackTrace();\n    line = null;\n  }\n  if (line == null) {\n    // Stop reading because of an error or file is empty\n    noLoop();  \n  } else {\n    String[] pieces = split(line, TAB);\n    int x = int(pieces[0]);\n    int y = int(pieces[1]);\n    point(x, y);\n  }\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "tryStatements",
        "description": "if this code throws an exception, then the code in \"catch\" is run"
    }, {
        "name": "exception",
        "description": "the Java exception that was thrown"
    }, {
        "name": "catchStatements",
        "description": "code that handles the exception"
    }]
}, {
    "name": "; (semicolon)",
    "description": "\nA statement terminator which separates elements of the program. A statement is a complete instruction to the computer and the semicolon is used to separate instructions (this is similar to the period \".\" in written English). Semicolons are also used to separate the different elements of a for structure. \n",
    "syntax": "\nstatement;\n",
    "returns": "",
    "examples": ["\nint a;       // Declaration statement\na = 30;      // Assignment statement\nprintln(i);  // Function statement\n"],
    "examples_img": [],
    "parameters": [{
        "name": "statement",
        "description": "a single statement to execute"
    }]
}, {
    "name": "Array",
    "description": "\nAn array is a list of data. It is possible to have an array of any type of data. Each piece of data in an array is identified by an index number representing its position in the array. The first element in the array is [0], the second element is [1], and so on. Arrays are similar to objects, so they must be created with the keyword new.\n\nEach array has a variable length, which is an integer value for the total number of elements in the array. Note that since index numbering begins at zero (not 1), the last value in an array with a length of 5 should be referenced as array[4] (that is, the length minus 1), not array[5], which would trigger an error.\n\nAnother common source of confusion is the difference between using length to get the size of an array and length() to get the size of a String. Notice the presence of parentheses when working with Strings. (array.length is a variable, while String.length() is a method specific to the String class.)\n",
    "syntax": "\ndatatype[] var\nvar[element] = value\nvar.length\n",
    "returns": "",
    "examples": ["\nint[] numbers = new int[3];\nnumbers[0] = 90;  // Assign value to first element in the array\nnumbers[1] = 150; // Assign value to second element in the array\nnumbers[2] = 30;  // Assign value to third element in the array\nint a = numbers[0] + numbers[1]; // Sets variable 'a' to 240\nint b = numbers[1] + numbers[2]; // Sets variable 'b' to 180 \n", "\nint[] numbers = { 90, 150, 30 };  // Alternate syntax\nint a = numbers[0] + numbers[1];  // Sets variable 'a' to 240\nint b = numbers[1] + numbers[2];  // Sets variable 'b' to 180\n", "\nint degrees = 360;\nfloat[] cos_vals = new float[degrees];\n// Use a for() loop to quickly iterate\n// through all values in an array.\nfor (int i=0; i < degrees; i++) {         \n  cos_vals[i] = cos(TWO_PI/degrees * i);\n}\n", "\nfloat[] randoms = new float[100];\nfor (int i = 0; i < randoms.length; i++) {\n  randoms[i] = random(100);\n}\n\n// You can also use an enhanced loop\n// to access the elements of an array\nfor (float val : randoms) {\n  println(val);\n}\n\n// This works with arrays of objects, too,\n// but not when first making the array\nPVector vectors = new PVector[5];\nfor (int i = 0; i < vectors.length; i++) {\n  vectors[i] = new PVector();\n}\n\n// The syntax only applies when iterating\n// over an existing array \nfor (PVector v : vectors) {\n  point(v.x, v.y);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "datatype",
        "description": "any primitive or compound datatype, including user-defined classes"
    }, {
        "name": "var",
        "description": "any valid variable name"
    }, {
        "name": "element",
        "description": "int: must not exceed the length of the array minus 1"
    }, {
        "name": "value",
        "description": "data to assign to the array element; must be the same datatype as the array"
    }]
}, {
    "name": "new",
    "description": "\nCreates a \"new\" object. The keyword new is typically used similarly to the applications in the above example. In this example, a new object \"h1\" of the datatype \"HLine\" is created. On the following line, a new array of floats called \"speeds\" is created.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nHLine h1 = new HLine();\nfloat[] speeds = new float[3];\nfloat ypos;\n\nvoid setup() { \n  size(200, 200);\n  speeds[0] = 0.1; \n  speeds[1] = 2.0;\n  speeds[2] = 0.5;\n} \n \nvoid draw() {\n  ypos += speeds[int(random(3))]; \n  if (ypos > width) { \n    ypos = 0; \n  } \n  h1.update(ypos); \n} \n \nclass HLine { \n  void update(float y) { \n    line(0, y, width, y); \n  } \n} \n\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "long",
    "description": "\nDatatype for large integers. While integers can be as large as 2,147,483,647 and as low as -2,147,483,648 (stored as 32 bits), a long integer has a minimum value of -9,223,372,036,854,775,808 and a maximum value of 9,223,372,036,854,775,807 (stored as 64 bits). Use this datatype when you need a number to have a greater magnitude than can be stored within an int. Processing functions don't use this datatype, so while they work in the language, you'll usually have to convert to a int using the (int) syntax before passing into a function.\n",
    "syntax": "\nlong var\nlong var = value\n",
    "returns": "",
    "examples": ["\nlong a;          // Declare variable 'a' of type long\na = 23;          // Assign 'a' the value 23\nlong b = -256;   // Declare variable 'b' and assign it the value -256\nlong c = a + b;  // Declare variable 'c' and assign it the sum of 'a' and 'b'\nint i = (int)c;  // Converts the value of 'c' from a long to an int\n"],
    "examples_img": [],
    "parameters": [{
        "name": "var",
        "description": "variable name referencing the value"
    }, {
        "name": "value",
        "description": "any integer value"
    }]
}, {
    "name": "cursor()",
    "description": "\nSets the cursor to a predefined symbol or an image, or makes it visible if already hidden. If you are trying to set an image as the cursor, the recommended size is 16x16 or 32x32 pixels. It is not possible to load an image as the cursor if you are exporting your program for the Web, and not all MODES work with all browsers. The values for parameters x and y must be less than the dimensions of the image.\n \nSetting or hiding the cursor does not generally work with \"Present\" mode (when running full-screen).\n",
    "syntax": "cursor(kind)\ncursor(img)\ncursor(img, x, y)\ncursor()",
    "returns": "void",
    "examples": ["\n// Move the mouse left and right across the image\n// to see the cursor change from a cross to a hand\n\nvoid draw() \n{\n  if (mouseX < 50) {\n    cursor(CROSS);\n  } else {\n    cursor(HAND);\n  }\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "kind",
        "description": "int: either ARROW, CROSS, HAND, MOVE, TEXT, or WAIT"
    }, {
        "name": "img",
        "description": "PImage: any variable of type PImage"
    }, {
        "name": "x",
        "description": "int: the horizontal active spot of the cursor"
    }, {
        "name": "y",
        "description": "int: the vertical active spot of the cursor"
    }]
}, {
    "name": "/** */ (doc comment)",
    "description": "\nExplanatory notes embedded within the code and written to the \"index.html\" file created when the code is exported. Doc comments (documentation comments) are used for sharing a description of your sketch when the program is exported. Export the code by hitting the \"Export\" button on the Toolbar.\n",
    "syntax": "\n/**\n  comment\n*/\n",
    "returns": "",
    "examples": ["\n/**\n   Draws two lines which divides the window \n   into four quadrants. First draws a horizontal\n   line and then the vertical line \n*/ \nline(0, 50, 100, 50);\nline(50, 0, 50, 100);\n"],
    "examples_img": [],
    "parameters": [{
        "name": "comment",
        "description": "any sequence of characters"
    }]
}, {
    "name": "displayHeight",
    "description": "\nSystem variable that stores the height of the entire screen display. This is used to run a full-screen program on any display size.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nsize(displayWidth, displayHeight);\nline(0, 0, width, height);\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "return",
    "description": "\nKeyword used to indicate the value to return from a function. The value being returned must be the same datatype as defined in the function declaration. Functions declared with void can't return values and shouldn't include a return value.\n\nThe keyword return may also be used to break out of a function, thus not allowing the program to  the remaining statements. (See the third example above.)\n",
    "syntax": "\ntype function {\n  statements\n  return value\n}\n",
    "returns": "",
    "examples": ["\nint val = 30;\n \nvoid draw() {\n  int t = timestwo(val);\n  println(t);\n}\n\n// The first 'int' in the function declaration\n// specifies the type of data to be returned.\nint timestwo(int dVal) {\n  dVal = dVal * 2;\n  return dVal;  // Returns an int of 60, in this case\n}\n", "\nint[] vals = {10, 20, 30}; \n  \nvoid draw() { \n  int[] t = timestwo(vals); \n  println(t); \n  noLoop();\n} \n \nint[] timestwo(int[] dVals) { \n  for (int i = 0; i < dVals.length; i++) { \n    dVals[i] = dVals[i] * 2; \n  } \n  return dVals;  // Returns an array of 3 ints: 20, 40, 60 \n}\n", "\nvoid draw() {\n  background(204);\n  line(0, 0, width, height);\n  if (mousePressed) {\n    return;  // Break out of draw(), skipping the line statement below\n  }\n  line(0, height, width, 0);  // Executed only if mouse is not pressed\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "type",
        "description": "boolean, byte, char, int, float, String, boolean[], byte[], char[], int[], float[], or String[]"
    }, {
        "name": "function",
        "description": "the function that is being defined"
    }, {
        "name": "statements",
        "description": "any valid statements"
    }, {
        "name": "value",
        "description": "must be the same datatype as the \"type\" parameter"
    }]
}, {
    "name": "redraw()",
    "description": "\nExecutes the code within draw() one time. This functions allows the program to update the display window only when necessary, for example when an event registered by mousePressed() or keyPressed() occurs. \n\nIn structuring a program, it only makes sense to call redraw() within events such as mousePressed(). This is because redraw() does not run draw() immediately (it only sets a flag that indicates an update is needed). \n\nThe redraw() function does not work properly when called inside draw(). To enable/disable animations, use loop() and noLoop().\n",
    "syntax": "redraw()",
    "returns": "void",
    "examples": ["\nfloat x = 0;\n\nvoid setup() {\n  size(200, 200);\n  noLoop();\n}\n\nvoid draw() {\n  background(204);\n  line(x, 0, x, height); \n}\n\nvoid mousePressed() {\n  x += 1;\n  redraw();\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "boolean",
    "description": "\nDatatype for the Boolean values true and false. It is common to use boolean values with control statements to determine the flow of a program. The first time a variable is written, it must be declared with a statement expressing its datatype.\n",
    "syntax": "\nboolean var\nboolean var = booleanvalue\n",
    "returns": "",
    "examples": ["\nboolean a = false; \nif (!a) { \n  rect(30, 20, 50, 50); \n} \na = true; \nif (a) { \n  line(20, 10, 90, 80); \n  line(20, 80, 90, 10); \n} \n"],
    "examples_img": ["https://www.processing.org/reference/images/boolean.png"],
    "parameters": [{
        "name": "var",
        "description": "variable name referencing the value"
    }, {
        "name": "booleanvalue",
        "description": "true or false"
    }]
}, {
    "name": "noLoop()",
    "description": "\nStops Processing from continuously executing the code within draw(). If loop() is called, the code in draw() begins to run continuously again. If using noLoop() in setup(), it should be the last line inside the block.\n\nWhen noLoop() is used, it's not possible to manipulate or access the screen inside event handling functions such as mousePressed() or keyPressed(). Instead, use those functions to call redraw() or loop(), which will run draw(), which can update the screen properly. This means that when noLoop() has been called, no drawing can happen, and functions like saveFrame() or loadPixels() may not be used.\n\nNote that if the sketch is resized, redraw() will be called to update the sketch, even after noLoop() has been specified. Otherwise, the sketch would enter an odd state until loop() was called.\n",
    "syntax": "noLoop()",
    "returns": "void",
    "examples": ["\nvoid setup() {\n  size(200, 200);\n  noLoop();\n}\n\nvoid draw() {\n  line(10, 10, 190, 190);\n}\n", "\nvoid setup() {\n  size(200, 200);\n}\n\nfloat x = 0.0;\n\nvoid draw() {\n  background(204);\n  x = x + 0.1;\n  if (x > width) {\n    x = 0;\n  }\n  line(x, 0, x, height); \n}\n\nvoid mousePressed() {\n  noLoop();\n}\n\nvoid mouseReleased() {\n  loop();\n}\n", "\nboolean someMode = false;\n\nvoid setup() {\n  noLoop();\n}\n\nvoid draw() {\n  if (someMode) {\n    // do something\n  }\n}\n\nvoid mousePressed() {\n  someMode = true;\n  redraw();  // or loop()\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "public",
    "description": "\nKeyword used to provide other classes access the fields and methods within a class. The public keyword is used before a field or method that you want to make available. In Processing, all fields and methods are public unless otherwise specified by the private keyword.\n\nThis keyword is an essential part of Java programming and is not usually used with Processing. Consult a Java language reference or tutorial for more information. \n",
    "syntax": "",
    "returns": "",
    "examples": [],
    "examples_img": [],
    "parameters": []
}, {
    "name": "pushStyle()",
    "description": "\nThe pushStyle() function saves the current style settings and popStyle() restores the prior settings. Note that these functions are always used together. They allow you to change the style settings and later return to what you had. When a new style is started with pushStyle(), it builds on the current style information. The pushStyle() and popStyle() functions can be embedded to provide more control. (See the second example above for a demonstration.)\n\nThe style information controlled by the following functions are included in the style:\nfill(), stroke(), tint(), strokeWeight(), strokeCap(), strokeJoin(), imageMode(), rectMode(), ellipseMode(), shapeMode(), colorMode(), textAlign(), textFont(), textMode(), textSize(), textLeading(), emissive(), specular(), shininess(), ambient() \n",
    "syntax": "pushStyle()",
    "returns": "void",
    "examples": ["\nellipse(0, 50, 33, 33);  // Left circle\n\npushStyle();  // Start a new style\nstrokeWeight(10);\nfill(204, 153, 0);\nellipse(50, 50, 33, 33);  // Middle circle\npopStyle();  // Restore original style\n\nellipse(100, 50, 33, 33);  // Right circle\n", "\nellipse(0, 50, 33, 33);  // Left circle\n\npushStyle();  // Start a new style\nstrokeWeight(10);\nfill(204, 153, 0);\nellipse(33, 50, 33, 33);  // Left-middle circle\n\npushStyle();  // Start another new style\nstroke(0, 102, 153);\nellipse(66, 50, 33, 33);  // Right-middle circle\npopStyle();  // Restore previous style\n\npopStyle();  // Restore original style\n\nellipse(100, 50, 33, 33);  // Right circle\n"],
    "examples_img": ["https://www.processing.org/reference/images/pushStyle_0.png", "https://www.processing.org/reference/images/pushStyle_1.png"],
    "parameters": []
}, {
    "name": "ArrayList",
    "description": "\nAn ArrayList stores a variable number of objects. This is similar to making an array of objects, but with an ArrayList, items can be easily added and removed from the ArrayList and it is resized dynamically. This can be very convenient, but it's slower than making an array of objects when using many elements.  Note that for resizable lists of integers, floats, and Strings, you can use the Processing classes IntList, FloatList, and StringList.\n\nAn ArrayList is a resizable-array implementation of the Java List interface. It has many methods used to control and search its contents. For example, the length of the ArrayList is returned by its size() method, which is an integer value for the total number of elements in the list. An element is added to an ArrayList with the add() method and is deleted with the remove() method. The get() method returns the element at the specified position in the list. (See the above example for context.)\n\nFor a list of the numerous ArrayList features, please read the Java reference description.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\n// These are code fragments that show how to use an ArrayList.\n// They won't compile because they assume the existence of a Particle class.\n\n// Declaring the ArrayList, note the use of the syntax \"<Particle>\" to indicate\n// our intention to fill this ArrayList with Particle objects\nArrayList<Particle> particles = new ArrayList<Particle>();\n\n// Objects can be added to an ArrayList with add()\nparticles.add(new Particle());\n\n// Particles can be pulled out of an ArrayList with get()\nParticle part = particles.get(0);\npart.display();\n\n// The size() method returns the current number of items in the list\nint total = particles.size();\nprintln(\"The total number of particles is: \" + total);\n\n// You can iterate over an ArrayList in two ways.\n// The first is by counting through the elements:\nfor (int i = 0; i < particles.size(); i++) {\n  Particle part = particles.get(i);\n  part.display();\n}\n\n// The second is using an enhanced loop:\nfor (Particle part : particles) {\n  part.display();\n}\n\n// You can delete particles from an ArrayList with remove()\nparticles.remove(0);\nprintln(particles.size()); // Now one less!\n\n// If you are modifying an ArrayList during the loop,\n// then you cannot use the enhanced loop syntax.\n// In addition, when deleting in order to hit all elements, \n// you should loop through it backwards, as shown here:\nfor (int i = particles.size - 1; i >= 0; i--) {\n  Particle part = particles.get(i);\n  if (part.finished()) {\n    particles.remove(i);\n  }\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "Type",
        "description": "Class Name: the data type for the objects to be placed in the ArrayList."
    }, {
        "name": "initialCapacity",
        "description": "int: defines the initial capacity of the list; it's empty by default"
    }]
}, {
    "name": "double",
    "description": "\nDatatype for floating-point numbers larger than those that can be stored in a float. A float is a 32-bit values that can be as large as 3.40282347E+38 and as low as -3.40282347E+38. A double can be used similarly to a float, but can have a greater magnitude because it's a 64-bit number. Processing functions don't use this datatype, so while they work in the language, you'll usually have to convert to a float using the (float) syntax before passing into a function.",
    "syntax": "\ndouble var\ndouble var = value\n",
    "returns": "",
    "examples": ["\ndouble a;            // Declare variable 'a' of type float\na = 1.5387;          // Assign 'a' the value 1.5387\ndouble b = -2.984;   // Declare variable 'b' and assign it the value -2.984\ndouble c = a + b;    // Declare variable 'c' and assign it the sum of 'a' and 'b'\nfloat f = (float)c;  // Converts the value of 'c' from a double to a float\n"],
    "examples_img": [],
    "parameters": [{
        "name": "var",
        "description": "variable name referencing the float"
    }, {
        "name": "value",
        "description": "any floating-point value"
    }]
}, {
    "name": "thread()",
    "description": "\nProcessing sketches follow a specific sequence of steps: setup() first, followed by draw() over and over and over again in a loop. A thread is also a series of steps with a beginning, a middle, and an end. A Processing sketch is a single thread, often referred to as the \"Animation\" thread. Other threads' sequences, however, can run independently of the main animation loop. In fact, you can launch any number of threads at one time, and they will all run concurrently.\n\nProcessing does this quite often, such as with library functions like captureEvent() and movieEvent(). These functions are triggered by a different thread running behind the scenes, and they alert Processing whenever they have something to report. This is useful when you need to perform a task that takes too long and would slow down the main animation's frame rate, such as grabbing data from the network.  If a separate thread gets stuck or has an error, the entire program won't grind to a halt, since the error only stops that individual thread.\n\nWriting your own thread can be a complex endeavor that involves extending the Java Thread class.  However, the thread() method is a quick and dirty way to implement a simple thread in Processing.  By passing in a String that matches the name of a function declared elsewhere in the sketch, Processing will execute that function in a separate thread.\n",
    "syntax": "thread(name)",
    "returns": "void",
    "examples": ["\nString time = \"\";\n\nvoid setup() {\n  size(100, 100);\n}\n\nvoid draw() {\n  background(0);\n  // Every 30 frames request new data\n  if (frameCount % 30 == 0) {\n    thread(\"requestData\");\n  }\n  text(time, 10, 50);\n}\n\n// This happens as a separate thread and can take as long as it wants\nvoid requestData() {\n  JSONObject json = loadJSONObject(\"http://time.jsontest.com/\");\n  time = json.getString(\"time\");\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "name",
        "description": "String: name of the function to be executed in a separate thread"
    }]
}, {
    "name": "height",
    "description": "\nSystem variable that stores the height of the display window. This value is set by the second parameter of the size() function. For example, the function call size(320, 240) sets the height variable to the value 240. The value of height defaults to 100 if size() is not used in a program.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nnoStroke();\nbackground(0);\nrect(40, 0, 20, height);\nrect(60, 0, 20, height/2);\n"],
    "examples_img": ["https://www.processing.org/reference/images/height.png"],
    "parameters": []
}, {
    "name": "void",
    "description": "\nKeyword used indicate that a function returns no value. Each function must either return a value of a specific datatype or use the keyword void to specify it returns nothing.\n",
    "syntax": "\nvoid function {\n  statements\n}\n",
    "returns": "",
    "examples": ["\nvoid setup() {  // setup() does not return a value\n  size(200, 200);\n}\n\nvoid draw() {  // draw() does not return a value\n  line(10, 100, 190, 100);\n  drawCircle();\n}\n\nvoid drawCircle() {  // This function also does not return a value\n  ellipse(30, 30, 50, 50);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "function",
        "description": "any function that is being defined or implemented"
    }, {
        "name": "statements",
        "description": "any valid statements"
    }]
}, {
    "name": "TableRow",
    "description": "\nA TableRow object represents a single row of data values, stored in columns, from a table.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nTable table;\n\nvoid setup() {\n\n  table = new Table();\n  \n  table.addColumn(\"number\", Table.INT);\n  table.addColumn(\"mass\", Table.FLOAT);\n  table.addColumn(\"name\", Table.STRING);\n  \n  TableRow row = table.addRow();\n  row.setInt(\"number\", 8);\n  row.setFloat(\"mass\", 15.9994);\n  row.setString(\"name\", \"Oxygen\");\n  \n  println(row.getInt(\"number\"));   // Prints 8\n  println(row.getFloat(\"mass\"));   // Prints 15.9994\n  println(row.getString(\"name\"));  // Prints \"Oxygen\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "this",
    "description": "\nRefers to the current object (i.e., \"this object\"), which will change depending on the context in which this is referenced. In Processing, it's most common to use this to pass a reference from the current object into one of the libraries.\n\nThe keyword this can also be used to reference an object's own method from within itself, but such usage is typically not necessary. For example, if you are calling the filter() method of a PImage object named tree from another object, you would write tree.filter(). To call this method inside the PImage object itself, one could simply write filter() or, more explicitly, this.filter(). The additional level of specificity in this.filter() is not necessary, as it is always implied.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nfloat ypos = 50;\n\nvoid setup() {\n  size(100, 100);\n  noLoop();\n}\n\nvoid draw() {\n  line(0, 0, 100, ypos);\n  // \"this\" references the Processing sketch,\n  // and is not necessary in this case\n  this.ypos = 100;\n  line(0, 0, 100, ypos);\n}\n\n", "\nimport processing.video.*;\nMovie myMovie;\n\nvoid setup() {\n  size(200, 200);\n  background(0);\n  // \"this\" references the Processing sketch\n  myMovie = new Movie(this, \"totoro.mov\");\n  myMovie.loop();\n}\n\nvoid draw() {\n  if (myMovie.available()) {\n    myMovie.read();\n  }\n  image(myMovie, 0, 0);\n}\n\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "color",
    "description": "\nDatatype for storing color values. Colors may be assigned with get() and color() or they may be specified directly using hexadecimal notation such as #FFCC00 or 0xFFFFCCOO. \n \nUsing print() or println() on a color will produce strange results (usually negative numbers) because of the way colors are stored in memory. A better technique is to use the hex() function to format the color data, or use the red(), green(), and blue() functions to get individual values and print those. The hue(), saturation(), and brightness() functions work in a similar fashion. To extract red, green, and blue values more quickly (for instance when analyzing an image or a frame of video), use bit shifting.\n \nValues can also be created using web color notation. For example: color c = #006699\n \nWeb color notation only works for opaque colors. To define a color with an alpha value, you can either use color() or hexadecimal notation. For hex notation, prefix the values with 0x, for instance color c = 0xCC006699. In that example, CC (the hex value of 204) is the alpha value, and the remainder is identical to a web color. Note that in hexadecimal notation, the alpha value appears in the first position. (The alpha value appears last when used within color(), fill(), and stroke().) The following is an equivalent way of writing the preceding example, but using color() and specifying the alpha value as its second parameter: color c = color(#006699, 191)\n \nFrom a technical standpoint, colors are 32 bits of information ordered as AAAAAAAARRRRRRRRGGGGGGGGBBBBBBBB where the A's contain the alpha value, the R's are the red value, G's are green, and B's are blue. Each component is 8 bits (a number between 0 and 255). These values can be manipulated with bit shifting.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\ncolor c1 = color(204, 153, 0);\ncolor c2 = #FFCC00;\nnoStroke();\nfill(c1);\nrect(0, 0, 25, 100);\nfill(c2);\nrect(25, 0, 25, 100);\ncolor c3 = get(10, 50);\nfill(c3);\nrect(50, 0, 50, 100);\n"],
    "examples_img": ["https://www.processing.org/reference/images/color.png"],
    "parameters": []
}, {
    "name": "nfc()",
    "description": "\nUtility function for formatting numbers into strings and placing appropriate commas to mark units of 1000. There are two versions: one for formatting ints, and one for formatting an array of ints. The value for the right parameter should always be a positive integer.\n \nFor a non-US locale, this will insert periods instead of commas, or whatever is apprioriate for that region.\n",
    "syntax": "nfc(num)\nnfc(num, right)",
    "returns": "String[]",
    "examples": ["\nint i = 500000; \nString si = nfc(i);\nprintln(si);  // Prints \"500,000\"\nfloat f = 42525.34343; \nString fi = nfc(f, 2);\nprintln(fi);  // Prints \"42,525.34\"\n\n"],
    "examples_img": [],
    "parameters": [{
        "name": "num",
        "description": "float[], or int[]: the number(s) to format"
    }, {
        "name": "right",
        "description": "int: number of digits to the right of the decimal point"
    }]
}, {
    "name": "boolean()",
    "description": "\nConverts an int or String to its boolean representation.  For an int, any non-zero value (positive or negative) evaluates to true, while zero evaluates to false. For a String, the value \"true\" evaluates to true, while any other value (including \"false\" or \"hippopotamus\") evaluates to false.\n\nWhen an array of int or String values is passed in, then a boolean array of the same length is returned.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nString s = \"true\";\nboolean b = boolean(s);\nif (b) {\n  println(\"The boolean is true\");\n} else {\n  println(\"The boolean is false\");\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "subset()",
    "description": "\nExtracts an array of elements from an existing array. The list parameter defines the array from which the elements will be copied, and the start and count parameters specify which elements to extract. If no count is given, elements will be extracted from the start to the end of the array. When specifying the start, remember that the first array element is 0. This function does not change the source array.\n\nWhen using an array of objects, the data returned from the function must be cast to the object array's data type. For example: SomeClass[] items = (SomeClass[]) subset(originalArray, 0, 4)\n",
    "syntax": "subset(list, start)\nsubset(list, start, count)",
    "returns": "boolean[], byte[], char[], int[], float[], String[], or Object",
    "examples": ["\nString[] sa1 = { \"OH\", \"NY\", \"CA\", \"VA\", \"CO\", \"IL\" };\nString[] sa2 = subset(sa1, 1);\nprintln(sa2);\n// Prints the following array contents to the console:\n// [0] \"NY\"\n// [1] \"CA\"\n// [2] \"VA\"\n// [3] \"CO\"\n// [4] \"IL\"\nprintln();\nString[] sa3 = subset(sa1, 2, 3);\nprintln(sa3);\n// Prints the following array contents to the console:\n// [0] \"CA\"\n// [1] \"VA\"\n// [2] \"CO\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "list",
        "description": "Object, String[], float[], int[], char[], byte[], or boolean[]: array to extract from"
    }, {
        "name": "start",
        "description": "int: position to begin"
    }, {
        "name": "count",
        "description": "int: number of values to extract"
    }]
}, {
    "name": "FloatList",
    "description": "\nHelper class for a list of floats. Lists are designed to have some of the \nfeatures of ArrayLists, but to maintain the simplicity and efficiency of\nworking with arrays. \n\nFunctions like sort() and shuffle() always act on the list itself. To get \na sorted copy, use list.copy().sort().\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nFloatList inventory;\n\nvoid setup() {\n  size(200, 200);\n  inventory = new FloatList();\n  inventory.append(108.6);\n  inventory.append(5.8);\n  inventory.append(8.2);\n  println(inventory);\n  noLoop();\n  fill(0);\n  textAlign(CENTER);\n}\n\nvoid draw() {\n  float nums = inventory.get(2);\n  text(nums, width/2, height/2);\n}\n\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "reverse()",
    "description": "\nReverses the order of an array.\n",
    "syntax": "reverse(list)",
    "returns": "boolean[], byte[], char[], int[], float[], String[], or Object",
    "examples": ["\nString sa[] = { \"OH\", \"NY\", \"MA\", \"CA\"};\nsa = reverse(sa);\nprintln(sa);\n// Prints updated array contents to the console:\n// [0] \"CA\"\n// [1] \"MA\"\n// [2] \"NY\"\n// [3] \"OH\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "list",
        "description": "Object, String[], float[], int[], char[], byte[], or boolean[]: booleans[], bytes[], chars[], ints[], floats[], or Strings[]"
    }]
}, {
    "name": "int()",
    "description": "\nConverts any value of a primitive data type (boolean, byte, char, color, double, float, int, or long) to its integer representation.\n\nWhen an array of values is passed in, then an int array of the same length is returned.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nfloat f = 65.0;\nint i = int(f);\nprintln(f + \" : \" + i);  // Prints \"65.0 : 65\"\n\nchar c = 'E';\ni = int(c);\nprintln(c + \" : \" + i);  // Prints \"E : 69\"\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "shorten()",
    "description": "\nDecreases an array by one element and returns the shortened array.\n \nWhen using an array of objects, the data returned from the function must be cast to the object array's data type. For example: SomeClass[] items = (SomeClass[]) shorten(originalArray)\n",
    "syntax": "shorten(list)",
    "returns": "boolean[], byte[], char[], int[], float[], String[], or Object",
    "examples": ["\nString[] sa1 = { \"OH \", \"NY \", \"CA \"}; \nString[] sa2 = shorten(sa1); \nprintln(sa1);  // 'sa1' still contains OH, NY, CA\nprintln(sa2);  // 'sa2' now contains OH, NY\n"],
    "examples_img": [],
    "parameters": [{
        "name": "list",
        "description": "Object, String[], float[], int[], char[], byte[], or boolean[]: array to shorten"
    }]
}, {
    "name": "Table",
    "description": "\nTable objects store data with multiple rows and columns, much like in a traditional spreadsheet.  Tables can be generated from scratch, dynamically, or using data from an existing file.  Tables can also be output and saved to disk, as in the example above.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nTable table;\n\nvoid setup() {\n\n  table = new Table();\n  \n  table.addColumn(\"id\");\n  table.addColumn(\"species\");\n  table.addColumn(\"name\");\n  \n  TableRow newRow = table.addRow();\n  newRow.setInt(\"id\", table.lastRowIndex());\n  newRow.setString(\"species\", \"Panthera leo\");\n  newRow.setString(\"name\", \"Lion\");\n  \n  saveTable(table, \"data/new.csv\");\n}\n\n// Sketch saves the following to a file called \"new.csv\":\n// id,species,name\n// 0,Panthera leo,Lion\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "String",
    "description": "\nA string is a sequence of characters. The class String includes methods for examining individual characters, comparing strings, searching strings, extracting parts of strings, and for converting an entire string uppercase and lowercase. Strings are always defined inside double quotes (\"Abc\"), and characters are always defined inside single quotes ('A').\n\nTo compare the contents of two Strings, use the equals() method, as in if (a.equals(b)), instead of if (a == b). A String is an Object, so comparing them with the == operator only compares whether both Strings are stored in the same memory location. Using the equals() method will ensure that the actual contents are compared. (The troubleshooting reference has a longer explanation.) \n\nBecause a String is defined between double quotation marks, to include such marks within the String itself you must use the \\ (backslash) character.  (See the third example above.)  This is known as an escape sequence. Other escape sequences include \\t for the tab character and \\n for new line. Because backslash is the escape character, to include a single backslash within a String, you must use two consecutive backslashes, as in: \\\\\n\nThere are more string methods than those linked from this page. Additional documentation is located online in the official Java documentation.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nString str1 = \"CCCP\";\nchar data[] = {'C', 'C', 'C', 'P'};\nString str2 = new String(data);\nprintln(str1);  // Prints \"CCCP\" to the console\nprintln(str2);  // Prints \"CCCP\" to the console\n", "\n// Comparing String objects, see reference below.\nString p = \"potato\";\nif (p == \"potato\") {\n  println(\"p == potato, yep.\");  // This will not print\n} \n// The correct way to compare two Strings\nif (p.equals(\"potato\")) {\n  println(\"Yes, the contents of p and potato are the same.\");\n}\n", "\n// Use a backslash to include quotes in a String\nString quoted = \"This one has \\\"quotes\\\"\";\nprintln(quoted);  // This one has \"quotes\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "data",
        "description": "byte[] or char[]: either an array of bytes to be decoded into characters, or an array of characters to be combined into a string"
    }, {
        "name": "offset",
        "description": "int: index of the first character"
    }, {
        "name": "length",
        "description": "int: number of characters"
    }]
}, {
    "name": "default",
    "description": "\nKeyword for defining the default condition of a switch. If none of the case labels match the switch parameter, the statement(s) after the default syntax are executed. Switch structures don't require a default.\n",
    "syntax": "\ndefault: statements\n",
    "returns": "",
    "examples": ["\nchar letter = 'F';\n\nswitch(letter) {\n  case 'A': \n    println(\"Alpha\");  // Does not execute\n    break;\n  case 'B': \n    println(\"Bravo\");  // Does not execute\n    break;\n  default:\n    println(\"Zulu\");   // Prints \"Zulu\"\n    break;\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "statements",
        "description": "one or more valid statements to be executed"
    }]
}, {
    "name": "JSONArray",
    "description": "\nA JSONArray stores an array of JSON objects.  JSONArrays can be generated from scratch, dynamically, or using data from an existing file.  JSON can also be output and saved to disk, as in the example above.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nString[] species = { \"Capra hircus\", \"Panthera pardus\", \"Equus zebra\" };\nString[] names = { \"Goat\", \"Leopard\", \"Zebra\" };\n\nJSONArray values;\n\nvoid setup() {\n\n  values = new JSONArray();\n\n  for (int i = 0; i < species.length; i++) {\n\n    JSONObject animal = new JSONObject();\n\n    animal.setInt(\"id\", i);\n    animal.setString(\"species\", species[i]);\n    animal.setString(\"name\", names[i]);\n\n    values.setJSONObject(i, animal);\n  }\n\n  saveJSONArray(values, \"data/new.json\");\n}\n\n// Sketch saves the following to a file called \"new.json\":\n// [\n//   {\n//     \"id\": 0,\n//     \"species\": \"Capra hircus\",\n//     \"name\": \"Goat\"\n//   },\n//   {\n//     \"id\": 1,\n//     \"species\": \"Panthera pardus\",\n//     \"name\": \"Leopard\"\n//   },\n//   {\n//     \"id\": 2,\n//     \"species\": \"Equus zebra\",\n//     \"name\": \"Zebra\"\n//   }\n// ]\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "expand()",
    "description": "\nIncreases the size of an array. By default, this function doubles the size of the array, but the optional newSize parameter provides precise control over the increase in size. \n \nWhen using an array of objects, the data returned from the function must be cast to the object array's data type. For example: SomeClass[] items = (SomeClass[]) expand(originalArray)\n",
    "syntax": "expand(list)\nexpand(list, newSize)",
    "returns": "boolean[], byte[], char[], int[], long[], float[], double[], String[], or Object",
    "examples": ["\nint[] data = {0, 1, 3, 4};\nprintln(data.length);  // Prints \"4\"\ndata = expand(data);\nprintln(data.length);  // Prints \"8\"\ndata = expand(data, 512);\nprintln(data.length);  // Prints \"512\"\n\n", "\nPImage[] imgs = new PImage[32];\nprintln(imgs.length);  // Prints \"32\"\nimgs = (PImage[]) expand(imgs);\nprintln(imgs.length);  // Prints \"64\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "list",
        "description": "Object, String[], double[], float[], long[], int[], char[], byte[], or boolean[]: the array to expand"
    }, {
        "name": "newSize",
        "description": "int: new size for the array"
    }]
}, {
    "name": "textMode()",
    "description": "\nSets the way text draws to the screen, either as texture maps or as vector geometry. The default textMode(MODEL), uses textures to render the fonts. The textMode(SHAPE) mode draws text using the glyph outlines of individual characters rather than as textures. This mode is only supported with the PDF and P3D renderer settings. With the PDF renderer, you must call textMode(SHAPE) before any other drawing occurs. If the outlines are not available, then textMode(SHAPE) will be ignored and textMode(MODEL) will be used instead.\n\nThe textMode(SHAPE) option in P3D can be combined with beginRaw() to write vector-accurate text to 2D and 3D output files, for instance DXF or PDF. The SHAPE mode is not currently optimized for P3D, so if recording shape data, use textMode(MODEL) until you're ready to capture the geometry with beginRaw().\n",
    "syntax": "textMode(mode)",
    "returns": "void",
    "examples": ["\nimport processing.pdf.*;\n\nvoid setup() {\n  size(500, 500, PDF, \"TypeDemo.pdf\");\n  textMode(SHAPE);\n  textSize(180);\n}\n\nvoid draw() {\n  text(\"ABC\", 75, 350);\n  exit();  // Quit the program\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "mode",
        "description": "int: either MODEL or SHAPE"
    }]
}, {
    "name": "trim()",
    "description": "\nRemoves whitespace characters from the beginning and end of a String. In addition to standard whitespace characters such as space, carriage return, and tab, this function also removes the Unicode \"nbsp\" character.\n",
    "syntax": "trim(str)\ntrim(array)",
    "returns": "String or String[]",
    "examples": ["\nString s1 = \"    Somerville MA \";\nprintln(s1);  // Prints \"    Somerville MA \"\nString s2 = trim(s1);\nprintln(s2);  // Prints \"Somerville MA\"\n\nString[] a1 = { \" inconsistent \", \" spacing\" };  // Note spaces\nString[] a2 = trim(a1);\nprintln(a2);\n// Prints the following array contents to the console:\n// [0] \"inconsistent\"\n// [1] \"spacing\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "str",
        "description": "String: any string"
    }, {
        "name": "array",
        "description": "String[]: a String array"
    }]
}, {
    "name": "== (equality)",
    "description": "\nDetermines if two values are equivalent. The equality operator is different from the assignment operator. \n\nNote that when comparing String objects, you must use the equals() method instead of == to compare their contents. See the reference for String or the troubleshooting note for more explanation.\n",
    "syntax": "\nvalue1 == value2\n",
    "returns": "",
    "examples": ["\nint a = 23;\nint b = 23;\nif (a == b) {\n  println(\"variables a and b are equal\");\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1",
        "description": "int, float, char, byte, boolean"
    }, {
        "name": "value2",
        "description": "int, float, char, byte, boolean"
    }]
}, {
    "name": "% (modulo)",
    "description": "\nCalculates the remainder when one number is divided by another. For example, when 52.1 is divided by 10, the divisor (10) goes into the dividend (52.1) five times (5 * 10 == 50), and there is a remainder of 2.1 (52.1 - 50 == 2.1). Thus, 52.1 % 10 produces 2.1.\n\nNote that when the divisor is greater than the dividend, the remainder constitutes the value of the entire dividend. That is, a number cannot be divided by any number larger than itself. For example, when 9 is divided by 10, the result is zero with a remainder of 9. Thus, 9 % 10 produces 9.\n\nModulo is extremely useful for keeping numbers within a boundary such as keeping a shape on the screen. (See the second example above.)\n",
    "syntax": "\nvalue1 % value2\n",
    "returns": "",
    "examples": ["\nint a = 5 % 4;            // Sets 'a' to 1\nint b = 125 % 100;        // Sets 'b' to 25\nfloat c = 285.5 % 140.0;  // Sets 'c' to 5.5 \nfloat d = 30.0 % 33.0;    // Sets 'd' to 30.0\n", "\nint a = 0;\nvoid draw() {\n  background(200);\n  a = (a + 1) % width;  // 'a' increases between 0 and width \n  line(a, 0, a, height);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1",
        "description": "int or float"
    }, {
        "name": "value2",
        "description": "int or float"
    }]
}, {
    "name": "exp()",
    "description": "\nReturns Euler's number e (2.71828...) raised to the power of the n parameter.\n",
    "syntax": "exp(n)",
    "returns": "float",
    "examples": ["\nfloat v1 = exp(1.0);\nprintln(v1);  // Prints \"2.7182817\"\n\n"],
    "examples_img": [],
    "parameters": [{
        "name": "n",
        "description": "float: exponent to raise"
    }]
}, {
    "name": "break",
    "description": "\nEnds the execution of a structure such as switch, for, or while and jumps to the next statement after.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nchar letter = 'B';\n\nswitch(letter) {\n  case 'A': \n    println(\"Alpha\");  // Does not execute\n    break;\n  case 'B': \n    println(\"Bravo\");  // Prints \"Bravo\"\n    break;\n  default:\n    println(\"Zulu\");   // Does not execute\n    break;\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "/= (divide assign)",
    "description": "\nCombines division with assignment. The expression a /= b is equivalent to a = a / b. \n",
    "syntax": "\nvalue1 /= value2\n",
    "returns": "",
    "examples": ["\nint a = 12;\nint b = 3;\na /= b;  // Sets 'a' to 4\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1",
        "description": "int or float"
    }, {
        "name": "value2",
        "description": "any numerical value the same datatype as value1"
    }]
}, {
    "name": "width",
    "description": "\nSystem variable that stores the width of the display window. This value is set by the first parameter of the size() function. For example, the function call size(320, 240) sets the width variable to the value 320. The value of width defaults to 100 if size() is not used in a program.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nnoStroke();\nbackground(0);\nrect(0, 40, width, 20);\nrect(0, 60, width/2, 20);\n"],
    "examples_img": ["https://www.processing.org/reference/images/width.png"],
    "parameters": []
}, {
    "name": "ceil()",
    "description": "\nCalculates the closest int value that is greater than or equal to the value of the parameter. For example, ceil(9.03) returns the value 10.\n",
    "syntax": "ceil(n)",
    "returns": "int",
    "examples": ["\nfloat x = 8.22;  \nint a = ceil(x);  // Sets 'a' to 9\n"],
    "examples_img": [],
    "parameters": [{
        "name": "n",
        "description": "float: number to round up"
    }]
}, {
    "name": "split()",
    "description": "\nThe split() function breaks a String into pieces using a character or string as the delimiter. The delim parameter specifies the character or characters that mark the boundaries between each piece. A String[] array is returned that contains each of the pieces.\n \nIf the result is a set of numbers, you can convert the String[] array to to a float[] or int[] array using the datatype conversion functions int() and float().  (See the second example above.)\n  \nThe splitTokens() function works in a similar fashion, except that it splits using a range of characters instead of a specific character or sequence.\n\n",
    "syntax": "split(value, delim)",
    "returns": "String[]",
    "examples": ["\nString men = \"Chernenko,Andropov,Brezhnev\";\nString[] list = split(men, ',');\n// list[0] is now \"Chernenko\", list[1] is \"Andropov\"...\n", "\nString numbers = \"8 67 5 309\";\nint[] nums = int(split(numbers, ' '));\n// nums[0] is now 8, nums[1] is now 67...\n", "\nString men = \"Chernenko ] Andropov ] Brezhnev\";\nString[] list = split(men, \" ] \");\n// list[0] is now \"Chernenko\", list[1] is \"Andropov\"...\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value",
        "description": "String: the String to be split"
    }, {
        "name": "delim",
        "description": "char: the character or String used to separate the data"
    }]
}, {
    "name": "++ (increment)",
    "description": "\nIncreases the value of an integer variable by 1. Equivalent to the operation i = i + 1. If the value of the variable i is five, then the expression i++ increases the value of i to 6.\n",
    "syntax": "\nvalue++\n",
    "returns": "",
    "examples": ["\nint a = 1;   // Sets 'a' to 1 \nint b = a++; // Sets 'b' to 1, then increments 'a' to 2\nint c = a;   // Sets 'c' to 2 \n"],
    "examples_img": [],
    "parameters": [{
        "name": "value",
        "description": "int"
    }]
}, {
    "name": "textFont()",
    "description": "\nSets the current font that will be drawn with the text() function. Fonts must be created for Processing with createFont() or loaded with loadFont() before they can be used. The font set through textFont() will be used in all subsequent calls to the text() function. If no size parameter is input, the font will appear at its original size (the size in which it was created with the \"Create Font...\" tool) until it is changed with textSize().\n Because fonts are usually bitmapped, you should create fonts at the sizes that will be used most commonly. Using textFont() without the size parameter will result in the cleanest type. \n\nWith the default and PDF renderers, it's also possible to enable the use of native fonts via the command hint(ENABLE_NATIVE_FONTS). This will produce vector text in both on-screen sketches and PDF output when the vector data is available, such as when the font is still installed, or the font is created dynamically via the createFont() function (rather than with the \"Create Font...\" tool).\n",
    "syntax": "textFont(which)\ntextFont(which, size)",
    "returns": "void",
    "examples": ["\nPFont mono;\n// The font \"AndaleMono-48.vlw\"\" must be located in the \n// current sketch's \"data\" directory to load successfully\nmono = loadFont(\"AndaleMono-32.vlw\");\nbackground(0);\ntextFont(mono);\ntext(\"word\", 12, 60);\n"],
    "examples_img": ["https://www.processing.org/reference/images/textFont_.png"],
    "parameters": [{
        "name": "which",
        "description": "PFont: any variable of the type PFont"
    }, {
        "name": "size",
        "description": "float: the size of the letters in units of pixels"
    }]
}, {
    "name": "mouseClicked()",
    "description": "\nThe mouseClicked() function is called after a mouse button has been pressed and then released.\n\nMouse and keyboard events only work when a program has draw(). Without draw(), the code is only run once and then stops listening for events.\n",
    "syntax": "mouseClicked()\nmouseClicked(event)",
    "returns": "void",
    "examples": ["\n// Click within the image to change \n// the value of the rectangle after\n// after the mouse has been clicked\n\nint value = 0;\n\nvoid draw() {\n  fill(value);\n  rect(25, 25, 50, 50);\n}\n\nvoid mouseClicked() {\n  if (value == 0) {\n    value = 255;\n  } else {\n    value = 0;\n  }\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "shape()",
    "description": "\nDraws shapes to the display window. Shapes must be in the sketch's \"data\" directory to load correctly. Select \"Add file...\" from the \"Sketch\" menu to add the shape. Processing currently works with SVG, OBJ, and custom-created shapes. The shape parameter specifies the shape to display and the coordinate parameters define the location of the shape from its upper-left corner. The shape is displayed at its original size unless the c and d parameters specify a different size. The shapeMode() function can be used to change the way these parameters are interpreted.\n",
    "syntax": "shape(shape)\nshape(shape, x, y)\nshape(shape, a, b, c, d)",
    "returns": "void",
    "examples": ["\nPShape s;\n\nvoid setup() {\n  s = loadShape(\"bot.svg\");\n}\n\nvoid draw() {\n  shape(s, 10, 10, 80, 80);\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/shape_1.png"],
    "parameters": [{
        "name": "shape",
        "description": "PShape: the shape to display"
    }, {
        "name": "x",
        "description": "float: x-coordinate of the shape"
    }, {
        "name": "y",
        "description": "float: y-coordinate of the shape"
    }, {
        "name": "a",
        "description": "float: x-coordinate of the shape"
    }, {
        "name": "b",
        "description": "float: y-coordinate of the shape"
    }, {
        "name": "c",
        "description": "float: width to display the shape"
    }, {
        "name": "d",
        "description": "float: height to display the shape"
    }]
}, {
    "name": "static",
    "description": "\nKeyword used to define a variable as a \"class variable\" and a method as a \"class method.\" When a variable is declared with the static keyword, all instances of that class share the same variable. When a class is defined with the static keyword, it's methods can be used without making an instance of the class. The above examples demonstrate each of these uses.\n\nThis keyword is an essential part of Java programming and is not usually used with Processing. Consult a Java language reference or tutorial for more information. \n",
    "syntax": "",
    "returns": "",
    "examples": ["\nvoid setup() {\n  MiniClass mc1 = new MiniClass();\n  MiniClass mc2 = new MiniClass();\n  println( mc1.y );   // Prints \"10\" to the console\n  MiniClass.y += 10;  // The 'y' variable is shared by 'mc1' and 'mc2'\n  println( mc1.y );   // Prints \"20\" to the console\n  println( mc2.y );   // Prints \"20\" to the console\n}\n\nstatic class MiniClass {\n  static int y = 10;  // Class variable\n}\n", "\nvoid setup() {\n  println(MiniClass.add(3, 4));  // Prints \"7\" to the console\n}\n\nstatic class MiniClass {\n  static int add(int x, int y) {\n    return(x + y);\n  } \n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "textLeading()",
    "description": "\nSets the spacing between lines of text in units of pixels. This setting will be used in all subsequent calls to the text() function.  Note, however, that the leading is reset by textSize(). For example, if the leading is set to 20 with textLeading(20), then if textSize(48) is run at a later point, the leading will be reset to the default for the text size of 48.\n",
    "syntax": "textLeading(leading)",
    "returns": "void",
    "examples": ["\n// Text to display. The \"\\n\" is a \"new line\" character\nString lines = \"L1\\nL2\\nL3\";\ntextSize(12);\nfill(0);  // Set fill to black\n\ntextLeading(10);  // Set leading to 10\ntext(lines, 10, 25);\n\ntextLeading(20);  // Set leading to 20\ntext(lines, 40, 25);\n\ntextLeading(30);  // Set leading to 30\ntext(lines, 70, 25);\n"],
    "examples_img": ["https://www.processing.org/reference/images/textLeading_.png"],
    "parameters": [{
        "name": "leading",
        "description": "float: the size in pixels for spacing between lines"
    }]
}, {
    "name": "pmouseY",
    "description": "\nThe system variable pmouseY always contains the vertical position of the mouse in the frame previous to the current frame.\n\nFor more detail on how pmouseY is updated inside of mouse events and draw(), see the reference for pmouseX.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\n// Move the mouse quickly to see the difference \n// between the current and previous position \nvoid draw() { \n  background(204); \n  line(20, mouseY, 80, pmouseY); \n  println(mouseY + \" : \" + pmouseY);\n} \n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "super",
    "description": "\nKeyword used to reference the superclass of a subclass.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\n// This example is a code fragment;\n// it will not compile on its own.\n\n// Create the DragDrop subclass from\n// the Button class. Button becomes\n// the superclass of DragDrop.\nclass DragDrop extends Button {\n  int xoff, yoff;\n  DragDrop(int x, int y) {\n    // Runs the superclass' constructor\n    super(x, y);\n  }\n  void press(int mx, int my) {\n    // Runs the superclass' press() method\n    super.press();  \n    xoff = mx;\n    yoff = my;  \n  }\n}\n\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "import",
    "description": "\nThe keyword import is used to load a library into a Processing sketch. \nA library is one or more classes that are grouped together to extend the capabilities of Processing. \nThe * character is often used at the end of the import line (see the code example above)\nto load all of the related classes at once, without having to reference them individually.\n\nThe import statement will be created for you by selecting a library from the \"Import Library...\" \nitem in the Sketch menu.\n",
    "syntax": "\nimport libraryName\n",
    "returns": "",
    "examples": ["\nimport processing.pdf.*;\n\nvoid setup() {\n  size(screenWidth, screenHeight, PDF);\n}\n\nvoid draw() {\n  line(0, 0, width, height);\n  line(0, height, width, 0);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "libraryName",
        "description": "the name of the library to load (e.g. \"processing.pdf.*\")"
    }]
}, {
    "name": "size()",
    "description": "\nDefines the dimension of the display window in units of pixels. The size() function must be the first line of code, or the first code inside setup(). Any code that appears before the size() command may run more than once, which can lead to confusing results.\n\nThe system variables width and height are set by the parameters passed to this function. If size() is not used, the window will be given a default size of 100x100 pixels. \n\nThe size() function can only be used once inside a sketch, and it cannot be used for resizing.\n\nDo not use variables as the parameters to size() function, because it will cause problems when exporting your sketch. When variables are used, the dimensions of your sketch cannot be determined during export. Instead, employ numeric values in the size() statement, and then use the built-in width and height variables inside your program when the dimensions of the display window are needed.\n\nThe maximum width and height is limited by your operating system, and is usually the width and height of your actual screen. On some machines it may simply be the number of pixels on your current screen, meaning that a screen of 800x600 could support size(1600, 300), since that is the same number of pixels. This varies widely, so you'll have to try different rendering modes and sizes until you get what you're looking for. If you need something larger, use createGraphics to create a non-visible drawing surface.\n\nThe renderer parameter selects which rendering engine to use. For example, if you will be drawing 3D shapes, use P3D. In addition to the default renderer, other renderers are:\n\nP2D (Processing 2D): A renderer that supports two-dimensional drawing.\n\nP3D (Processing 3D): 3D graphics renderer that makes use of OpenGL-compatible graphics hardware.\n\nPDF: The PDF renderer draws 2D graphics directly to an Acrobat PDF file. This produces excellent results when you need vector shapes for high-resolution output or printing. You must first use Import Library  PDF to make use of the library. More information can be found in the PDF library reference.\n\n",
    "syntax": "size(w, h)\nsize(w, h, renderer)",
    "returns": "void",
    "examples": ["\nsize(200, 100);\nbackground(153);\nline(0, 0, width, height);\n", "\nvoid setup() {\n  size(320, 240);\n}\n\nvoid draw() {\n  background(153);\n  line(0, 0, width, height);\n}\n", "\nsize(150, 200, P3D);  // Specify P3D renderer\nbackground(153);\n\n// With P3D, we can use z (depth) values...\nline(0, 0, 0, width, height, -100);\nline(width, 0, 0, width, height, -100);\nline(0, height, 0, width, height, -100);\n\n//...and 3D-specific functions, like box()\ntranslate(width/2, height/2);\nrotateX(PI/6);\nrotateY(PI/6);\nbox(35);\n"],
    "examples_img": ["https://www.processing.org/reference/images/size_0.png", "https://www.processing.org/reference/images/size_1.png", "https://www.processing.org/reference/images/size_2.png"],
    "parameters": [{
        "name": "w",
        "description": "int: width of the display window in units of pixels"
    }, {
        "name": "h",
        "description": "int: height of the display window in units of pixels"
    }, {
        "name": "renderer",
        "description": "String: Either P2D, P3D, or PDF"
    }]
}, {
    "name": "textWidth()",
    "description": "\nCalculates and returns the width of any character or text string.\n",
    "syntax": "textWidth(c)\ntextWidth(str)",
    "returns": "float",
    "examples": ["\ntextSize(28);\n\nchar c = 'T';\nfloat cw = textWidth(c);\ntext(c, 0, 40);\nline(cw, 0, cw, 50); \n\nString s = \"Tokyo\";\nfloat sw = textWidth(s);\ntext(s, 0, 85);\nline(sw, 50, sw, 100);\n"],
    "examples_img": ["https://www.processing.org/reference/images/textWidth_.png"],
    "parameters": [{
        "name": "c",
        "description": "char: the character to measure"
    }, {
        "name": "str",
        "description": "String: the String of characters to measure"
    }]
}, {
    "name": "ellipse()",
    "description": "\nDraws an ellipse (oval) to the screen. An ellipse with equal width and height is a circle. By default, the first two parameters set the location, and the third and fourth parameters set the shape's width and height. The origin may be changed with the ellipseMode() function.\n",
    "syntax": "ellipse(a, b, c, d)",
    "returns": "void",
    "examples": ["\nellipse(56, 46, 55, 55);\n"],
    "examples_img": ["https://www.processing.org/reference/images/ellipse_.png"],
    "parameters": [{
        "name": "a",
        "description": "float: x-coordinate of the ellipse"
    }, {
        "name": "b",
        "description": "float: y-coordinate of the ellipse"
    }, {
        "name": "c",
        "description": "float: width of the ellipse by default"
    }, {
        "name": "d",
        "description": "float: height of the ellipse by default"
    }]
}, {
    "name": "PVector",
    "description": "\nA class to describe a two or three dimensional vector, specifically a Euclidean (also known as geometric) vector.   A vector is an entity that has both magnitude and direction.  The datatype, however, stores the components of the vector (x,y for 2D, and x,y,z for 3D).  The magnitude and direction can be accessed via the methods mag() and heading().\n\nIn many of the Processing examples, you will see PVector used to describe a position, velocity, or acceleration.  For example, if you consider a rectangle moving across the screen, at any given instant it has a position (a vector that points from the origin to its location), a velocity (the rate at which the object's position changes per time unit, expressed as a vector), and acceleration (the rate at which the object's velocity changes per time unit, expressed as a vector). Since vectors represent groupings of values, we cannot simply use traditional addition/multiplication/etc. Instead, we'll need to do some \"vector\" math, which is made easy by the methods inside the PVector class.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nPVector v1, v2;\n\nvoid setup() {\n  noLoop();\n  v1 = new PVector(40, 20);\n  v2 = new PVector(25, 50); \n}\n\nvoid draw() {\n  ellipse(v1.x, v1.y, 12, 12);\n  ellipse(v2.x, v2.y, 12, 12);\n  v2.add(v1);\n  ellipse(v2.x, v2.y, 24, 24);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "x",
        "description": "float: the x coordinate."
    }, {
        "name": "y",
        "description": "float: the y coordinate."
    }, {
        "name": "z",
        "description": "float: the z coordinate."
    }]
}, {
    "name": "else",
    "description": "\nExtends the if structure allowing the program to choose between two or more blocks of code. It specifies a block of code to execute when the expression in if is false.\n",
    "syntax": "\nif (expression) { \n  statements \n} else { \n  statements \n} \n\nif (expression) { \n  statements \n} else if (expression) { \n  statements \n} else { \n  statements \n}\n",
    "returns": "",
    "examples": ["\nfor (int i = 5; i < 95; i += 5) {\n  if (i < 35) {\n    line(30, i, 80, i);\n  } else {\n    line(20, i, 90, i);\n  }\n}\n", "\nfor (int i = 5; i < 95; i += 5) {\n  if (i < 35) {\n    line(30, i, 80, i);\n  } else if (i < 65) {\n    line(20, i, 90, i);\n  } else {\n    line(0, i, 100, i);\n  }\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/else0.png", "https://www.processing.org/reference/images/else1.png"],
    "parameters": [{
        "name": "expression",
        "description": "any valid expression that evaluates to true or false"
    }, {
        "name": "statements",
        "description": "one or more statements to be executed"
    }]
}, {
    "name": "sphere()",
    "description": "\nA sphere is a hollow ball made from tessellated triangles.\n",
    "syntax": "sphere(r)",
    "returns": "void",
    "examples": ["\nnoStroke();\nlights();\ntranslate(58, 48, 0);\nsphere(28);\n"],
    "examples_img": ["https://www.processing.org/reference/images/sphere_.png"],
    "parameters": [{
        "name": "r",
        "description": "float: the radius of the sphere"
    }]
}, {
    "name": "! (logical NOT)",
    "description": "\nInverts the Boolean value of an expression. Returns true if the expression is false and returns false if the expression is true. If the expression (a>b) evaluates to true, then !(a>b) evaluates to false. \n",
    "syntax": "\n!expression\n",
    "returns": "",
    "examples": ["\nboolean a = false;\nif (!a) {\n  rect(30, 20, 50, 50);\n}\na = true;\nif (a) {\n  line(20, 10, 90, 80);\n  line(20, 80, 90, 10);\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/logicalNOT.png"],
    "parameters": [{
        "name": "expression",
        "description": "any valid expression"
    }]
}, {
    "name": "implements",
    "description": "\nImplements an interface or group of interfaces. Interfaces are used to establish a protocol between classes; they establish the form for a class (method names, return types, etc.) but no implementation. After implementation, an interface can be used and extended like any other class.\n\nBecause Java doesn't allow extending more than one class at a time, you can create interfaces instead, so specific methods and fields can be found in the class which implements it. A Thread is an example; it implements the \"Runnable\" interface, which means the class has a method called \"public void run()\" inside it. \n",
    "syntax": "",
    "returns": "",
    "examples": ["\ninterface Dot {\n  void move();\n  void display();\n}\n\nclass CircleDot implements Dot {\n  float x = 50;\n  float y = 50;\n\n  void move() {\n    x = x + random(-1, 1);\n  }\n\n  void display() {\n    ellipse(x, y, 16, 16);\n  }\n}\n\nclass SquareDot implements Dot {\n  float x = 50;\n  float y = 50;\n\n\n  void move() {\n    y = y + random(-1, 1);\n  }\n\n  void display() {\n    rect(x, y, 16, 16);\n  }\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "final",
    "description": "\nKeyword used to state that a value, class, or method can't be changed. If the final keyword is used to define a variable, the variable can't be changed within the program. When used to define a class, a final class cannot be subclassed. When used to define a function or method, a final method can't be overridden by subclasses.\n\nThis keyword is an essential part of Java programming and is not usually used with Processing. Consult a Java language reference or tutorial for more information. \n",
    "syntax": "",
    "returns": "",
    "examples": ["\nfinal float constant = 12.84753;\nprintln(constant);  // Prints \"12.84753\" to the console\nconstant += 12.84;  // ERROR! It's not possible to change a \"final\" value\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "ellipseMode()",
    "description": "\nModifies the location from which ellipses are drawn by changing the way in which parameters given to ellipse() are intepreted.\n\nThe default mode is ellipseMode(CENTER), which interprets the first two parameters of ellipse() as the shape's center point, while the third and fourth parameters are its width and height.\n\nellipseMode(RADIUS) also uses the first two parameters of ellipse() as the shape's center point, but uses the third and fourth parameters to specify half of the shapes's width and height.\n\nellipseMode(CORNER) interprets the first two parameters of ellipse() as the upper-left corner of the shape, while the third and fourth parameters are its width and height.\n\nellipseMode(CORNERS) interprets the first two parameters of ellipse() as the location of one corner of the ellipse's bounding box, and the third and fourth parameters as the location of the opposite corner.\n\nThe parameter must be written in ALL CAPS because Processing is a case-sensitive language.\n",
    "syntax": "ellipseMode(mode)",
    "returns": "void",
    "examples": ["\nellipseMode(RADIUS);  // Set ellipseMode to RADIUS\nfill(255);  // Set fill to white\nellipse(50, 50, 30, 30);  // Draw white ellipse using RADIUS mode\n\nellipseMode(CENTER);  // Set ellipseMode to CENTER\nfill(100);  // Set fill to gray\nellipse(50, 50, 30, 30);  // Draw gray ellipse using CENTER mode\n", "\nellipseMode(CORNER);  // Set ellipseMode is CORNER\nfill(255);  // Set fill to white\nellipse(25, 25, 50, 50);  // Draw white ellipse using CORNER mode\n\nellipseMode(CORNERS);  // Set ellipseMode to CORNERS\nfill(100);  // Set fill to gray\nellipse(25, 25, 50, 50);  // Draw gray ellipse using CORNERS mode\n"],
    "examples_img": ["https://www.processing.org/reference/images/ellipseMode_0.png", "https://www.processing.org/reference/images/ellipseMode_1.png"],
    "parameters": [{
        "name": "mode",
        "description": "int: either CENTER, RADIUS, CORNER, or CORNERS"
    }]
}, {
    "name": "?: (conditional)",
    "description": "\nA shortcut for writing an if and else structure. The conditional operator, ?: is sometimes called the ternary operator, an operator that takes three arguments. If the test evaluates to true, expression1 is evaluated and returned. If the condition evaluates to false, expression2 is evaluated and returned.\n\nThe following conditional expression: \nresult = test ? expression1 : expression2\nis equivalent to this structure: \nif (test) {\n  result = expression1 \n} else { \n  result = expression2 \n}\n",
    "syntax": "\ntest ? expression1 : expression2\n",
    "returns": "",
    "examples": ["\nint s = 0;\nfor (int i = 5; i < 100; i += 5) {\n  s = (i < 50) ? 0 : 255;\n  stroke(s);\n  line(30, i, 80, i);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "test",
        "description": "any valid expression which evaluates to true or false"
    }, {
        "name": "expression1",
        "description": "any valid expression"
    }, {
        "name": "expression2",
        "description": "any valid expression"
    }]
}, {
    "name": "case",
    "description": "\nDenotes the different labels to be evaluated with the parameter in the switch structure.\n",
    "syntax": "\ncase label: statements\n",
    "returns": "",
    "examples": ["\nchar letter = 'B';\n\nswitch(letter) {\n  case 'A': \n    println(\"Alpha\");  // Does not execute\n    break;\n  case 'B': \n    println(\"Bravo\");  // Prints \"Bravo\"\n    break;\n  default:\n    println(\"Zulu\");   // Does not execute\n    break;\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "label",
        "description": "byte, char, or int"
    }, {
        "name": "statements",
        "description": "one or more valid statements"
    }]
}, {
    "name": "() (parentheses)",
    "description": "\nGrouping and containing expressions and parameters. Parentheses have multiple functions relating to functions and structures. They are used to contain a list of parameters passed to functions and control structures and they are used to group expressions to control the order of execution. Some functions have no parameters and in this case, the space between parentheses is blank.\n",
    "syntax": "\nfunction()\nfunction(p1, ..., pN)\nstructure(expression)\n",
    "returns": "",
    "examples": ["\nint a;\na = (4 + 3) * 2;       // Grouping expressions\nif (a > 10) {          // Containing expressions\n  line(a, 0, a, 100);  // Containing a list of parameters\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "function",
        "description": "any function"
    }, {
        "name": "p1, ..., pN",
        "description": "list of parameters specific to the function"
    }, {
        "name": "structure",
        "description": "Control structure such as if, for, while"
    }, {
        "name": "expressions",
        "description": "any valid expression or group of expression"
    }]
}, {
    "name": "bezierVertex()",
    "description": "\nSpecifies vertex coordinates for Bezier curves. Each call to bezierVertex() defines the position of two control points and one anchor point of a Bezier curve, adding a new segment to a line or shape. The first time bezierVertex() is used within a beginShape() call, it must be prefaced with a call to vertex() to set the first anchor point. This function must be used between beginShape() and endShape() and only when there is no MODE parameter specified to beginShape(). Using the 3D version requires rendering with P3D (see the Environment reference for more information).\n",
    "syntax": "bezierVertex(x2, y2, x3, y3, x4, y4)\nbezierVertex(x2, y2, z2, x3, y3, z3, x4, y4, z4)",
    "returns": "void",
    "examples": ["\nnoFill();\nbeginShape();\nvertex(30, 20);\nbezierVertex(80, 0, 80, 75, 30, 75);\nendShape();\n", "\nbeginShape();\nvertex(30, 20);\nbezierVertex(80, 0, 80, 75, 30, 75);\nbezierVertex(50, 80, 60, 25, 30, 20);\nendShape();\n"],
    "examples_img": ["https://www.processing.org/reference/images/bezierVertex_0.png", "https://www.processing.org/reference/images/bezierVertex_1.png"],
    "parameters": [{
        "name": "x2",
        "description": "float: the x-coordinate of the 1st control point"
    }, {
        "name": "y2",
        "description": "float: the y-coordinate of the 1st control point"
    }, {
        "name": "z2",
        "description": "float: the z-coordinate of the 1st control point"
    }, {
        "name": "x3",
        "description": "float: the x-coordinate of the 2nd control point"
    }, {
        "name": "y3",
        "description": "float: the y-coordinate of the 2nd control point"
    }, {
        "name": "z3",
        "description": "float: the z-coordinate of the 2nd control point"
    }, {
        "name": "x4",
        "description": "float: the x-coordinate of the anchor point"
    }, {
        "name": "y4",
        "description": "float: the y-coordinate of the anchor point"
    }, {
        "name": "z4",
        "description": "float: the z-coordinate of the anchor point"
    }]
}, {
    "name": "> (greater than)",
    "description": "\nTests if the value on the left is larger than the value on the right. \n",
    "syntax": "\nvalue1 > value2\n",
    "returns": "",
    "examples": ["\nint a = 5;\nint b = 13;\nif (b > a) {\n  println(\"variable b is larger the variable a\");\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1",
        "description": "int, float, char, or byte"
    }, {
        "name": "value2",
        "description": "int, float, char, or byte"
    }]
}, {
    "name": "mousePressed",
    "description": "\nThe mousePressed variable stores whether or not a mouse button is currently being pressed. The value is true when any mouse button is pressed, and false if no button is pressed. The mouseButton variable (see the related reference entry) can be used to determine which button has been pressed.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\n// Click within the image to change \n// the value of the rectangle\nvoid draw() {\n  if (mousePressed == true) {\n    fill(0);\n  } else {\n    fill(255);\n  }\n  rect(25, 25, 50, 50);\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "exit()",
    "description": "\nQuits/stops/exits the program. Programs without a draw() function exit automatically after the last line has run, but programs with draw() run continuously until the program is manually stopped or exit() is run.\n\nRather than terminating immediately, exit() will cause the sketch to exit after draw() has completed (or after setup() completes if called during the setup() function).\n\nFor Java programmers, this is not the same as System.exit(). Further, System.exit() should not be used because closing out an application while draw() is running may cause a crash (particularly with P3D).\n",
    "syntax": "exit()",
    "returns": "void",
    "examples": ["\nvoid draw() {\n  line(mouseX, mouseY, 50, 50);\n}\n\nvoid mousePressed() {\n  exit(); \n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "createShape()",
    "description": "\nThe createShape() function is used to define a new shape. Once created, this shape can be drawn with the shape() function. The basic way to use the function defines new primitive shapes. One of the following parameters are used as the first parameter: ELLIPSE, RECT, ARC, TRIANGLE, SPHERE, BOX, QUAD, or LINE. The parameters for each of these different shapes are the same as their corresponding functions: ellipse(), rect(), arc(), triangle(), sphere(), box(), and line(). The first example above clarifies how this works.\n\nCustom, unique shapes can be made by using createShape() without a parameter. After the shape is started, the drawing attributes and geometry can be set directly to the shape within the beginShape() and endShape() methods. See the second example above for specifics.\n\nGeometry that groups vertices to build larger forms, such as group of triangles, can be created with parameters to beginShape(). These options are POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, and QUAD_STRIP. See the third example above.\n\nThe  createShape() function can also be used to make a complex shape made of other shapes. This is called a \"group\" and it's created by using the parameter GROUP as the first parameter. See the fourth example above to see how it works.\n\nWhen a shape is first created inside the beginShape() and endShape() methods, the normal Processing style functions like fill() and stroke() are used to define the drawing attributes. However, after a shape is created, a different set of functions needs to be used. These include the setFill() and setStroke() functions shown in the examples above. The complete list of methods and fields for the PShape class are in the Processing Javadoc.\n",
    "syntax": "createShape()\ncreateShape(source)\ncreateShape(type)\ncreateShape(kind, p)",
    "returns": "PShape",
    "examples": ["\nPShape square;  // The PShape object\n\nvoid setup() {\n  size(100, 100, P2D);\n  // Creating the PShape as a square. The\n  // numeric arguments are similar to rect().\n  square = createShape(RECT, 0, 0, 50, 50);\n  square.setFill(color(0, 0, 255));\n  square.setStroke(false);\n}\n\nvoid draw() {\n  shape(square, 25, 25);\n}\n", "\nPShape s;  // The PShape object\n\nvoid setup() {\n  size(100, 100, P2D);\n  // Creating a custom PShape as a square, by\n  // specifying a series of vertices.\n  s = createShape();\n  s.beginShape();\n  s.fill(0, 0, 255);\n  s.noStroke();\n  s.vertex(0, 0);\n  s.vertex(0, 50);\n  s.vertex(50, 50);\n  s.vertex(50, 0);\n  s.endShape(CLOSE);\n}\n\nvoid draw() {\n  shape(s, 25, 25);\n}\n", "\nPShape s;\n\nvoid setup() {\n  size(100, 100, P2D);\n  s = createShape();\n  s.beginShape(TRIANGLE_STRIP);\n  s.vertex(30, 75);\n  s.vertex(40, 20);\n  s.vertex(50, 75);\n  s.vertex(60, 20);\n  s.vertex(70, 75);\n  s.vertex(80, 20);\n  s.vertex(90, 75);\n  s.endShape();\n}\n\nvoid draw() {\n  shape(s, 0, 0);\n}\n", "\nPShape alien, head, body;\n\nvoid setup() {\n  size(100, 100, P2D);\n\n  // Create the shape group\n  alien = createShape(GROUP);\n\n  // Make two shapes\n  head = createShape(ELLIPSE, -25, 0, 50, 50);\n  head.setFill(color(255));\n  body = createShape(RECT, -25, 45, 50, 40);\n  body.setFill(color(0));\n\n  // Add the two \"child\" shapes to the parent group\n  alien.addChild(body);\n  alien.addChild(head);\n}\n\nvoid draw() {\n  background(204);\n  translate(50, 15);\n  shape(alien); // Draw the group\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "type",
        "description": "int: either POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, QUAD_STRIP"
    }, {
        "name": "kind",
        "description": "int: either LINE, TRIANGLE, RECT, ELLIPSE, ARC, SPHERE, BOX"
    }, {
        "name": "p",
        "description": "float[]: parameters that match the kind of shape"
    }]
}, {
    "name": "loadShape()",
    "description": "\nLoads geometry into a variable of type PShape. SVG and OBJ files may be loaded. To load correctly, the file must be located in the data directory of the current sketch. In most cases, loadShape() should be used inside setup() because loading shapes inside draw() will reduce the speed of a sketch.\n\nAlternatively, the file maybe be loaded from anywhere on the local computer using an absolute path (something that starts with / on Unix and Linux, or a drive letter on Windows), or the filename parameter can be a URL for a file found on a network.\n\nIf the file is not available or an error occurs, null will be returned and an error message will be printed to the console. The error message does not halt the program, however the null value may cause a NullPointerException if your code does not check whether the value returned is null.\n",
    "syntax": "loadShape(filename)",
    "returns": "PShape",
    "examples": ["\nPShape s;\n\nvoid setup() {\n  size(100, 100);\n  // The file \"bot.svg\" must be in the data folder\n  // of the current sketch to load successfully\n  s = loadShape(\"bot.svg\");\n}\n\nvoid draw() {\n  shape(s, 10, 10, 80, 80);\n}\n", "\nPShape s;\n\nvoid setup() {\n  size(100, 100, P3D);\n  // The file \"bot.obj\" must be in the data folder\n  // of the current sketch to load successfully\n  s = loadShape(\"bot.obj\");\n}\n\nvoid draw() {\n  background(204);\n  translate(width/2, height/2);\n  shape(s, 0, 0);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: name of file to load, can be .svg or .obj"
    }]
}, {
    "name": "binary()",
    "description": "\nConverts an int, byte, char, or color to a String containing the equivalent binary notation. For example, the color value produced by color(0, 102, 153, 255) will convert to the String value \"11111111000000000110011010011001\". This function can help make your geeky debugging sessions much happier.\n\nNote that the maximum number of digits is 32, because an int value can only represent up to 32 bits. Specifying more than 32 digits will have no effect.\n",
    "syntax": "binary(value)\nbinary(value, digits)",
    "returns": "String",
    "examples": ["\ncolor c = color(255, 204, 0);\nprintln(c);             // Prints \"-13312\"\nprintln(binary(c));     // Prints \"11111111111111111100110000000000\"\nprintln(binary(c, 16)); // Prints \"1100110000000000\"\n\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value",
        "description": "char, byte, or int: value to convert"
    }, {
        "name": "digits",
        "description": "int: number of digits to return"
    }]
}, {
    "name": "mouseButton",
    "description": "\nWhen a mouse button is pressed, the value of the system variable mouseButton is set to either LEFT, RIGHT, or CENTER, depending on which button is pressed. (If no button is pressed, mouseButton may be reset to 0. For that reason, it's best to use mousePressed first to test if any button is being pressed, and only then test the value of mouseButton, as shown in the examples above.)\n",
    "syntax": "",
    "returns": "",
    "examples": ["\n// Click within the image and press\n// the left and right mouse buttons to \n// change the value of the rectangle\nvoid draw() {\n  if (mousePressed && (mouseButton == LEFT)) {\n    fill(0);\n  } else if (mousePressed && (mouseButton == RIGHT)) {\n    fill(255);\n  } else {\n    fill(126);\n  }\n  rect(25, 25, 50, 50);\n}\n", "\n// Click within the image and press\n// the left and right mouse buttons to \n// change the value of the rectangle\nvoid draw() {\n  rect(25, 25, 50, 50);\n}\n\nvoid mousePressed() {\n  if (mouseButton == LEFT) {\n    fill(0);\n  } else if (mouseButton == RIGHT) {\n    fill(255);\n  } else {\n    fill(126);\n  }\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "vertex()",
    "description": "\nAll shapes are constructed by connecting a series of vertices. vertex() is used to specify the vertex coordinates for points, lines, triangles, quads, and polygons. It is used exclusively within the beginShape() and endShape() functions.\n\nDrawing a vertex in 3D using the z parameter requires the P3D parameter in combination with size, as shown in the above example.\n\nThis function is also used to map a texture onto geometry. The texture() function declares the texture to apply to the geometry and the u and v coordinates set define the mapping of this texture to the form. By default, the coordinates used for u and v are specified in relation to the image's size in pixels, but this relation can be changed with textureMode().\n",
    "syntax": "vertex(x, y)\nvertex(x, y, z)\nvertex(v)\nvertex(x, y, u, v)\nvertex(x, y, z, u, v)",
    "returns": "void",
    "examples": ["\nbeginShape(POINTS);\nvertex(30, 20);\nvertex(85, 20);\nvertex(85, 75);\nvertex(30, 75);\nendShape();\n", "\n// Drawing vertices in 3D requires P3D\n// as a parameter to size()\nsize(100, 100, P3D);\nbeginShape(POINTS);\nvertex(30, 20, -50);\nvertex(85, 20, -50);\nvertex(85, 75, -50);\nvertex(30, 75, -50);\nendShape();\n", "\nsize(100, 100, P3D);\nPImage img = loadImage(\"laDefense.jpg\");\nnoStroke();\nbeginShape();\ntexture(img);\n// \"laDefense.jpg\" is 100x100 pixels in size so\n// the values 0 and 100 are used for the\n// parameters \"u\" and \"v\" to map it directly\n// to the vertex points\nvertex(10, 20, 0, 0);\nvertex(80, 5, 100, 0);\nvertex(95, 90, 100, 100);\nvertex(40, 95, 0, 100);\nendShape();\n"],
    "examples_img": ["https://www.processing.org/reference/images/vertex_0.png", "https://www.processing.org/reference/images/vertex_1.png", "https://www.processing.org/reference/images/vertex_2.png"],
    "parameters": [{
        "name": "v",
        "description": "float[]: vertex parameters, as a float array of length VERTEX_FIELD_COUNT"
    }, {
        "name": "x",
        "description": "float: x-coordinate of the vertex"
    }, {
        "name": "y",
        "description": "float: y-coordinate of the vertex"
    }, {
        "name": "z",
        "description": "float: z-coordinate of the vertex"
    }, {
        "name": "u",
        "description": "float: horizontal coordinate for the texture mapping"
    }, {
        "name": "v",
        "description": "float: vertical coordinate for the texture mapping"
    }]
}, {
    "name": "mousePressed()",
    "description": "\nThe mousePressed() function is called once after every time a mouse button is pressed. The mouseButton variable (see the related reference entry) can be used to determine which button has been pressed.\n\nMouse and keyboard events only work when a program has draw(). Without draw(), the code is only run once and then stops listening for events.\n",
    "syntax": "mousePressed()\nmousePressed(event)",
    "returns": "void",
    "examples": ["\n// Click within the image to change \n// the value of the rectangle\n\nint value = 0;\n\nvoid draw() {\n  fill(value);\n  rect(25, 25, 50, 50);\n}\n\nvoid mousePressed() {\n  if (value == 0) {\n    value = 255;\n  } else {\n    value = 0;\n  }\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "beginShape()",
    "description": "\nUsing the beginShape() and endShape() functions allow creating more complex forms. beginShape() begins recording vertices for a shape and endShape() stops recording. The value of the kind parameter tells it which types of shapes to create from the provided vertices. With no mode specified, the shape can be any irregular polygon. The parameters available for beginShape() are POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, and QUAD_STRIP. After calling the beginShape() function, a series of vertex() commands must follow. To stop drawing the shape, call endShape(). The vertex() function with two parameters specifies a position in 2D and the vertex() function with three parameters specifies a position in 3D. Each shape will be outlined with the current stroke color and filled with the fill color. \n\nTransformations such as translate(), rotate(), and scale() do not work within beginShape(). It is also not possible to use other shapes, such as ellipse() or rect() within beginShape(). \n\nThe P2D and P3D renderers allow stroke() and fill() to be altered on a per-vertex basis, but the default renderer does not. Settings such as strokeWeight(), strokeCap(), and strokeJoin() cannot be changed while inside a beginShape()/endShape() block with any renderer.\n",
    "syntax": "beginShape()\nbeginShape(kind)",
    "returns": "void",
    "examples": ["\nbeginShape();\nvertex(30, 20);\nvertex(85, 20);\nvertex(85, 75);\nvertex(30, 75);\nendShape(CLOSE);\n", "\nbeginShape(POINTS);\nvertex(30, 20);\nvertex(85, 20);\nvertex(85, 75);\nvertex(30, 75);\nendShape();\n", "\nbeginShape(LINES);\nvertex(30, 20);\nvertex(85, 20);\nvertex(85, 75);\nvertex(30, 75);\nendShape();\n", "\nnoFill();\nbeginShape();\nvertex(30, 20);\nvertex(85, 20);\nvertex(85, 75);\nvertex(30, 75);\nendShape();\n", "\nnoFill();\nbeginShape();\nvertex(30, 20);\nvertex(85, 20);\nvertex(85, 75);\nvertex(30, 75);\nendShape(CLOSE);\n", "\nbeginShape(TRIANGLES);\nvertex(30, 75);\nvertex(40, 20);\nvertex(50, 75);\nvertex(60, 20);\nvertex(70, 75);\nvertex(80, 20);\nendShape();\n", "\nbeginShape(TRIANGLE_STRIP);\nvertex(30, 75);\nvertex(40, 20);\nvertex(50, 75);\nvertex(60, 20);\nvertex(70, 75);\nvertex(80, 20);\nvertex(90, 75);\nendShape();\n", "\nbeginShape(TRIANGLE_FAN);\nvertex(57.5, 50);\nvertex(57.5, 15); \nvertex(92, 50); \nvertex(57.5, 85); \nvertex(22, 50); \nvertex(57.5, 15); \nendShape();\n", "\nbeginShape(QUADS);\nvertex(30, 20);\nvertex(30, 75);\nvertex(50, 75);\nvertex(50, 20);\nvertex(65, 20);\nvertex(65, 75);\nvertex(85, 75);\nvertex(85, 20);\nendShape();\n", "\nbeginShape(QUAD_STRIP); \nvertex(30, 20); \nvertex(30, 75); \nvertex(50, 20);\nvertex(50, 75);\nvertex(65, 20); \nvertex(65, 75); \nvertex(85, 20);\nvertex(85, 75); \nendShape();\n", "\nbeginShape();\nvertex(20, 20);\nvertex(40, 20);\nvertex(40, 40);\nvertex(60, 40);\nvertex(60, 60);\nvertex(20, 60);\nendShape(CLOSE);\n"],
    "examples_img": ["https://www.processing.org/reference/images/beginShape_0.png", "https://www.processing.org/reference/images/beginShape_1.png", "https://www.processing.org/reference/images/beginShape_2.png", "https://www.processing.org/reference/images/beginShape_3.png", "https://www.processing.org/reference/images/beginShape_4.png", "https://www.processing.org/reference/images/beginShape_5.png", "https://www.processing.org/reference/images/beginShape_6.png", "https://www.processing.org/reference/images/beginShape_7.png", "https://www.processing.org/reference/images/beginShape_8.png", "https://www.processing.org/reference/images/beginShape_9.png", "https://www.processing.org/reference/images/beginShape_10.png"],
    "parameters": [{
        "name": "kind",
        "description": "int: Either POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, or QUAD_STRIP"
    }]
}, {
    "name": "mouseMoved()",
    "description": "\nThe mouseMoved() function is called every time the mouse moves and a mouse button is not pressed. (If a button is being pressed, mouseDragged() is called instead.)\n\nMouse and keyboard events only work when a program has draw(). Without draw(), the code is only run once and then stops listening for events.\n",
    "syntax": "mouseMoved()\nmouseMoved(event)",
    "returns": "void",
    "examples": ["\n// Move the mouse across the image\n// to change its value\n\nint value = 0;\n\nvoid draw() {\n  fill(value);\n  rect(25, 25, 50, 50);\n}\n\nvoid mouseMoved() {\n  value = value + 5;\n  if (value > 255) {\n    value = 0;\n  }\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "nfs()",
    "description": "\nUtility function for formatting numbers into strings. Similar to nf(), but leaves a blank space in front of positive numbers so they align with negative numbers in spite of the minus symbol. There are two versions: one for formatting floats, and one for formatting ints. The values for the digits, left, and right parameters should always be positive integers.\n",
    "syntax": "nfs(num, digits)\nnfs(num, left, right)",
    "returns": "String or String[]",
    "examples": ["\nint a=200, b=-40, c=90; \nString sa = nfs(a, 10); \nprintln(sa);  // Prints \" 0000000200\" \nString sb = nfs(b, 5); \nprintln(sb);  // Prints \"-00040\" \nString sc = nfs(c, 3); \nprintln(sc);  // Prints \" 090\" \n \nfloat d = -200.94, e = 40.2, f = -9.012; \nString sd = nfs(d, 10, 4); \nprintln(sd);  // Prints \"-0000000200.9400\" \nString se = nfs(e, 5, 3); \nprintln(se);  // Prints \" 00040.200\" \nString sf = nfs(f, 3, 5); \nprintln(sf);  // Prints \"-009.01200\" \n"],
    "examples_img": [],
    "parameters": [{
        "name": "num",
        "description": "float[], int[], or int: the number(s) to format"
    }, {
        "name": "digits",
        "description": "int: number of digits to pad with zeroes"
    }, {
        "name": "left",
        "description": "int: the number of digits to the left of the decimal point"
    }, {
        "name": "right",
        "description": "int: the number of digits to the right of the decimal point"
    }]
}, {
    "name": "bezierPoint()",
    "description": "\nEvaluates the Bezier at point t for points a, b, c, d. The parameter t varies between 0 and 1, a and d are points on the curve, and b and c are the control points. This can be done once with the x coordinates and a second time with the y coordinates to get the location of a bezier curve at t.\n",
    "syntax": "bezierPoint(a, b, c, d, t)",
    "returns": "float",
    "examples": ["\nnoFill();\nbezier(85, 20, 10, 10, 90, 90, 15, 80);\nfill(255);\nint steps = 10;\nfor (int i = 0; i "],
    "examples_img": ["https://www.processing.org/reference/images/bezierPoint_.png"],
    "parameters": [{
        "name": "a",
        "description": "float: coordinate of first point on the curve"
    }, {
        "name": "b",
        "description": "float: coordinate of first control point"
    }, {
        "name": "c",
        "description": "float: coordinate of second control point"
    }, {
        "name": "d",
        "description": "float: coordinate of second point on the curve"
    }, {
        "name": "t",
        "description": "float: value between 0 and 1"
    }]
}, {
    "name": "for",
    "description": "\nControls a sequence of repetitions. A basic for structure has three parts: init, test, and update. Each part must be separated by a semicolon (;). The loop continues until the test evaluates to false. When a for structure is executed, the following sequence of events occurs:\n\n1. The init statement is run.\n2. The test is evaluated to be true or false.\n3. If the test is true, jump to step 4. If the test is false, jump to step 6.\n4. Run the statements within the block.\n5. Run the update statement and jump to step 2.\n6. Exit the loop.\n\nIn the first example above, the for structure is executed 40 times. In the init statement, the value i is created and set to zero. i is less than 40, so the test evaluates as true. At the end of each loop, i is incremented by one. On the 41st execution, the test is evaluated as false, because i is then equal to 40, so i < 40 is no longer true. Thus, the loop exits.\n\nA second type of for structure makes it easier to iterate over each element of an array. The last example above shows how it works. Within the parentheses, first define the datatype of the array, then define a variable name. This variable name will be assigned to each element of the array in turn as the for moves through the entire array. Finally, after the colon, define the array name to be used. \n",
    "syntax": "\nfor (init; test; update) { \n  statements\n} \n\nfor (datatype element : array) { \n  statements\n}\n",
    "returns": "",
    "examples": ["\nfor (int i = 0; i < 40; i = i+1) {\n  line(30, i, 80, i);\n}\n", "\nfor (int i = 0; i < 80; i = i+5) {\n  line(30, i, 80, i);\n}\n", "\nfor (int i = 40; i < 80; i = i+5) {\n  line(30, i, 80, i);\n}\n", "\n// Nested for() loops can be used to\n// generate two-dimensional patterns\nfor (int i = 30; i < 80; i = i+5) {\n  for (int j = 0; j < 80; j = j+5) {\n    point(i, j);\n  }\n}\n", "\n// This example has no visual output,\n// but prints values to the console.\n\nint[] nums = { 5, 4, 3, 2, 1 };\n\nfor (int i : nums) {\n  println(i); \n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/for_0.png", "https://www.processing.org/reference/images/for_1.png", "https://www.processing.org/reference/images/for_2.png", "https://www.processing.org/reference/images/for_3.png"],
    "parameters": [{
        "name": "init",
        "description": "statement executed once when beginning loop"
    }, {
        "name": "test",
        "description": "if the test evaluates to true, the statements execute"
    }, {
        "name": "update",
        "description": "executes at the end of each iteration"
    }, {
        "name": "statements",
        "description": "collection of statements executed each time through the loop"
    }, {
        "name": "datatype",
        "description": "datatype of elements in the array"
    }, {
        "name": "element",
        "description": "temporary name to use for each element of the array"
    }, {
        "name": "array",
        "description": "name of the array to iterate through"
    }]
}, {
    "name": "continue",
    "description": "\nWhen run inside of a for or while, it skips the remainder of the block and starts the next iteration.\n",
    "syntax": "\ncontinue\n",
    "returns": "",
    "examples": ["\nfor (int i = 0; i < 100; i += 10) {\n  if (i == 70) {  // If 'i' is 70,\n    continue;     // skip to the next iteration,\n  }               // therefore not drawing the line.\n  line(i, 0, i, height);\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "createReader()",
    "description": "\nCreates a BufferedReader object that can be used to read files line-by-line as individual String objects. This is the complement to the createWriter() function.\n \nStarting with Processing release 0134, all files loaded and saved by the Processing API use UTF-8 encoding. In previous releases, the default encoding for your platform was used, which causes problems when files are moved to other platforms.\n",
    "syntax": "createReader(filename)",
    "returns": "BufferedReader",
    "examples": ["\nBufferedReader reader;\nString line;\n \nvoid setup() {\n  // Open the file from the createWriter() example\n  reader = createReader(\"positions.txt\");    \n}\n \nvoid draw() {\n  try {\n    line = reader.readLine();\n  } catch (IOException e) {\n    e.printStackTrace();\n    line = null;\n  }\n  if (line == null) {\n    // Stop reading because of an error or file is empty\n    noLoop();  \n  } else {\n    String[] pieces = split(line, TAB);\n    int x = int(pieces[0]);\n    int y = int(pieces[1]);\n    point(x, y);\n  }\n} \n"],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: name of the file to be opened"
    }]
}, {
    "name": "StringDict",
    "description": "\nA simple class to use a String as a lookup for an String value. String \"keys\" are associated with String values.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nStringDict inventory;\n\nvoid setup() {\n  size(200, 200);\n  inventory = new StringDict();\n  inventory.set(\"coffee\",\"black\");\n  inventory.set(\"flour\",\"white\");\n  inventory.set(\"tea\",\"green\");\n  println(inventory);\n  noLoop();\n  fill(0);\n  textAlign(CENTER);\n}\n\nvoid draw() {\n  String s = inventory.get(\"tea\");\n  text(s, width/2, height/2);\n}\n\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "bezierDetail()",
    "description": "\nSets the resolution at which Beziers display. The default value is 20. This function is only useful when using the P3D renderer; the default P2D renderer does not use this information.\n",
    "syntax": "bezierDetail(detail)",
    "returns": "void",
    "examples": ["\n// Move the mouse left and right to see the detail change\n\nvoid setup() {\n  size(100, 100, P3D);\n  noFill();\n}\n\nvoid draw() {\n  background(204);\n  int d = int(map(mouseX, 0, 100, 1, 20));\n  bezierDetail(d);\n  bezier(85, 20, 10, 10, 90, 90, 15, 80);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "detail",
        "description": "int: resolution of the curves"
    }]
}, {
    "name": "open()",
    "description": "\nAttempts to open an application or file using your platform's launcher. The filename parameter is a String specifying the file name and location. The location parameter must be a full path name, or the name of an executable in the system's PATH. In most cases, using a full path is the best option, rather than relying on the system PATH. Be sure to make the file executable before attempting to open it (chmod +x). \n \nThe argv parameter is a String or String array which is passed to the command line. If you have multiple parameters, e.g. an application and a document, or a command with multiple switches, use the version that takes a String array, and place each individual item in a separate element. \n \nIf argv is a String (not an array), then it can only be a single file or application with no parameters. It's not the same as executing that String using a shell. For instance, open(\"jikes -help\") will not work properly.\n \nThis function behaves differently on each platform. On Windows, the parameters are sent to the Windows shell via \"cmd /c\". On Mac OS X, the \"open\" command is used (type \"man open\" in Terminal.app for documentation). On Linux, it first tries gnome-open, then kde-open, but if neither are available, it sends the command to the shell without any alterations. \n \nFor users familiar with Java, this is not quite the same as Runtime.exec(), because the launcher command is prepended. Instead, the exec(String[]) function is a shortcut for Runtime.getRuntime.exec(String[]). \n",
    "syntax": "open(filename)\nopen(argv)",
    "returns": "void or Process",
    "examples": ["\nvoid setup() {\n  size(200, 200);\n}\n\nvoid draw() { \n  // draw() must be present for mousePressed() to work\n}\n\nvoid mousePressed() {\n  println(\"Opening Process_4\");\n  open(\"/Applications/Process_4.app\");\n}\n\n", "\nvoid setup() {\n  size(200, 200);\n}\n\nvoid draw() { \n  // draw() must be present for mousePressed() to work\n}\n\nvoid mousePressed() {\n  String[] params = { \"/usr/bin/jikes\", \"-help\" };\n  open(params);\n}\n\n"],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: name of the file"
    }, {
        "name": "argv",
        "description": "String[]: list of commands passed to the command line"
    }]
}, {
    "name": "loadJSONObject()",
    "description": "\nLoads a JSON from the data folder or a URL, and returns a JSONObject.\n\nAll files loaded and saved by the Processing API use UTF-8 encoding.\n",
    "syntax": "loadJSONObject(filename)\nloadJSONObject(file)",
    "returns": "JSONObject",
    "examples": ["\n// The following short JSON file called \"data.json\" is parsed \n// in the code below. It must be in the project's \"data\" folder.\n//\n// {\n//   \"id\": 0,\n//   \"species\": \"Panthera leo\",\n//   \"name\": \"Lion\"\n// }\n\nJSONObject json;\n\nvoid setup() {\n\n  json = loadJSONObject(\"data.json\");\n\n  int id = json.getInt(\"id\");\n  String species = json.getString(\"species\");\n  String name = json.getString(\"name\");\n\n  println(id + \", \" + species + \", \" + name);\n}\n\n// Sketch prints:\n// 0, Panthera leo, Lion\n"],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: name of a file in the data folder or a URL"
    }]
}, {
    "name": "XML",
    "description": "\nXML is a representation of an XML object, able to parse XML code. Use loadXML() to load external XML files and create XML objects.\n\nOnly files encoded as UTF-8 (or plain ASCII) are parsed properly; the encoding parameter inside XML files is ignored.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\n// The following short XML file called \"mammals.xml\" is parsed \n// in the code below. It must be in the project's \"data\" folder.\n//\n// <?xml version=\"1.0\"?>\n// <mammals>\n//   <animal id=\"0\" species=\"Capra hircus\">Goat</animal>\n//   <animal id=\"1\" species=\"Panthera pardus\">Leopard</animal>\n//   <animal id=\"2\" species=\"Equus zebra\">Zebra</animal>\n// </mammals>\n\nXML xml;\n\nvoid setup() {\n  xml = loadXML(\"mammals.xml\");\n  XML[] children = xml.getChildren(\"animal\");\n\n  for (int i = 0; i < children.length; i++) {\n    int id = children[i].getInt(\"id\");\n    String coloring = children[i].getString(\"species\");\n    String name = children[i].getContent();\n    println(id + \", \" + coloring + \", \" + name);\n  }\n}\n\n// Sketch prints:\n// 0, Capra hircus, Goat\n// 1, Panthera pardus, Leopard\n// 2, Equus zebra, Zebra\n"],
    "examples_img": [],
    "parameters": [{
        "name": "name",
        "description": "String: creates a node with this name"
    }]
}, {
    "name": "splitTokens()",
    "description": "\nThe splitTokens() function splits a String at one or many character delimiters or \"tokens.\" The delim parameter specifies the character or characters to be used as a boundary.\n\nIf no delim characters are specified, any whitespace character is used to split. Whitespace characters include tab (\\t), line feed (\\n), carriage return (\\r), form feed (\\f), and space.\n\nAfter using this function to parse incoming data, it is common to convert the data from Strings to integers or floats by using the datatype conversion functions int() and float().\n",
    "syntax": "splitTokens(value)\nsplitTokens(value, delim)",
    "returns": "String[]",
    "examples": ["\nString t = \"a b\";\nString[] q = splitTokens(t);\nprintln(q[0]);  // Prints \"a\"\nprintln(q[1]);  // Prints \"b\"\n", "\n// Despite the bad formatting, the data is parsed correctly.\n// The \", \" as delimiter means to break whenever a comma *or*\n// a space is found in the String. Unlike the split() function, \n// multiple adjacent delimiters are treated as a single break.\nString s = \"a, b c ,,d \"; \nString[] q = splitTokens(s, \", \");\nprintln(q.length + \" values found\");  // Prints \"4 values found\"\nprintln(q[0]);  // Prints \"a\"\nprintln(q[1]);  // Prints \"b\"\nprintln(q[2]);  // Prints \"c\"\nprintln(q[3]);  // Prints \"d\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value",
        "description": "String: the String to be split"
    }, {
        "name": "delim",
        "description": "String: list of individual characters that will be used as separators"
    }]
}, {
    "name": "endShape()",
    "description": "\nThe endShape() function is the companion to beginShape() and may only be called after beginShape(). When endshape() is called, all of image data defined since the previous call to beginShape() is written into the image buffer. The constant CLOSE as the value for the MODE parameter to close the shape (to connect the beginning and the end). \n",
    "syntax": "endShape()\nendShape(mode)",
    "returns": "void",
    "examples": ["\nnoFill();\n\nbeginShape();\nvertex(20, 20);\nvertex(45, 20);\nvertex(45, 80);\nendShape(CLOSE);\n\nbeginShape();\nvertex(50, 20);\nvertex(75, 20);\nvertex(75, 80);\nendShape();\n"],
    "examples_img": ["https://www.processing.org/reference/images/endShape_.png"],
    "parameters": [{
        "name": "mode",
        "description": "int: use CLOSE to close the shape"
    }]
}, {
    "name": "point()",
    "description": "\nDraws a point, a coordinate in space at the dimension of one pixel. The first parameter is the horizontal value for the point, the second value is the vertical value for the point, and the optional third value is the depth value. Drawing this shape in 3D with the z parameter requires the P3D parameter in combination with size() as shown in the above example.\n",
    "syntax": "point(x, y)\npoint(x, y, z)",
    "returns": "void",
    "examples": ["\nnoSmooth();\npoint(30, 20);\npoint(85, 20);\npoint(85, 75);\npoint(30, 75);\n", "\nsize(100, 100, P3D);\nnoSmooth();\npoint(30, 20, -50);\npoint(85, 20, -50);\npoint(85, 75, -50);\npoint(30, 75, -50);\n"],
    "examples_img": ["https://www.processing.org/reference/images/point_0.png", "https://www.processing.org/reference/images/point_1.png"],
    "parameters": [{
        "name": "x",
        "description": "float: x-coordinate of the point"
    }, {
        "name": "y",
        "description": "float: y-coordinate of the point"
    }, {
        "name": "z",
        "description": "float: z-coordinate of the point"
    }]
}, {
    "name": "mouseDragged()",
    "description": "\nThe mouseDragged() function is called once every time the mouse moves while a mouse button is pressed. (If a button is not being pressed, mouseMoved() is called instead.)\n\nMouse and keyboard events only work when a program has draw(). Without draw(), the code is only run once and then stops listening for events.\n",
    "syntax": "mouseDragged()\nmouseDragged(event)",
    "returns": "void",
    "examples": ["\n// Drag (click and hold) your mouse across the \n// image to change the value of the rectangle\n\nint value = 0;\n\nvoid draw() {\n  fill(value);\n  rect(25, 25, 50, 50);\n}\n\nvoid mouseDragged() \n{\n  value = value + 5;\n  if (value > 255) {\n    value = 0;\n  }\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "IntList",
    "description": "\nHelper class for a list of ints. Lists are designed to have some of the \nfeatures of ArrayLists, but to maintain the simplicity and efficiency of\nworking with arrays. \n\nFunctions like sort() and shuffle() always act on the list itself. To get \na sorted copy, use list.copy().sort().\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nIntList inventory;\n\nvoid setup() {\n  size(200, 200);\n  inventory = new IntList();\n  inventory.append(84);\n  inventory.append(15);\n  inventory.append(102);\n  println(inventory);\n  noLoop();\n  fill(0);\n  textAlign(CENTER);\n}\n\nvoid draw() {\n  int nums = inventory.get(2);\n  text(nums, width/2, height/2);\n}\n\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "private",
    "description": "\nKeyword used to disallow other classes access the fields and methods within a class. The private keyword is used before a field or method that you want to be available only within the class. In Processing, all fields and methods are public unless otherwise specified by the private keyword.\n\nThis keyword is an essential part of Java programming and is not usually used with Processing. Consult a Java language reference or tutorial for more information. \n",
    "syntax": "",
    "returns": "",
    "examples": [],
    "examples_img": [],
    "parameters": []
}, {
    "name": "loadXML()",
    "description": "\nReads the contents of a file or URL and creates an XML object with its values. If a file is specified, it must be located in the sketch's \"data\" folder. The filename parameter can also be a URL to a file found online.\n\nAll files loaded and saved by the Processing API use UTF-8 encoding. If you need to load an XML file that's not in UTF-8 format, see the developer's reference for the XML object.\n",
    "syntax": "loadXML(filename)",
    "returns": "XML",
    "examples": ["\n// The following short XML file called \"mammals.xml\" is parsed \n// in the code below. It must be in the project's \"data\" folder.\n//\n// <?xml version=\"1.0\"?>\n// <mammals>\n//   <animal id=\"0\" species=\"Capra hircus\">Goat</animal>\n//   <animal id=\"1\" species=\"Panthera pardus\">Leopard</animal>\n//   <animal id=\"2\" species=\"Equus zebra\">Zebra</animal>\n// </mammals>\n\nXML xml;\n\nvoid setup() {\n  xml = loadXML(\"mammals.xml\");\n  XML[] children = xml.getChildren(\"animal\");\n\n  for (int i = 0; i < children.length; i++) {\n    int id = children[i].getInt(\"id\");\n    String coloring = children[i].getString(\"species\");\n    String name = children[i].getContent();\n    println(id + \", \" + coloring + \", \" + name);\n  }\n}\n\n// Sketch prints:\n// 0, Capra hircus, Goat\n// 1, Panthera pardus, Leopard\n// 2, Equus zebra, Zebra\n"],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: name of a file in the data folder or a URL."
    }]
}, {
    "name": "keyTyped()",
    "description": "\nThe keyTyped() function is called once every time a key is pressed, but action keys such as Ctrl, Shift, and Alt are ignored.\n\nBecause of how operating systems handle key repeats, holding down a key may cause multiple calls to keyTyped(). The rate of repeat is set by the operating system, and may be configured differently on each computer.\n\nMouse and keyboard events only work when a program has draw(). Without draw(), the code is only run once and then stops listening for events.\n",
    "syntax": "keyTyped()\nkeyTyped(event)",
    "returns": "void",
    "examples": ["\n// Run this program to learn how each of these functions\n// relate to the others.\n\nvoid draw() { } // Empty draw() needed to keep the program running\n\nvoid keyPressed() {\n  println(\"pressed \" + int(key) + \" \" + keyCode);\n}\n\nvoid keyTyped() {\n  println(\"typed \" + int(key) + \" \" + keyCode);\n}\n\nvoid keyReleased() {\n  println(\"released \" + int(key) + \" \" + keyCode);\n}\n\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "keyCode",
    "description": "\nThe variable keyCode is used to detect special keys such as the arrow keys (UP, DOWN, LEFT, and RIGHT) as well as ALT, CONTROL, SHIFT, PAGE_UP, PAGE_DOWN, HOME, and END.\n\nWhen checking for these keys, it can be useful to first check if the key is coded. This is done with the conditional if (key == CODED), as shown in the example above.\n\nThe keys included in the ASCII specification (BACKSPACE, TAB, ENTER, RETURN, ESC, and DELETE) do not require checking to see if the key is coded; for those keys, you should simply use the key variable directly (and not keyCode).  If you're making cross-platform projects, note that the ENTER key is commonly used on PCs and Unix, while the RETURN key is used on Macs. Make sure your program will work on all platforms by checking for both ENTER and RETURN.\n\nFor those familiar with Java, the values for UP and DOWN are simply shorter versions of Java's KeyEvent.VK_UP and KeyEvent.VK_DOWN. Other keyCode values can be found in the Java KeyEvent reference.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\ncolor fillVal = color(126);\n\nvoid draw() {\n  fill(fillVal);\n  rect(25, 25, 50, 50);\n}\n\nvoid keyPressed() {\n  if (key == CODED) {\n    if (keyCode == UP) {\n      fillVal = 255;\n    } else if (keyCode == DOWN) {\n      fillVal = 0;\n    } \n  } else {\n    fillVal = 126;\n  }\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "quadraticVertex()",
    "description": "\nSpecifies vertex coordinates for quadratic Bezier curves. Each call to quadraticVertex() defines the position of one control points and one anchor point of a Bezier curve, adding a new segment to a line or shape. The first time quadraticVertex() is used within a beginShape() call, it must be prefaced with a call to vertex() to set the first anchor point. This function must be used between beginShape() and endShape() and only when there is no MODE parameter specified to beginShape(). Using the 3D version requires rendering with P3D (see the Environment reference for more information).\n",
    "syntax": "quadraticVertex(cx, cy, x3, y3)\nquadraticVertex(cx, cy, cz, x3, y3, z3)",
    "returns": "void",
    "examples": ["\nnoFill();\nstrokeWeight(4);\nbeginShape();\nvertex(20, 20);\nquadraticVertex(80, 20, 50, 50);\nendShape();\n", "\nnoFill();\nstrokeWeight(4);\nbeginShape();\nvertex(20, 20);\nquadraticVertex(80, 20, 50, 50);\nquadraticVertex(20, 80, 80, 80);\nvertex(80, 60);\nendShape();\n"],
    "examples_img": ["https://www.processing.org/reference/images/quadraticVertex_0.png", "https://www.processing.org/reference/images/quadraticVertex_1.png"],
    "parameters": [{
        "name": "cx",
        "description": "float: the x-coordinate of the control point"
    }, {
        "name": "cy",
        "description": "float: the y-coordinate of the control point"
    }, {
        "name": "x3",
        "description": "float: the x-coordinate of the anchor point"
    }, {
        "name": "y3",
        "description": "float: the y-coordinate of the anchor point"
    }, {
        "name": "cz",
        "description": "float: the z-coordinate of the control point"
    }, {
        "name": "z3",
        "description": "float: the z-coordinate of the anchor point"
    }]
}, {
    "name": "JSONObject",
    "description": "\nA JSONObject stores JSON data with multiple name/value pairs.  Values can be numeric, Strings, booleans, other JSONObjects or JSONArrays, or null.  JSONObject and JSONArray objects are quite similar and share most of the same methods; the primary difference is that the latter stores an array of JSON objects, while the former represents a single JSON object.\n\nJSON can be generated from scratch, dynamically, or using data from an existing file.  JSON can also be output and saved to disk, as in the example above.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nJSONObject json;\n\nvoid setup() {\n\n  json = new JSONObject();\n\n  json.setInt(\"id\", 0);\n  json.setString(\"species\", \"Panthera leo\");\n  json.setString(\"name\", \"Lion\");\n\n  saveJSONObject(json, \"data/new.json\");\n}\n\n// Sketch saves the following to a file called \"new.json\":\n// {\n//   \"id\": 0,\n//   \"species\": \"Panthera leo\",\n//   \"name\": \"Lion\"\n// }\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "curve()",
    "description": "\nDraws a curved line on the screen. The first and second parameters specify the beginning control point and the last two parameters specify the ending control point. The middle parameters specify the start and stop of the curve. Longer curves can be created by putting a series of curve() functions together or using curveVertex(). An additional function called curveTightness() provides control for the visual quality of the curve. The curve() function is an implementation of Catmull-Rom splines. Using the 3D version requires rendering with P3D (see the Environment reference for more information).\n",
    "syntax": "curve(x1, y1, x2, y2, x3, y3, x4, y4)\ncurve(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4)",
    "returns": "void",
    "examples": ["\nnoFill();\nstroke(255, 102, 0);\ncurve(5, 26, 5, 26, 73, 24, 73, 61);\nstroke(0); \ncurve(5, 26, 73, 24, 73, 61, 15, 65); \nstroke(255, 102, 0);\ncurve(73, 24, 73, 61, 15, 65, 15, 65);\n"],
    "examples_img": ["https://www.processing.org/reference/images/curve_.png"],
    "parameters": [{
        "name": "x1",
        "description": "float: coordinates for the beginning control point"
    }, {
        "name": "y1",
        "description": "float: coordinates for the beginning control point"
    }, {
        "name": "x2",
        "description": "float: coordinates for the first point"
    }, {
        "name": "y2",
        "description": "float: coordinates for the first point"
    }, {
        "name": "x3",
        "description": "float: coordinates for the second point"
    }, {
        "name": "y3",
        "description": "float: coordinates for the second point"
    }, {
        "name": "x4",
        "description": "float: coordinates for the ending control point"
    }, {
        "name": "y4",
        "description": "float: coordinates for the ending control point"
    }, {
        "name": "z1",
        "description": "float: coordinates for the beginning control point"
    }, {
        "name": "z2",
        "description": "float: coordinates for the first point"
    }, {
        "name": "z3",
        "description": "float: coordinates for the second point"
    }, {
        "name": "z4",
        "description": "float: coordinates for the ending control point"
    }]
}, {
    "name": "shapeMode()",
    "description": "\nModifies the location from which shapes draw. The default mode is shapeMode(CORNER), which specifies the location to be the upper left corner of the shape and uses the third and fourth parameters of shape() to specify the width and height. The syntax shapeMode(CORNERS) uses the first and second parameters of shape() to set the location of one corner and uses the third and fourth parameters to set the opposite corner. The syntax shapeMode(CENTER) draws the shape from its center point and uses the third and forth parameters of shape() to specify the width and height. The parameter must be written in \"ALL CAPS\" because Processing is a case sensitive language.\n",
    "syntax": "shapeMode(mode)",
    "returns": "void",
    "examples": ["\nPShape bot \n\nvoid setup() {\n  size(100, 100);\n  bot = loadShape(\"bot.svg\");\n}\n\nvoid draw() {\n  shapeMode(CENTER);\n  shape(bot, 35, 35, 50, 50);\n  shapeMode(CORNER);\n  shape(bot, 35, 35, 50, 50);\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/shapeMode_.png"],
    "parameters": [{
        "name": "mode",
        "description": "int: either CORNER, CORNERS, CENTER"
    }]
}, {
    "name": "loadStrings()",
    "description": "\nReads the contents of a file and creates a String array of its individual lines. If the name of the file is used as the parameter, as in the above example, the file must be loaded in the sketch's \"data\" directory/folder. \n\nAlternatively, the file maybe be loaded from anywhere on the local computer using an absolute path (something that starts with / on Unix and Linux, or a drive letter on Windows), or the filename parameter can be a URL for a file found on a network.\n\nIf the file is not available or an error occurs, null will be returned and an error message will be printed to the console. The error message does not halt the program, however the null value may cause a NullPointerException if your code does not check whether the value returned is null.\n\nStarting with Processing release 0134, all files loaded and saved by the Processing API use UTF-8 encoding. In previous releases, the default encoding for your platform was used, which causes problems when files are moved to other platforms.\n",
    "syntax": "loadStrings(filename)\nloadStrings(reader)",
    "returns": "String[]",
    "examples": ["\nString lines[] = loadStrings(\"list.txt\");\nprintln(\"there are \" + lines.length + \" lines\");\nfor (int i = 0 ; i < lines.length; i++) {\n  println(lines[i]);\n}\n", "\nString lines[] = loadStrings(\"http://processing.org/about/index.html\");\nprintln(\"there are \" + lines.length + \" lines\");\nfor (int i = 0 ; i < lines.length; i++) {\n  println(lines[i]);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: name of the file or url to load"
    }]
}, {
    "name": "splice()",
    "description": "\nInserts a value or an array of values into an existing array. The first two parameters must be arrays of the same datatype. The first parameter specifies the intial array to be modified, and the second parameter defines the data to be inserted. The third parameter is an index value which specifies the array position from which to insert data. (Remember that array index numbering starts at zero, so the first position is 0, the second position is 1, and so on.)\n\nWhen splicing an array of objects, the data returned from the function must be cast to the object array's data type. For example: SomeClass[] items = (SomeClass[]) splice(array1, array2, index)\n",
    "syntax": "splice(list, value, index)",
    "returns": "boolean[], byte[], char[], int[], float[], String[], or Object",
    "examples": ["\nString[] a = { \"OH\", \"NY\", \"CA\" };\na = splice(a, \"KY\", 1);  // Splice one value into an array\nprintln(a);\n// Prints the following array contents to the console:\n// [0] \"OH\"\n// [1] \"KY\"\n// [2] \"NY\"\n// [3] \"CA\"\n\nprintln();  // Prints a blank line\n\nString[] b = { \"VA\", \"CO\", \"IL\" };\na = splice(a, b, 2);  // Splice one array of values into another\nprintln(a);\n// Prints the following array contents to the console:\n// [0] \"OH\"\n// [1] \"KY\"\n// [2] \"VA\"\n// [3] \"CO\"\n// [4] \"IL\"\n// [5] \"NY\"\n// [6] \"CA\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "list",
        "description": "Object, String[], float[], int[], char[], byte[], or boolean[]: array to splice into"
    }, {
        "name": "value",
        "description": "Object, String[], String, float[], float, int[], int, char[], char, byte[], byte, boolean[], or boolean: value to be spliced in"
    }, {
        "name": "index",
        "description": "int: position in the array from which to insert data"
    }]
}, {
    "name": "nfp()",
    "description": "\nUtility function for formatting numbers into strings. Similar to nf() but puts a \"+\" in front of positive numbers and a \"-\" in front of negative numbers. There are two versions: one for formatting floats, and one for formatting ints. The values for the digits, left, and right parameters should always be positive integers.\n",
    "syntax": "nfp(num, digits)\nnfp(num, left, right)",
    "returns": "String or String[]",
    "examples": ["\nint a=200, b=-40, c=90; \nString sa = nfp(a, 10); \nprintln(sa);  // Prints \"+0000000200\" \nString sb = nfp(b, 5); \nprintln(sb);  // Prints \"-00040\" \nString sc = nfp(c, 3); \nprintln(sc);  // Prints \"+090\" \n \nfloat d = -200.94, e = 40.2, f = -9.012; \nString sd = nfp(d, 10, 4); \nprintln(sd);  // Prints \"-0000000200.9400\" \nString se = nfp(e, 5, 3); \nprintln(se);  // Prints \"+00040.200\" \nString sf = nfp(f, 3, 5); \nprintln(sf);  // Prints \"-009.01200\" \n"],
    "examples_img": [],
    "parameters": [{
        "name": "num",
        "description": "float[], int[], or int: the number(s) to format"
    }, {
        "name": "digits",
        "description": "int: number of digits to pad with zeroes"
    }, {
        "name": "left",
        "description": "int: the number of digits to the left of the decimal point"
    }, {
        "name": "right",
        "description": "int: the number of digits to the right of the decimal point"
    }]
}, {
    "name": "StringList",
    "description": "\nHelper class for a list of Strings. Lists are designed to have some of the \nfeatures of ArrayLists, but to maintain the simplicity and efficiency of\nworking with arrays.\n\nFunctions like sort() and shuffle() always act on the list itself. To get \na sorted copy, use list.copy().sort().\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nStringList inventory;\n\nvoid setup() {\n  size(200, 200);\n  inventory = new StringList();\n  inventory.append(\"coffee\");\n  inventory.append(\"flour\");\n  inventory.append(\"tea\");\n  println(inventory);\n  noLoop();\n  fill(0);\n  textAlign(CENTER);\n}\n\nvoid draw() {\n  String item = inventory.get(2);\n  text(item, width/2, height/2);\n}\n\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "strokeWeight()",
    "description": "\nSets the width of the stroke used for lines, points, and the border around shapes. All widths are set in units of pixels.\n",
    "syntax": "strokeWeight(weight)",
    "returns": "void",
    "examples": ["\nstrokeWeight(1);  // Default\nline(20, 20, 80, 20);\nstrokeWeight(4);  // Thicker\nline(20, 40, 80, 40);\nstrokeWeight(10);  // Beastly\nline(20, 70, 80, 70);\n"],
    "examples_img": ["https://www.processing.org/reference/images/strokeWeight_.png"],
    "parameters": [{
        "name": "weight",
        "description": "float: the weight (in pixels) of the stroke"
    }]
}, {
    "name": "bezierTangent()",
    "description": "\nCalculates the tangent of a point on a Bezier curve. There is a good definition of tangent on Wikipedia.\n",
    "syntax": "bezierTangent(a, b, c, d, t)",
    "returns": "float",
    "examples": ["\nnoFill();\nbezier(85, 20, 10, 10, 90, 90, 15, 80);\nint steps = 6;\nfill(255);\nfor (int i = 0; i ", "\nnoFill();\nbezier(85, 20, 10, 10, 90, 90, 15, 80);\nstroke(255, 102, 0);\nint steps = 16;\nfor (int i = 0; i "],
    "examples_img": ["https://www.processing.org/reference/images/bezierTangent_0.png", "https://www.processing.org/reference/images/bezierTangent_1.png"],
    "parameters": [{
        "name": "a",
        "description": "float: coordinate of first point on the curve"
    }, {
        "name": "b",
        "description": "float: coordinate of first control point"
    }, {
        "name": "c",
        "description": "float: coordinate of second control point"
    }, {
        "name": "d",
        "description": "float: coordinate of second point on the curve"
    }, {
        "name": "t",
        "description": "float: value between 0 and 1"
    }]
}, {
    "name": "frameRate",
    "description": "\nThe system variable frameRate contains the approximate frame rate of a running sketch. The initial value is 10 fps and is updated with each frame. The value is averaged over several frames, and so will only be accurate after the draw function has run 5-10 times.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nvoid setup() {\n  frameRate(30);\n}\n\nvoid draw() {\n  line(0, 0, width, height);\n  println(frameRate);\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "curvePoint()",
    "description": "\nEvaluates the curve at point t for points a, b, c, d. The parameter t may range from 0 (the start of the curve) and 1 (the end of the curve). a and d are points on the curve, and b and c are the control points. This can be used once with the x coordinates and a second time with the y coordinates to get the location of a curve at t.\n",
    "syntax": "curvePoint(a, b, c, d, t)",
    "returns": "float",
    "examples": ["\nnoFill();\ncurve(5, 26, 5, 26, 73, 24, 73, 61);\ncurve(5, 26, 73, 24, 73, 61, 15, 65);\nfill(255);\nellipseMode(CENTER);\nint steps = 6;\nfor (int i = 0; i "],
    "examples_img": ["https://www.processing.org/reference/images/curvePoint_.png"],
    "parameters": [{
        "name": "a",
        "description": "float: coordinate of first point on the curve"
    }, {
        "name": "b",
        "description": "float: coordinate of second point on the curve"
    }, {
        "name": "c",
        "description": "float: coordinate of third point on the curve"
    }, {
        "name": "d",
        "description": "float: coordinate of fourth point on the curve"
    }, {
        "name": "t",
        "description": "float: value between 0 and 1"
    }]
}, {
    "name": "&& (logical AND)",
    "description": "\nCompares two expressions and returns true only if both evaluate to true. Returns false if one or both evaluate to false. The following list shows all possible combinations:true && false   // Evaluates false because the second is false false && true   // Evaluates false because the first is false true && true    // Evaluates true because both are true false && false  // Evaluates false because both are false\n",
    "syntax": "\nexpression1 && expression2\n",
    "returns": "",
    "examples": ["\nfor (int i = 5; i  35) && (i < 60)) {\n    stroke(0);  // Set color to black\n  } else {\n    stroke(255);  // Set color to white\n  }\n  line(30, i, 80, i);\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/logicalAND.png"],
    "parameters": [{
        "name": "expression1",
        "description": "any valid expression"
    }, {
        "name": "expression2",
        "description": "any valid expression"
    }]
}, {
    "name": "curveTangent()",
    "description": "\nCalculates the tangent of a point on a curve. There's a good definition of tangent on Wikipedia.\n",
    "syntax": "curveTangent(a, b, c, d, t)",
    "returns": "float",
    "examples": ["\nnoFill();\ncurve(5, 26, 73, 24, 73, 61, 15, 65); \nint steps = 6;\nfor (int i = 0; i "],
    "examples_img": ["https://www.processing.org/reference/images/curveTangent_.png"],
    "parameters": [{
        "name": "a",
        "description": "float: coordinate of first point on the curve"
    }, {
        "name": "b",
        "description": "float: coordinate of first control point"
    }, {
        "name": "c",
        "description": "float: coordinate of second control point"
    }, {
        "name": "d",
        "description": "float: coordinate of second point on the curve"
    }, {
        "name": "t",
        "description": "float: value between 0 and 1"
    }]
}, {
    "name": "class",
    "description": "\nKeyword used to indicate the declaration of a class. A class is a composite of fields (data) and methods (functions that are a part of the class) which may be instantiated as objects. The first letter of a class name is usually uppercase to separate it from other kinds of variables. A related tutorial on Object-Oriented Programming is hosted on the Oracle website.\n",
    "syntax": "\nclass ClassName {\n  statements\n}\n",
    "returns": "",
    "examples": ["\n// Declare and construct two objects (h1, h2) from the class HLine \nHLine h1 = new HLine(20, 2.0); \nHLine h2 = new HLine(50, 2.5); \n \nvoid setup() \n{\n  size(200, 200);\n  frameRate(30);\n}\n\nvoid draw() { \n  background(204);\n  h1.update(); \n  h2.update();  \n} \n \nclass HLine { \n  float ypos, speed; \n  HLine (float y, float s) {  \n    ypos = y; \n    speed = s; \n  } \n  void update() { \n    ypos += speed; \n    if (ypos > height) { \n      ypos = 0; \n    } \n    line(0, ypos, width, ypos); \n  } \n} \n"],
    "examples_img": [],
    "parameters": [{
        "name": "ClassName",
        "description": "Any valid variable name"
    }, {
        "name": "statements",
        "description": "any valid statements"
    }]
}, {
    "name": "join()",
    "description": "\nCombines an array of Strings into one String, each separated by the character(s) used for the separator parameter. To join arrays of ints or floats, it's necessary to first convert them to Strings using nf() or nfs().\n",
    "syntax": "join(list, separator)",
    "returns": "String",
    "examples": ["\nString[] animals = new String[3]; \nanimals[0] = \"cat\"; \nanimals[1] = \"seal\"; \nanimals[2] = \"bear\"; \nString joinedAnimals = join(animals, \" : \"); \nprintln(joinedAnimals);  // Prints \"cat : seal : bear\" \n\n// Joining an array of ints requires first\n// converting to an array of Strings\nint[] numbers = new int[3]; \nnumbers[0] = 8; \nnumbers[1] = 67; \nnumbers[2] = 5; \nString joinedNumbers = join(nf(numbers, 0), \", \"); \nprintln(joinedNumbers);  // Prints \"8, 67, 5\" \n\n"],
    "examples_img": [],
    "parameters": [{
        "name": "list",
        "description": "String[]: array of Strings"
    }, {
        "name": "separator",
        "description": "char: char or String to be placed between each item"
    }]
}, {
    "name": "byte()",
    "description": "\nConverts any value of a primitive data type (boolean, byte, char, color, double, float, int, or long) to its byte representation. A byte can only be a whole number between -128 and 127, so when a value outside of this range is converted, it wraps around to the corresponding byte representation.  (For example, byte(128) evaluates to -128.)\n\nWhen an array of values is passed in, then a byte array of the same length is returned.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nchar c = 'E';\nbyte b = byte(c);\nprintln(c + \" : \" + b);  // Prints \"E : 69\"\n\nint i = 130;\nb = byte(i);\nprintln(i + \" : \" + b);  // Prints \"130 : -126\"\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "null",
    "description": "\nSpecial value used to signify the target is not a valid data element. In Processing, you may run across the keyword null when trying to access data which is not there.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nString content = \"It is a beautiful day.\";\nString[] results;  // Declare empty String array\n\nresults = match(content, \"orange\");\n// The match statement above will fail to find\n// the word \"orange\" in the String 'content', so\n// it will return a null value to 'results'.\n\nif (results == null) {\n  println(\"Value of 'results' is null.\");  // This line is printed\n} else {\n  println(\"Value of 'results' is not null!\");  // This line is not printed\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "textAlign()",
    "description": "\nSets the current alignment for drawing text. The parameters LEFT, CENTER, and RIGHT set the display characteristics of the letters in relation to the values for the x and y parameters of the text() function.\n \nAn optional second parameter can be used to vertically align the text. BASELINE is the default, and the vertical alignment will be reset to BASELINE if the second parameter is not used. The TOP and CENTER parameters are straightforward. The BOTTOM parameter offsets the line based on the current textDescent(). For multiple lines, the final line will be aligned to the bottom, with the previous lines appearing above it.\n \nWhen using text() with width and height parameters, BASELINE is ignored, and treated as TOP. (Otherwise, text would by default draw outside the box, since BASELINE is the default setting. BASELINE is not a useful drawing mode for text drawn in a rectangle.)\n \nThe vertical alignment is based on the value of textAscent(), which many fonts do not specify correctly. It may be necessary to use a hack and offset by a few pixels by hand so that the offset looks correct. To do this as less of a hack, use some percentage of textAscent() or textDescent() so that the hack works even if you change the size of the font.\n",
    "syntax": "textAlign(alignX)\ntextAlign(alignX, alignY)",
    "returns": "void",
    "examples": ["\nbackground(0);\ntextSize(16);\ntextAlign(RIGHT);\ntext(\"ABCD\", 50, 30);\ntextAlign(CENTER);\ntext(\"EFGH\", 50, 50);\ntextAlign(LEFT);\ntext(\"IJKL\", 50, 70);\n", "\nbackground(0);\nstroke(153);\ntextSize(11);\ntextAlign(CENTER, BOTTOM);\nline(0, 30, width, 30);\ntext(\"CENTER,BOTTOM\", 50, 30);\ntextAlign(CENTER, CENTER);\nline(0, 50, width, 50);\ntext(\"CENTER,CENTER\", 50, 50);\ntextAlign(CENTER, TOP);\nline(0, 70, width, 70);\ntext(\"CENTER,TOP\", 50, 70);\n"],
    "examples_img": ["https://www.processing.org/reference/images/textAlign_0.png", "https://www.processing.org/reference/images/textAlign_1.png"],
    "parameters": [{
        "name": "alignX",
        "description": "int: horizontal alignment, either LEFT, CENTER, or RIGHT"
    }, {
        "name": "alignY",
        "description": "int: vertical alignment, either TOP, BOTTOM, CENTER, or BASELINE"
    }]
}, {
    "name": "PShape",
    "description": "\nDatatype for storing shapes. Before a shape is used, it must be loaded with the loadShape() or created with the createShape(). The shape() function is used to draw the shape to the display window. Processing can currently load and display SVG (Scalable Vector Graphics) and OBJ shapes. OBJ files can only be opened using the P3D renderer and createShape() is only available with the P2D and P3D renderers. The loadShape() function supports SVG files created with Inkscape and Adobe Illustrator. It is not a full SVG implementation, but offers some straightforward support for handling vector data.\n\nThe PShape object contains a group of methods that can operate on the shape data. Some of the methods are listed below, but the full list used for creating and modifying shapes is available here in the Processing Javadoc.\n\nTo create a new shape, use the createShape() function. Do not use the syntax new PShape(). \n",
    "syntax": "",
    "returns": "",
    "examples": ["\nPShape s;\n\nvoid setup() {\n  size(100, 100);\n  // The file \"bot.svg\" must be in the data folder\n  // of the current sketch to load successfully\n  s = loadShape(\"bot.svg\");\n}\n\nvoid draw() {\n  shape(s, 10, 10, 80, 80);\n}\n", "\nPShape square;  // The PShape object\n\nvoid setup() {  \n  size(100, 100, P2D);\n  // Creating the PShape as a square. The corner \n  // is 0,0 so that the center is at 40,40 \n  square = createShape(RECT, 0, 0, 80, 80);\n}\n\nvoid draw() {\n  shape(square, 10, 10);\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "mouseReleased()",
    "description": "\nThe mouseReleased() function is called every time a mouse button is released.\n\nMouse and keyboard events only work when a program has draw(). Without draw(), the code is only run once and then stops listening for events.\n",
    "syntax": "mouseReleased()\nmouseReleased(event)",
    "returns": "void",
    "examples": ["\n// Click within the image to change \n// the value of the rectangle\n\nint value = 0;\n\nvoid draw() {\n  fill(value);\n  rect(25, 25, 50, 50);\n}\n\nvoid mouseReleased() {\n  if (value == 0) {\n    value = 255;\n  } else {\n    value = 0;\n  }\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "// (comment)",
    "description": "\nExplanatory notes embedded within the code. Comments are used to remind yourself and to inform others about the details of the code. Single-line comments are signified with the two forward slash characters. Comments are ignored by the compiler.\n",
    "syntax": "\n// comment\n",
    "returns": "",
    "examples": ["\n// Draws two lines which divides the window\n// into four quadrants\nline(0, 50, 100, 50);  // Draw the horizontal line\nline(50, 0, 50, 100);  // Draw the vertical line\n"],
    "examples_img": [],
    "parameters": [{
        "name": "comment",
        "description": "any sequence of characters"
    }]
}, {
    "name": "nf()",
    "description": "\nUtility function for formatting numbers into strings. There are two versions: one for formatting floats, and one for formatting ints. The values for the digits, left, and right parameters should always be positive integers.As shown in the above example, nf() is used to add zeros to the left and/or right of a number. This is typically for aligning a list of numbers. To remove digits from a floating-point number, use the int(), ceil(), floor(), or round() functions.  \n",
    "syntax": "nf(num, digits)\nnf(num, left, right)",
    "returns": "String or String[]",
    "examples": ["\nint a=200, b=40, c=90;\nString sa = nf(a, 10);\nprintln(sa);  // Prints \"0000000200\"\nString sb = nf(b, 5);\nprintln(sb);  // Prints \"00040\"\nString sc = nf(c, 3);\nprintln(sc);  // Prints \"090\"\n\nfloat d = 200.94, e = 40.2, f = 9.012;\nString sd = nf(d, 10, 4);\nprintln(sd);  // Prints \"0000000200.9400\"\nString se = nf(e, 5, 3);\nprintln(se);  // Prints \"00040.200\"\nString sf = nf(f, 3, 5);\nprintln(sf);  // Prints \"009.01200\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "num",
        "description": "float[], int[], or int: the number(s) to format"
    }, {
        "name": "digits",
        "description": "int: number of digits to pad with zero"
    }, {
        "name": "left",
        "description": "int: number of digits to the left of the decimal point"
    }, {
        "name": "right",
        "description": "int: number of digits to the right of the decimal point"
    }]
}, {
    "name": "< (less than)",
    "description": "\nTests if the value on the left is smaller than the value on the right. \n",
    "syntax": "\nvalue1 < value2\n",
    "returns": "",
    "examples": ["\nint a = 22;\nint b = 23;\nif (a < b) {\n  println(\"variable a is less then variable b \");\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1",
        "description": "int, float, char, or byte"
    }, {
        "name": "value2",
        "description": "int, float, char, or byte"
    }]
}, {
    "name": "str()",
    "description": "\nConverts any value of a primitive data type (boolean, byte, char, color, double, float, int, or long) to its String representation. For example, converting an integer with str(3) will return the String value of \"3\", converting a float with str(-12.6) will return \"-12.6\", and converting a boolean with str(true) will return \"true\".\n\nWhen an array of values is passed in, then a String array of the same length is returned.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nboolean b = false;\nbyte y = -28;\nchar c = 'R';\nfloat f = -32.6;\nint i = 1024;\n\nString sb = str(b);\nString sy = str(y); \nString sc = str(c);\nString sf = str(f);\nString si = str(i);\n\nsb = sb + sy + sc + sf + si;\n\nprintln(sb);  // Prints 'false-28R-32.61024'\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "append()",
    "description": "\nExpands an array by one element and adds data to the new position. The datatype of the element parameter must be the same as the datatype of the array.\n\nWhen using an array of objects, the data returned from the function must be cast to the object array's data type. For example: SomeClass[] items = (SomeClass[]) append(originalArray, element)\n",
    "syntax": "append(array, value)",
    "returns": "byte[], char[], int[], float[], String[], or Object",
    "examples": ["\nString[] sa1 = { \"OH\", \"NY\", \"CA\"}; \nString[] sa2 = append(sa1, \"MA\"); \nprintln(sa2);\n// Prints updated array contents to the console:\n// [0] \"OH\"\n// [1] \"NY\"\n// [2] \"CA\"\n// [3] \"MA\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "array",
        "description": "Object, String[], float[], int[], char[], or byte[]: array to append"
    }, {
        "name": "value",
        "description": "Object, String, float, int, char, or byte: new data for the array"
    }]
}, {
    "name": "float()",
    "description": "\nConverts an int or String to its floating point representation.  An int is easily converted to a float, but the contents of a String must resemble a number, or NaN (not a number) will be returned.  For example, float(\"1234.56\") evaluates to 1234.56, but float(\"giraffe\") will return NaN.\n\nWhen an array of int or String values is passed in, then a floating point array of the same length is returned.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nint i = 65;\nfloat f = float(i);\nprintln(i + \" : \" + f);  // Prints \"65 : 65.0\"\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "if",
    "description": "\nAllows the program to make a decision about which code to execute. If the test evaluates to true, the statements enclosed within the block are executed and if the test evaluates to false the statements are not executed.\n",
    "syntax": "\nif (test) { \n  statements \n} \n",
    "returns": "",
    "examples": ["\nfor (int i = 5; i < height; i += 5) {\n  stroke(255);   // Set the color to white\n  if (i < 35) {  // When 'i' is less than 35...\n    stroke(0);   //...set the color to black\n  }\n  line(30, i, 80, i);\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/if_.png"],
    "parameters": [{
        "name": "test",
        "description": "any valid expression that evaluates to true or false"
    }, {
        "name": "statements",
        "description": "one or more statements to be executed"
    }]
}, {
    "name": "unhex()",
    "description": "\nConverts a String representation of a hexadecimal number to its equivalent integer value.\n",
    "syntax": "unhex(value)",
    "returns": "int",
    "examples": ["\nString hs = \"FF006699\";\nint hi = unhex(hs);\nfill(hi);\nrect(30, 20, 55, 55);\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value",
        "description": "String: String to convert to an integer"
    }]
}, {
    "name": "TWO_PI",
    "description": "\nTWO_PI is a mathematical constant with the value 6.28318530717958647693. It is twice the ratio of the circumference of a circle to its diameter. It is useful in combination with the trigonometric functions sin() and cos(). \n",
    "syntax": "",
    "returns": "",
    "examples": ["\nfloat x = width/2;\nfloat y = height/2;\nfloat d = width * 0.8;\narc(x, y, d, d, 0, QUARTER_PI);\narc(x, y, d-20, d-20, 0, HALF_PI);\narc(x, y, d-40, d-40, 0, PI);\narc(x, y, d-60, d-60, 0, TWO_PI);\n"],
    "examples_img": ["https://www.processing.org/reference/images/TWO_PI.png"],
    "parameters": []
}, {
    "name": "loop()",
    "description": "\nBy default, Processing loops through draw() continuously, executing the code within it. However, the draw() loop may be stopped by calling noLoop(). In that case, the draw() loop can be resumed with loop().\n",
    "syntax": "loop()",
    "returns": "void",
    "examples": ["\nvoid setup() {\n  size(200, 200);\n  noLoop();  // draw() will not loop\n}\n\nfloat x = 0;\n\nvoid draw() {\n  background(204);\n  x = x + .1;\n  if (x > width) {\n    x = 0;\n  }\n  line(x, 0, x, height); \n}\n\nvoid mousePressed() {\n  loop();  // Holding down the mouse activates looping\n}\n\nvoid mouseReleased() {\n  noLoop();  // Releasing the mouse stops looping draw()\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "noCursor()",
    "description": "\nHides the cursor from view. Will not work when running the program in a web browser or in full screen (Present) mode.\n",
    "syntax": "noCursor()",
    "returns": "void",
    "examples": ["\n// Press the mouse to hide the cursor\nvoid draw() \n{\n  if (mousePressed == true) {\n    noCursor();\n  } else {\n    cursor(HAND);\n  }\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "key",
    "description": "\nThe system variable key always contains the value of the most recent key on the keyboard that was used (either pressed or released). \n \nFor non-ASCII keys, use the keyCode variable. The keys included in the ASCII specification (BACKSPACE, TAB, ENTER, RETURN, ESC, and DELETE) do not require checking to see if they key is coded, and you should simply use the key variable instead of keyCode If you're making cross-platform projects, note that the ENTER key is commonly used on PCs and Unix and the RETURN key is used instead on Macintosh. Check for both ENTER and RETURN to make sure your program will work for all platforms.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\n// Click on the window to give it focus,\n// and press the 'B' key.\n\nvoid draw() {\n  if (keyPressed) {\n    if (key == 'b' || key == 'B') {\n      fill(0);\n    }\n  } else {\n    fill(255);\n  }\n  rect(25, 25, 50, 50);\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "true",
    "description": "\nReserved word representing the logical value \"true\". Only variables of type boolean may be assigned the value true.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nrect(30, 20, 50, 50);\nboolean b = true;\nif (b == true) {\n  line(20, 10, 90, 80);  // This line is drawn\n} else {\n  line(20, 80, 90, 10);  // This line is not drawn\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "displayWidth",
    "description": "\nSystem variable that stores the width of the entire screen display. This is used to run a full-screen program on any display size.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nsize(displayWidth, displayHeight);\nline(0, 0, width, height);\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "endRaw()",
    "description": "\nComplement to beginRaw(); they must always be used together. See the beginRaw() reference for details.\n",
    "syntax": "endRaw()",
    "returns": "void",
    "examples": ["\nimport processing.pdf.*;\n\nvoid setup() {\n  size(400, 400);\n  beginRaw(PDF, \"raw.pdf\");\n}\n\nvoid draw() {\n  line(pmouseX, pmouseY, mouseX, mouseY);\n}\n\nvoid keyPressed() {\n  if (key == ' ') {\n    endRaw();\n    exit();\n  }\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "loadBytes()",
    "description": "\nReads the contents of a file and places it in a byte array. If the name of the file is used as the parameter, as in the above example, the file must be loaded in the sketch's \"data\" directory/folder. \n\nAlternatively, the file maybe be loaded from anywhere on the local computer using an absolute path (something that starts with / on Unix and Linux, or a drive letter on Windows), or the filename parameter can be a URL for a file found on a network.\n\nIf the file is not available or an error occurs, null will be returned and an error message will be printed to the console. The error message does not halt the program, however the null value may cause a NullPointerException if your code does not check whether the value returned is null.\n",
    "syntax": "loadBytes(filename)",
    "returns": "byte[]",
    "examples": ["\n// Open a file and read its binary data \nbyte b[] = loadBytes(\"something.dat\"); \n \n// Print each value, from 0 to 255 \nfor (int i = 0; i < b.length; i++) { \n  // Every tenth number, start a new line \n  if ((i % 10) == 0) { \n    println(); \n  } \n  // bytes are from -128 to 127, this converts to 0 to 255 \n  int a = b[i] & 0xff; \n  print(a + \" \"); \n} \n// Print a blank line at the end \nprintln(); \n"],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: name of a file in the data folder or a URL."
    }]
}, {
    "name": "textSize()",
    "description": "\nSets the current font size. This size will be used in all subsequent calls to the text() function. Font size is measured in units of pixels.\n",
    "syntax": "textSize(size)",
    "returns": "void",
    "examples": ["\nbackground(0);\nfill(255);\ntextSize(26); \ntext(\"WORD\", 10, 50); \ntextSize(14);\ntext(\"WORD\", 10, 70);\n"],
    "examples_img": ["https://www.processing.org/reference/images/textSize_.png"],
    "parameters": [{
        "name": "size",
        "description": "float: the size of the letters in units of pixels"
    }]
}, {
    "name": "concat()",
    "description": "\nConcatenates two arrays. For example, concatenating the array { 1, 2, 3 } and the array { 4, 5, 6 } yields { 1, 2, 3, 4, 5, 6 }. Both parameters must be arrays of the same datatype.\n \nWhen using an array of objects, the data returned from the function must be cast to the object array's data type. For example: SomeClass[] items = (SomeClass[]) concat(array1, array2).\n",
    "syntax": "concat(a, b)",
    "returns": "boolean[], byte[], char[], int[], float[], String[], or Object",
    "examples": ["\nString[] sa1 = { \"OH\", \"NY\", \"CA\"};\nString[] sa2 = { \"KY\", \"IN\", \"MA\"};\nString[] sa3 = concat(sa1, sa2);\nprintln(sa3);\n// Prints updated array contents to the console:\n// [0] \"OH\"\n// [1] \"NY\"\n// [2] \"CA\"\n// [3] \"KY\"\n// [4] \"IN\"\n// [5] \"MA\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "a",
        "description": "Object, String[], float[], int[], char[], byte[], or boolean[]: first array to concatenate"
    }, {
        "name": "b",
        "description": "Object, String[], float[], int[], char[], byte[], or boolean[]: second array to concatenate"
    }]
}, {
    "name": "ambient()",
    "description": "\nSets the ambient reflectance for shapes drawn to the screen. This is combined with the ambient light component of environment. The color components set through the parameters define the reflectance. For example in the default color mode, setting v1=255, v2=127, v3=0, would cause all the red light to reflect and half of the green light to reflect. Used in combination with emissive(), specular(), and shininess() in setting the material properties of shapes.\n",
    "syntax": "ambient(rgb)\nambient(gray)\nambient(v1, v2, v3)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nbackground(0);\nnoStroke();\ndirectionalLight(153, 153, 153, .5, 0, -1);\nambientLight(153, 102, 0);\nambient(51, 26, 0);\ntranslate(70, 50, 0);\nsphere(30);\n"],
    "examples_img": ["https://www.processing.org/reference/images/ambient_.png"],
    "parameters": [{
        "name": "rgb",
        "description": "int: any value of the color datatype"
    }, {
        "name": "gray",
        "description": "float: number specifying value between white and black"
    }, {
        "name": "v1",
        "description": "float: red or hue value (depending on current color mode)"
    }, {
        "name": "v2",
        "description": "float: green or saturation value (depending on current color mode)"
    }, {
        "name": "v3",
        "description": "float: blue or brightness value (depending on current color mode)"
    }]
}, {
    "name": "beginContour()",
    "description": "\nUse the beginContour() and endContour() function to create negative shapes within shapes such as the center of the letter 'O'. beginContour() begins recording vertices for the shape and endContour() stops recording. The vertices that define a negative shape must \"wind\" in the opposite direction from the exterior shape. First draw vertices for the exterior shape in clockwise order, then for internal shapes, draw vertices counter-clockwise.\n\nThese functions can only be used within a beginShape()/endShape() pair and transformations such as translate(), rotate(), and scale() do not work within a beginContour()/endContour() pair. It is also not possible to use other shapes, such as ellipse() or rect() within.\n",
    "syntax": "beginContour()",
    "returns": "void",
    "examples": ["\nsize(100, 100);\ntranslate(50, 50);\nstroke(255, 0, 0);\nbeginShape();\n// Exterior part of shape, clockwise winding\nvertex(-40, -40);\nvertex(40, -40);\nvertex(40, 40);\nvertex(-40, 40);\n// Interior part of shape, counter-clockwise winding\nbeginContour();\nvertex(-20, -20);\nvertex(-20, 20);\nvertex(20, 20);\nvertex(20, -20);\nendContour();\nendShape(CLOSE);\n"],
    "examples_img": ["https://www.processing.org/reference/images/beginContour_0.png"],
    "parameters": []
}, {
    "name": "selectOutput()",
    "description": "\nOpens a platform-specific file chooser dialog to select a file for output. After the selection is made, the selected File will be passed to the 'callback' function. If the dialog is closed or canceled, null will be sent to the function, so that the program is not waiting for additional input. The callback is necessary because of how threading works.\n",
    "syntax": "selectOutput(prompt, callback)\nselectOutput(prompt, callback, file)\nselectOutput(prompt, callback, file, callbackObject)\nselectOutput(prompt, callbackMethod, file, callbackObject, parent)",
    "returns": "void",
    "examples": ["\nvoid setup() {\n  selectOutput(\"Select a file to write to:\", \"fileSelected\");\n}\n\nvoid fileSelected(File selection) {\n  if (selection == null) {\n    println(\"Window was closed or the user hit cancel.\");\n  } else {\n    println(\"User selected \" + selection.getAbsolutePath());\n  }\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "prompt",
        "description": "String: message to the user"
    }, {
        "name": "callback",
        "description": "String: name of the method to be called when the selection is made"
    }]
}, {
    "name": "background()",
    "description": "\nThe background() function sets the color used for the background of the Processing window. The default background is light gray. This function is typically used within draw() to clear the display window at the beginning of each frame, but it can be used inside setup() to set the background on the first frame of animation or if the backgound need only be set once.\n \nAn image can also be used as the background for a sketch, although the image's width and height must match that of the sketch window. Images used with background() will ignore the current tint() setting. To resize an image to the size of the sketch window, use image.resize(width, height).\n \nIt is not possible to use the transparency alpha parameter with background colors on the main drawing surface. It can only be used along with a PGraphics object and createGraphics().\n",
    "syntax": "background(rgb)\nbackground(rgb, alpha)\nbackground(gray)\nbackground(gray, alpha)\nbackground(v1, v2, v3)\nbackground(v1, v2, v3, alpha)\nbackground(image)",
    "returns": "void",
    "examples": ["\nbackground(51);\n", "\nbackground(255, 204, 0);\n", "\nPImage img;\nimg = loadImage(\"laDefense.jpg\");\nbackground(img);\n"],
    "examples_img": ["https://www.processing.org/reference/images/background_0.png", "https://www.processing.org/reference/images/background_1.png", "https://www.processing.org/reference/images/background_2.png"],
    "parameters": [{
        "name": "rgb",
        "description": "int: any value of the color datatype"
    }, {
        "name": "alpha",
        "description": "float: opacity of the background"
    }, {
        "name": "gray",
        "description": "float: specifies a value between white and black"
    }, {
        "name": "v1",
        "description": "float: red or hue value (depending on the current color mode)"
    }, {
        "name": "v2",
        "description": "float: green or saturation value (depending on the current color mode)"
    }, {
        "name": "v3",
        "description": "float: blue or brightness value (depending on the current color mode)"
    }, {
        "name": "image",
        "description": "PImage: PImage to set as background (must be same size as the sketch window)"
    }]
}, {
    "name": "camera()",
    "description": "\nSets the position of the camera through setting the eye position, the center of the scene, and which axis is facing upward. Moving the eye position and the direction it is pointing (the center of the scene) allows the images to be seen from different angles. The version without any parameters sets the camera to the default position, pointing to the center of the display window with the Y axis as up. The default values are camera(width/2.0, height/2.0, (height/2.0) / tan(PI*30.0 / 180.0), width/2.0, height/2.0, 0, 0, 1, 0). This function is similar to gluLookAt() in OpenGL, but it first clears the current camera settings.\n",
    "syntax": "camera()\ncamera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nnoFill();\nbackground(204);\ncamera(70.0, 35.0, 120.0, 50.0, 50.0, 0.0, \n       0.0, 1.0, 0.0);\ntranslate(50, 50, 0);\nrotateX(-PI/6);\nrotateY(PI/3);\nbox(45);\n"],
    "examples_img": ["https://www.processing.org/reference/images/camera_.png"],
    "parameters": [{
        "name": "eyeX",
        "description": "float: x-coordinate for the eye"
    }, {
        "name": "eyeY",
        "description": "float: y-coordinate for the eye"
    }, {
        "name": "eyeZ",
        "description": "float: z-coordinate for the eye"
    }, {
        "name": "centerX",
        "description": "float: x-coordinate for the center of the scene"
    }, {
        "name": "centerY",
        "description": "float: y-coordinate for the center of the scene"
    }, {
        "name": "centerZ",
        "description": "float: z-coordinate for the center of the scene"
    }, {
        "name": "upX",
        "description": "float: usually 0.0, 1.0, or -1.0"
    }, {
        "name": "upY",
        "description": "float: usually 0.0, 1.0, or -1.0"
    }, {
        "name": "upZ",
        "description": "float: usually 0.0, 1.0, or -1.0"
    }]
}, {
    "name": "textureMode()",
    "description": "\nSets the coordinate space for texture mapping. The default mode is IMAGE, which refers to the actual coordinates of the image. NORMAL refers to a normalized space of values ranging from 0 to 1. This function only works with the P2D and P3D renderers.\n\nWith IMAGE, if an image is 100 x 200 pixels, mapping the image onto the entire size of a quad would require the points (0,0) (100, 0) (100,200) (0,200). The same mapping in NORMAL is (0,0) (1,0) (1,1) (0,1).\n",
    "syntax": "textureMode(mode)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nnoStroke();\nPImage img = loadImage(\"laDefense.jpg\");\ntextureMode(IMAGE);\nbeginShape();\ntexture(img);\nvertex(10, 20, 0, 0);\nvertex(80, 5, 100, 0);\nvertex(95, 90, 100, 100);\nvertex(40, 95, 0, 100);\nendShape();\n", "\nsize(100, 100, P3D);\nnoStroke();\nPImage img = loadImage(\"laDefense.jpg\");\ntextureMode(NORMAL);\nbeginShape();\ntexture(img);\nvertex(10, 20, 0, 0);\nvertex(80, 5, 1, 0);\nvertex(95, 90, 1, 1);\nvertex(40, 95, 0, 1);\nendShape();\n"],
    "examples_img": ["https://www.processing.org/reference/images/textureMode_0.png", "https://www.processing.org/reference/images/textureMode_1.png"],
    "parameters": [{
        "name": "mode",
        "description": "int: either IMAGE or NORMAL"
    }]
}, {
    "name": "noise()",
    "description": "\nReturns the Perlin noise value at specified coordinates. Perlin noise is a random sequence generator producing a more natural, harmonic succession of numbers than that of the standard random() function. It was invented by Ken Perlin in the 1980s and has been used in graphical applications to generate procedural textures, shapes, terrains, and other seemingly organic forms.\n\nIn contrast to the random() function, Perlin noise is defined in an infinite n-dimensional space, in which each pair of coordinates corresponds to a fixed semi-random value (fixed only for the lifespan of the program). The resulting value will always be between 0.0 and 1.0. Processing can compute 1D, 2D and 3D noise, depending on the number of coordinates given. The noise value can be animated by moving through the noise space, as demonstrated in the first example above. The 2nd and 3rd dimensions can also be interpreted as time.\n\nThe actual noise structure is similar to that of an audio signal, in respect to the function's use of frequencies. Similar to the concept of harmonics in physics, Perlin noise is computed over several octaves which are added together for the final result.\n\nAnother way to adjust the character of the resulting sequence is the scale of the input coordinates. As the function works within an infinite space, the value of the coordinates doesn't matter as such; only the distance between successive coordinates is important (such as when using noise() within a loop). As a general rule, the smaller the difference between coordinates, the smoother the resulting noise sequence. Steps of 0.005-0.03 work best for most applications, but this will differ depending on use.\n",
    "syntax": "noise(x)\nnoise(x, y)\nnoise(x, y, z)",
    "returns": "float",
    "examples": ["\nfloat xoff = 0.0;\n\nvoid draw() {\n  background(204);\n  xoff = xoff + .01;\n  float n = noise(xoff) * width;\n  line(n, 0, n, height);\n}\n", "\nfloat noiseScale=0.02;\n\nvoid draw() {\n  background(0);\n  for (int x=0; x < width; x++) {\n    float noiseVal = noise((mouseX+x)*noiseScale, \n                            mouseY*noiseScale);\n    stroke(noiseVal*255);\n    line(x, mouseY+noiseVal*80, x, height);\n  }\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "x",
        "description": "float: x-coordinate in noise space"
    }, {
        "name": "y",
        "description": "float: y-coordinate in noise space"
    }, {
        "name": "z",
        "description": "float: z-coordinate in noise space"
    }]
}, {
    "name": "loadJSONArray()",
    "description": "\nLoads an array of JSON objects from the data folder or a URL, and returns a JSONArray.  Per standard JSON syntax, the array must be enclosed in a pair of hard brackets [], and each object within the array must be separated by a comma.\n\nAll files loaded and saved by the Processing API use UTF-8 encoding.\n",
    "syntax": "loadJSONArray(filename)\nloadJSONArray(file)",
    "returns": "JSONArray",
    "examples": ["\n// The following short JSON file called \"data.json\" is parsed \n// in the code below. It must be in the project's \"data\" folder.\n//\n// [\n//   {\n//     \"id\": 0,\n//     \"species\": \"Capra hircus\",\n//     \"name\": \"Goat\"\n//   },\n//   {\n//     \"id\": 1,\n//     \"species\": \"Panthera pardus\",\n//     \"name\": \"Leopard\"\n//   },\n//   {\n//     \"id\": 2,\n//     \"species\": \"Equus zebra\",\n//     \"name\": \"Zebra\"\n//   }\n// ]\n\nJSONArray values;\n\nvoid setup() {\n\n  values = loadJSONArray(\"data.json\");\n\n  for (int i = 0; i < values.size(); i++) {\n    \n    JSONObject animal = values.getJSONObject(i); \n\n    int id = animal.getInt(\"id\");\n    String species = animal.getString(\"species\");\n    String name = animal.getString(\"name\");\n\n    println(id + \", \" + species + \", \" + name);\n  }\n}\n\n// Sketch prints:\n// 0, Capra hircus, Goat\n// 1, Panthera pardus, Leopard\n// 2, Equus zebra, Zebra\n"],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: name of a file in the data folder or a URL"
    }]
}, {
    "name": "parseXML()",
    "description": "\nTakes a String, parses its contents, and returns an XML object.  If the String does not contain XML data or cannot be parsed, a null value is returned.\n\nparseXML() is most useful when pulling data dynamically, such as from third-party APIs.  Normally, API results would be saved to a String, and then can be converted to a structured XML object using parseXML().  Be sure to check if null is returned before performing operations on the new XML object, in case the String content could not be parsed.\n\nIf your data already exists as an XML file in the data folder, it is simpler to use loadXML().\n",
    "syntax": "parseXML(xmlString)\nparseXML(xmlString, options)",
    "returns": "XML",
    "examples": ["\nString data = \"<mammals><animal>Goat</animal></mammals>\";\n\nvoid setup() {\n  XML xml = parseXML(data);\n  if (xml == null) {\n    println(\"XML could not be parsed.\");\n  } else {\n    XML firstChild = xml.getChild(\"animal\");\n    println(firstChild.getContent());\n  }\n}\n\n// Sketch prints:\n// Goat\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "PI",
    "description": "\nPI is a mathematical constant with the value 3.14159265358979323846. It is the ratio of the circumference of a circle to its diameter. It is useful in combination with the trigonometric functions sin() and cos(). \n",
    "syntax": "",
    "returns": "",
    "examples": ["\nfloat x = width/2;\nfloat y = height/2;\nfloat d = width * 0.8;\narc(x, y, d, d, 0, QUARTER_PI);\narc(x, y, d-20, d-20, 0, HALF_PI);\narc(x, y, d-40, d-40, 0, PI);\narc(x, y, d-60, d-60, 0, TWO_PI);\n"],
    "examples_img": ["https://www.processing.org/reference/images/PI.png"],
    "parameters": []
}, {
    "name": "sphereDetail()",
    "description": "\nControls the detail used to render a sphere by adjusting the number of vertices of the sphere mesh. The default resolution is 30, which creates a fairly detailed sphere definition with vertices every 360/30 = 12 degrees. If you're going to render a great number of spheres per frame, it is advised to reduce the level of detail using this function. The setting stays active until sphereDetail() is called again with a new parameter and so should not be called prior to every sphere() statement, unless you wish to render spheres with different settings, e.g. using less detail for smaller spheres or ones further away from the camera. To control the detail of the horizontal and vertical resolution independently, use the version of the functions with two parameters.\n",
    "syntax": "sphereDetail(res)\nsphereDetail(ures, vres)",
    "returns": "void",
    "examples": ["\nvoid setup() {\n  size(100, 100, P3D); \n}\n\nvoid draw() {\n  background(200);\n  stroke(255, 50);\n  translate(50, 50, 0);\n  rotateX(mouseY * 0.05);\n  rotateY(mouseX * 0.05);\n  fill(mouseX * 2, 0, 160);\n  sphereDetail(mouseX / 4);\n  sphere(40);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "res",
        "description": "int: number of segments (minimum 3) used per full circle revolution"
    }, {
        "name": "ures",
        "description": "int: number of segments used longitudinally per full circle revolutoin"
    }, {
        "name": "vres",
        "description": "int: number of segments used latitudinally from top to bottom"
    }]
}, {
    "name": "day()",
    "description": "\nProcessing communicates with the clock on your computer. The day() function returns the current day as a value from 1 - 31.\n",
    "syntax": "day()",
    "returns": "int",
    "examples": ["\nint d = day();    // Values from 1 - 31\nint m = month();  // Values from 1 - 12\nint y = year();   // 2003, 2004, 2005, etc.\n\nString s = String.valueOf(d);\ntext(s, 10, 28);\ns = String.valueOf(m);\ntext(s, 10, 56); \ns = String.valueOf(y);\ntext(s, 10, 84);\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "noiseSeed()",
    "description": "\nSets the seed value for noise(). By default, noise() produces different results each time the program is run. Set the seed parameter to a constant to return the same pseudo-random numbers each time the software is run. \n",
    "syntax": "noiseSeed(seed)",
    "returns": "void",
    "examples": ["\nfloat xoff = 0.0;\n\nvoid setup() {\n  noiseSeed(0);\n  stroke(0, 10);\n}\n\nvoid draw() {\n  xoff = xoff + .01;\n  float n = noise(xoff) * width;\n  line(n, 0, n, height);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "seed",
        "description": "int: seed value"
    }]
}, {
    "name": "keyReleased()",
    "description": "\nThe keyReleased() function is called once every time a key is released. The key that was released will be stored in the key variable. See key and keyCode for more information.\n\nMouse and keyboard events only work when a program has draw(). Without draw(), the code is only run once and then stops listening for events.\n",
    "syntax": "keyReleased()\nkeyReleased(event)",
    "returns": "void",
    "examples": ["\n// Click on the image to give it focus,\n// and then press any key.\n\nint value = 0;\n\nvoid draw() {\n  fill(value);\n  rect(25, 25, 50, 50);\n}\n\nvoid keyReleased() {\n  if (value == 0) {\n    value = 255;\n  } else {\n    value = 0;\n  }\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "min()",
    "description": "\nDetermines the smallest value in a sequence of numbers, and then returns that value. min() accepts either two or three float or int values as parameters, or an array of any length.\n",
    "syntax": "min(a, b)\nmin(a, b, c)\nmin(list)",
    "returns": "float or int",
    "examples": ["\nint d = min(5, 9);            // Sets 'd' to 5\nint e = min(-4, -12);         // Sets 'e' to -12\nfloat f = min(12.3, 230.24);  // Sets 'f' to 12.3\n", "\nint[] values = { 5, 1, 2, -3 };  // Create an array of ints\nint h = min(values);             // Sets 'h' to -3\n"],
    "examples_img": [],
    "parameters": [{
        "name": "a",
        "description": "int, or float: first number"
    }, {
        "name": "b",
        "description": "int, or float: second number"
    }, {
        "name": "c",
        "description": "int, or float: third number"
    }, {
        "name": "list",
        "description": "float[], or int[]: array of numbers to compare"
    }]
}, {
    "name": "switch",
    "description": "\nWorks like an if else structure, but switch is more convenient when you need to select between three or more alternatives. Program controls jumps to the case with the same value as the expression. All remaining statements in the switch are executed unless redirected by a break. Only primitive datatypes which can convert to an integer (byte, char, and int) may be used as the expression parameter. The default is optional.\n",
    "syntax": "\nswitch(expression)\n{\n  case label: \n     statements          \n  case label:          // Optional\n     statements        // \"\n  default:             // \"\n     statements        // \"\n}\n",
    "returns": "",
    "examples": ["\nint num = 1;\n\nswitch(num) {\n  case 0: \n    println(\"Zero\");  // Does not execute\n    break;\n  case 1: \n    println(\"One\");  // Prints \"One\"\n    break;\n}\n", "\nchar letter = 'N';\n\nswitch(letter) {\n  case 'A': \n    println(\"Alpha\");  // Does not execute\n    break;\n  case 'B': \n    println(\"Bravo\");  // Does not execute\n    break;\n  default:             // Default executes if the case labels\n    println(\"None\");   // don't match the switch parameter\n    break;\n}\n", "\n// Removing a \"break\" enables testing\n// for more than one value at once\n\nchar letter = 'b';\n\nswitch(letter) {\n  case 'a':\n  case 'A': \n    println(\"Alpha\");  // Does not execute\n    break;\n  case 'b':\n  case 'B': \n    println(\"Bravo\");  // Prints \"Bravo\"\n    break;\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "expression",
        "description": "byte, char, or int"
    }, {
        "name": "label",
        "description": "byte, char, or int"
    }, {
        "name": "statements",
        "description": "one or more statements to be executed"
    }]
}, {
    "name": "saveJSONArray()",
    "description": "\nWrites the contents of a JSONArray object to a file. By default, this file is saved to the sketch's folder. This folder is opened by selecting \"Show Sketch Folder\" from the \"Sketch\" menu.\n\nAlternatively, the file can be saved to any location on the computer by using an absolute path (something that starts with / on Unix and Linux, or a drive letter on Windows).\n\nAll files loaded and saved by the Processing API use UTF-8 encoding.\n",
    "syntax": "saveJSONArray(json, filename)\nsaveJSONArray(json, filename, options)",
    "returns": "boolean",
    "examples": ["\nString[] species = { \"Capra hircus\", \"Panthera pardus\", \"Equus zebra\" };\nString[] names = { \"Goat\", \"Leopard\", \"Zebra\" };\n\nJSONArray values;\n\nvoid setup() {\n\n  values = new JSONArray();\n\n  for (int i = 0; i < species.length; i++) {\n\n    JSONObject animal = new JSONObject();\n\n    animal.setInt(\"id\", i);\n    animal.setString(\"species\", species[i]);\n    animal.setString(\"name\", names[i]);\n\n    values.setJSONObject(i, animal);\n  }\n\n  saveJSONArray(values, \"data/new.json\");\n}\n\n// Sketch saves the following to a file called \"new.json\":\n// [\n//   {\n//     \"id\": 0,\n//     \"species\": \"Capra hircus\",\n//     \"name\": \"Goat\"\n//   },\n//   {\n//     \"id\": 1,\n//     \"species\": \"Panthera pardus\",\n//     \"name\": \"Leopard\"\n//   },\n//   {\n//     \"id\": 2,\n//     \"species\": \"Equus zebra\",\n//     \"name\": \"Zebra\"\n//   }\n// ]\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "curveTightness()",
    "description": "\nModifies the quality of forms created with curve() and curveVertex(). The parameter tightness determines how the curve fits to the vertex points. The value 0.0 is the default value for tightness (this value defines the curves to be Catmull-Rom splines) and the value 1.0 connects all the points with straight lines. Values within the range -5.0 and 5.0 will deform the curves but will leave them recognizable and as values increase in magnitude, they will continue to deform.\n",
    "syntax": "curveTightness(tightness)",
    "returns": "void",
    "examples": ["\n// Move the mouse left and right to see the curve change\n\nvoid setup() {\n  size(100, 100);\n  noFill();\n}\n\nvoid draw() {\n  background(204);\n  float t = map(mouseX, 0, width, -5, 5);\n  curveTightness(t);\n  beginShape();\n  curveVertex(10, 26);\n  curveVertex(10, 26);\n  curveVertex(83, 24);\n  curveVertex(83, 61);\n  curveVertex(25, 65); \n  curveVertex(25, 65);\n  endShape();\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "tightness",
        "description": "float: amount of deformation from the original vertices"
    }]
}, {
    "name": "second()",
    "description": "\nProcessing communicates with the clock on your computer. The second() function returns the current second as a value from 0 - 59.\n",
    "syntax": "second()",
    "returns": "int",
    "examples": ["\nvoid draw() {\n  background(204);\n  int s = second();  // Values from 0 - 59\n  int m = minute();  // Values from 0 - 59\n  int h = hour();    // Values from 0 - 23\n  line(s, 0, s, 33);\n  line(m, 33, m, 66);\n  line(h, 66, h, 100);\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "HALF_PI",
    "description": "\nHALF_PI is a mathematical constant with the value 1.57079632679489661923. It is half the ratio of the circumference of a circle to its diameter. It is useful in combination with the trigonometric functions sin() and cos(). \n",
    "syntax": "",
    "returns": "",
    "examples": ["\nfloat x = width/2;\nfloat y = height/2;\nfloat d = width * 0.8;\narc(x, y, d, d, 0, QUARTER_PI);\narc(x, y, d-20, d-20, 0, HALF_PI);\narc(x, y, d-40, d-40, 0, PI);\narc(x, y, d-60, d-60, 0, TWO_PI);\n"],
    "examples_img": ["https://www.processing.org/reference/images/HALF_PI.png"],
    "parameters": []
}, {
    "name": "loadTable()",
    "description": "\nReads the contents of a file or URL and creates an Table object with its values. If a file is specified, it must be located in the sketch's \"data\" folder. The filename parameter can also be a URL to a file found online. The filename must either end in an extension or an extension must be specified in the options (if an extension is in both places, the extension in the options is used). For example, to use tab-separated data, include \"tsv\" in the options parameter if the filename or URL does not end in .tsv.\n\nIf the file contains a header row, include \"header\" in the options parameter.  If the file does not have a header row, then simply omit the \"header\" option.\n\nWhen specifying both a header and the file type, separate the options with commas, as in: loadTable(\"data.csv\", \"header, tsv\")\n\nAll files loaded and saved by the Processing API use UTF-8 encoding.\n",
    "syntax": "loadTable(filename)\nloadTable(filename, options)",
    "returns": "Table",
    "examples": ["\n// The following short CSV file called \"mammals.csv\" is parsed \n// in the code below. It must be in the project's \"data\" folder.\n//\n// id,species,name\n// 0,Capra hircus,Goat\n// 1,Panthera pardus,Leopard\n// 2,Equus zebra,Zebra\n\nTable table;\n\nvoid setup() {\n  \n  table = loadTable(\"mammals.csv\", \"header\");\n\n  println(table.getRowCount() + \" total rows in table\"); \n\n  for (TableRow row : table.rows()) {\n    \n    int id = row.getInt(\"id\");\n    String species = row.getString(\"species\");\n    String name = row.getString(\"name\");\n    \n    println(name + \" (\" + species + \") has an ID of \" + id);\n  }\n  \n}\n\n// Sketch prints:\n// 3 total rows in table\n// Goat (Capra hircus) has an ID of 0\n// Leopard (Panthera pardus) has an ID of 1\n// Zebra (Equus zebra) has an ID of 2\n"],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: name of a file in the data folder or a URL."
    }]
}, {
    "name": "modelY()",
    "description": "\nReturns the three-dimensional X, Y, Z position in model space. This returns the Y value for a given coordinate based on the current set of transformations (scale, rotate, translate, etc.) The Y value can be used to place an object in space relative to the location of the original point once the transformations are no longer in use. \n\nIn the example, the modelX(), modelY(), and modelZ() functions record the location of a box in space after being placed using a series of translate and rotate commands. After popMatrix() is called, those transformations no longer apply, but the (x, y, z) coordinate returned by the model functions is used to place another box in the same location.\n",
    "syntax": "modelY(x, y, z)",
    "returns": "float",
    "examples": ["\nvoid setup() {\n  size(500, 500, P3D);\n  noFill();\n}\n\nvoid draw() {\n  background(0);\n \n  pushMatrix();\n  // start at the middle of the screen\n  translate(width/2, height/2, -200);     \n  // some random rotation to make things interesting\n  rotateY(1.0); //yrot);\n  rotateZ(2.0); //zrot);\n  // rotate in X a little more each frame\n  rotateX(frameCount / 100.0);\n  // offset from center\n  translate(0, 150, 0);\n \n  // draw a white box outline at (0, 0, 0)\n  stroke(255);\n  box(50);\n \n  // the box was drawn at (0, 0, 0), store that location\n  float x = modelX(0, 0, 0);\n  float y = modelY(0, 0, 0);\n  float z = modelZ(0, 0, 0);\n  // clear out all the transformations\n  popMatrix();\n\n  // draw another box at the same (x, y, z) coordinate as the other\n  pushMatrix();\n  translate(x, y, z);\n  stroke(255, 0, 0);\n  box(50);\n  popMatrix();\n} \n"],
    "examples_img": [],
    "parameters": [{
        "name": "x",
        "description": "float: 3D x-coordinate to be mapped"
    }, {
        "name": "y",
        "description": "float: 3D y-coordinate to be mapped"
    }, {
        "name": "z",
        "description": "float: 3D z-coordinate to be mapped"
    }]
}, {
    "name": "frameRate()",
    "description": "\nSpecifies the number of frames to be displayed every second. For example, the function call frameRate(30) will attempt to refresh 30 times a second. If the processor is not fast enough to maintain the specified rate, the frame rate will not be achieved. Setting the frame rate within setup() is recommended. The default rate is 60 frames per second.\n",
    "syntax": "frameRate(fps)",
    "returns": "void",
    "examples": ["\nvoid setup() {\n  frameRate(4);\n}\nint pos = 0;\nvoid draw() {\n  background(204);\n  pos++;\n  line(pos, 20, pos, 80);\n  if (pos > width) {\n    pos = 0;\n  }\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "fps",
        "description": "float: number of desired frames per second"
    }]
}, {
    "name": "endRecord()",
    "description": "\nStops the recording process started by beginRecord() and closes the file.\n",
    "syntax": "endRecord()",
    "returns": "void",
    "examples": ["\nimport processing.pdf.*;\n\nvoid setup() {\n  size(400, 400);\n  beginRecord(PDF, \"everything.pdf\");\n}\n\nvoid draw() {\n  ellipse(mouseX, mouseY, 10, 10);\n}\n\nvoid mousePressed() {\n  endRecord();\n  exit();\n} \n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "endContour()",
    "description": "\nUse the beginContour() and endContour() function to create negative shapes within shapes such as the center of the letter 'O'. beginContour() begins recording vertices for the shape and endContour() stops recording. The vertices that define a negative shape must \"wind\" in the opposite direction from the exterior shape. First draw vertices for the exterior shape in clockwise order, then for internal shapes, draw vertices counter-clockwise.\n\nThese functions can only be used within a beginShape()/endShape() pair and transformations such as translate(), rotate(), and scale() do not work within a beginContour()/endContour() pair. It is also not possible to use other shapes, such as ellipse() or rect() within.\n",
    "syntax": "endContour()",
    "returns": "void",
    "examples": ["\nsize(100, 100);\ntranslate(50, 50);\nstroke(255, 0, 0);\nbeginShape();\n// Exterior part of shape, clockwise winding\nvertex(-40, -40);\nvertex(40, -40);\nvertex(40, 40);\nvertex(-40, 40);\n// Interior part of shape, counter-clockwise winding\nbeginContour();\nvertex(-20, -20);\nvertex(-20, 20);\nvertex(20, 20);\nvertex(20, -20);\nendContour();\nendShape(CLOSE);\n"],
    "examples_img": ["https://www.processing.org/reference/images/beginContour_0.png"],
    "parameters": []
}, {
    "name": "saveStream()",
    "description": "\nSave the contents of a stream to a file in the sketch folder. This is basically saveBytes(blah, loadBytes()), but done more efficiently (and with less confusing syntax).\n   \nThe target parameter can be either a String specifying a file name, or, for greater control over the file location, a File object. (Note that, unlike some other functions, this will not automatically compress or uncompress gzip files.)\n",
    "syntax": "saveStream(target, source)",
    "returns": "boolean or void",
    "examples": [""],
    "examples_img": [],
    "parameters": [{
        "name": "target",
        "description": "File, or String: name of the file to write to"
    }, {
        "name": "source",
        "description": "String: location to read from (a filename, path, or URL)"
    }]
}, {
    "name": "extends",
    "description": "\nAllows a new class to inherit the methods and data fields (variables and constants) from an existing class. In code, state the name of the new class, followed by the keyword extends and the name of the base class. The concept of inheritance is one of the fundamental principles of object oriented programming.\n\nNote that in Java, and therefore also Processing, you cannot extend a class more than once. Instead, see implements.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nDrawDot dd1 = new DrawDot(50, 80);\n\nvoid setup() { \n  size(200, 200);\n} \n \nvoid draw() {\n  dd1.display();\n} \n \nclass Dot { \n  int xpos, ypos;\n} \n\nclass DrawDot extends Dot {\n  DrawDot(int x, int y) {\n    xpos = x;\n    ypos = y;\n  }\n  void display() {\n    ellipse(xpos, ypos, 200, 200);\n  }\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "try",
    "description": "\nThe try keyword is used with catch to handle exceptions. Sun's Java documentation defines an exception as \"an event, which occurs during the execution of a program, that disrupts the normal flow of the program's instructions.\" This could be, for example, an error while a file is read.\n",
    "syntax": "\ntry {\n  tryStatements\n} catch (exception) {\n  catchStatements\n} \n",
    "returns": "",
    "examples": ["\nBufferedReader reader;\nString line;\n \nvoid setup() {\n  // Open the file from the createWriter() example\n  reader = createReader(\"positions.txt\");    \n}\n \nvoid draw() {\n  try {\n    line = reader.readLine();\n  } catch (IOException e) {\n    e.printStackTrace();\n    line = null;\n  }\n  if (line == null) {\n    // Stop reading because of an error or file is empty\n    noLoop();  \n  } else {\n    String[] pieces = split(line, TAB);\n    int x = int(pieces[0]);\n    int y = int(pieces[1]);\n    point(x, y);\n  }\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "tryStatements",
        "description": "if this code throws an exception, then the code in \"catch\" is run"
    }, {
        "name": "exception",
        "description": "the Java exception that was thrown"
    }, {
        "name": "catchStatements",
        "description": "code that handles the exception"
    }]
}, {
    "name": "saveFrame()",
    "description": "\nSaves a numbered sequence of images, one image each time the function is run. To save an image that is identical to the display window, run the function at the end of draw() or within mouse and key events such as mousePressed() and keyPressed(). Use the Movie Maker program in the Tools menu to combine these images to a movie.\n\nIf saveFrame() is used without parameters, it will save files as screen-0000.tif, screen-0001.tif, and so on. You can specify the name of the sequence with the filename parameter, including hash marks (####), which will be replaced by the current frameCount value. (The number of hash marks is used to determine how many digits to include in the file names.) Append a file extension, to indicate the file format to be used: either TIFF (.tif), TARGA (.tga), JPEG (.jpg), or PNG (.png). Image files are saved to the sketch's folder, which may be opened by selecting \"Show Sketch Folder\" from the \"Sketch\" menu.\n\nAlternatively, the files can be saved to any location on the computer by using an absolute path (something that starts with / on Unix and Linux, or a drive letter on Windows).\n\nAll images saved from the main drawing window will be opaque. To save images without a background, use createGraphics().\n",
    "syntax": "saveFrame()\nsaveFrame(filename)",
    "returns": "void",
    "examples": ["\nint x = 0;\nvoid draw() {\n  background(204);\n  if (x < 100) {\n    line(x, 0, x, 100);\n    x = x + 1;\n  } else {\n    noLoop();\n  }\n  // Saves each frame as screen-0001.tif, screen-0002.tif, etc.\n  saveFrame(); \n}\n", "\nint x = 0;\nvoid draw() {\n  background(204);\n  if (x < 100) {\n    line(x, 0, x, 100);\n    x = x + 1;\n  } else {\n    noLoop();\n  }\n  // Saves each frame as line-000001.png, line-000002.png, etc.\n  saveFrame(\"line-######.png\");\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: any sequence of letters or numbers that ends with either \".tif\", \".tga\", \".jpg\", or \".png\""
    }]
}, {
    "name": "createOutput()",
    "description": "\nSimilar to createInput(), this creates a Java OutputStream for a given filename or path. The file will be created in the sketch folder, or in the same folder as an exported application.\n\nIf the path does not exist, intermediate folders will be created. If an exception occurs, it will be printed to the console, and null will be returned.\n\nThis function is a convenience over the Java approach that requires you to 1) create a FileOutputStream object, 2) determine the exact file location, and 3) handle exceptions. Exceptions are handled internally by the function, which is more appropriate for \"sketch\" projects.\n\nIf the output filename ends with .gz, the output will be automatically GZIP compressed as it is written.\n",
    "syntax": "createOutput(filename)",
    "returns": "OutputStream",
    "examples": [""],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: name of the file to open"
    }]
}, {
    "name": "FloatDict",
    "description": "\nA simple class to use a String as a lookup for an float value. String \"keys\" are associated with floating-point values.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nFloatDict inventory;\n\nvoid setup() {\n  size(200, 200);\n  inventory = new FloatDict();\n  inventory.set(\"coffee\",108.6);\n  inventory.set(\"flour\",5.8);\n  inventory.set(\"tea\",8.2);\n  println(inventory);\n  noLoop();\n  fill(0);\n  textAlign(CENTER);\n}\n\nvoid draw() {\n  float weight = inventory.get(\"coffee\");\n  text(weight, width/2, height/2);\n}\n\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "resetMatrix()",
    "description": "\nReplaces the current matrix with the identity matrix. The equivalent function in OpenGL is glLoadIdentity(). \n",
    "syntax": "resetMatrix()",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nnoFill();\nbox(80);\nprintMatrix();\n// Prints:\n// 01.0000  00.0000  00.0000 -50.0000\n// 00.0000  01.0000  00.0000 -50.0000\n// 00.0000  00.0000  01.0000 -86.6025\n// 00.0000  00.0000  00.0000  01.0000\n\nresetMatrix();\nbox(80);\nprintMatrix();\n// Prints:\n// 1.0000  0.0000  0.0000  0.0000\n// 0.0000  1.0000  0.0000  0.0000\n// 0.0000  0.0000  1.0000  0.0000\n// 0.0000  0.0000  0.0000  1.0000\n"],
    "examples_img": ["https://www.processing.org/reference/images/resetMatrix_.png"],
    "parameters": []
}, {
    "name": "strokeJoin()",
    "description": "\nSets the style of the joints which connect line segments. These joints are either mitered, beveled, or rounded and specified with the corresponding parameters MITER, BEVEL, and ROUND. The default joint is MITER. \n",
    "syntax": "strokeJoin(join)",
    "returns": "void",
    "examples": ["\nnoFill();\nstrokeWeight(10.0);\nstrokeJoin(MITER);\nbeginShape();\nvertex(35, 20);\nvertex(65, 50);\nvertex(35, 80);\nendShape();\n", "\nnoFill();\nstrokeWeight(10.0);\nstrokeJoin(BEVEL);\nbeginShape();\nvertex(35, 20);\nvertex(65, 50);\nvertex(35, 80);\nendShape();\n", "\nnoFill();\nstrokeWeight(10.0);\nstrokeJoin(ROUND);\nbeginShape();\nvertex(35, 20);\nvertex(65, 50);\nvertex(35, 80);\nendShape();\n"],
    "examples_img": ["https://www.processing.org/reference/images/strokeJoin_0.png", "https://www.processing.org/reference/images/strokeJoin_1.png", "https://www.processing.org/reference/images/strokeJoin_2.png"],
    "parameters": [{
        "name": "join",
        "description": "int: either MITER, BEVEL, ROUND"
    }]
}, {
    "name": "saveBytes()",
    "description": "\nAs the opposite of loadBytes(), this function will write an entire array of bytes to a file. The data is saved in binary format. This file is saved to the sketch's folder, which is opened by selecting \"Show Sketch Folder\" from the \"Sketch\" menu. Alternatively, the files can be saved to any location on the computer by using an absolute path (something that starts with / on Unix and Linux, or a drive letter on Windows).\n",
    "syntax": "saveBytes(filename, data)",
    "returns": "void",
    "examples": ["\nbyte[] nums = { 0, 34, 5, 127, 52};\n\n// Writes the bytes to a file\nsaveBytes(\"numbers.dat\", nums);\n"],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: name of the file to write to"
    }, {
        "name": "data",
        "description": "byte[]: array of bytes to be written"
    }]
}, {
    "name": "radians()",
    "description": "\nConverts a degree measurement to its corresponding value in radians. Radians and degrees are two ways of measuring the same thing. There are 360 degrees in a circle and 2*PI radians in a circle. For example, 90 = PI/2 = 1.5707964. All trigonometric functions in Processing require their parameters to be specified in radians.\n",
    "syntax": "radians(degrees)",
    "returns": "float",
    "examples": ["\nfloat deg = 45.0;\nfloat rad = radians(deg);\nprintln(deg + \" degrees is \" + rad + \" radians\");\n"],
    "examples_img": [],
    "parameters": [{
        "name": "degrees",
        "description": "float: degree value to convert to radians"
    }]
}, {
    "name": "tan()",
    "description": "\nCalculates the ratio of the sine and cosine of an angle. This function expects the values of the angle parameter to be provided in radians (values from 0 to PI*2). Values are returned in the range infinity to -infinity.\n",
    "syntax": "tan(angle)",
    "returns": "float",
    "examples": ["\nfloat a = 0.0;\nfloat inc = TWO_PI/50.0;\n\nfor (int i = 0; i < 100; i = i+2) {\n  line(i, 50, i, 50+tan(a)*2.0);\n  a = a + inc;\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/tan_.png"],
    "parameters": [{
        "name": "angle",
        "description": "float: an angle in radians"
    }]
}, {
    "name": "map()",
    "description": "\nRe-maps a number from one range to another.\n\nIn the first example above, the number 25 is converted from a value in the range of 0 to 100 into a value that ranges from the left edge of the window (0) to the right edge (width).\n\nAs shown in the second example, numbers outside of the range are not clamped to the minimum and maximum parameters values, because out-of-range values are often intentional and useful.\n",
    "syntax": "map(value, start1, stop1, start2, stop2)",
    "returns": "float",
    "examples": ["\nsize(200, 200);\nfloat value = 25;\nfloat m = map(value, 0, 100, 0, width);\nellipse(m, 200, 10, 10);\n", "\nfloat value = 110;\nfloat m = map(value, 0, 100, -20, -10);\nprintln(m);  // Prints \"-9.0\"\n", "\nvoid setup() {\n  size(200, 200);\n  noStroke();\n}\n\nvoid draw() {\n  background(204);\n  float  x1 = map(mouseX, 0, width, 50, 150);\n  ellipse(x1, 75, 50, 50);  \n  float x2 = map(mouseX, 0, width, 0, 200);\n  ellipse(x2, 125, 50, 50);  \n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value",
        "description": "float: the incoming value to be converted"
    }, {
        "name": "start1",
        "description": "float: lower bound of the value's current range"
    }, {
        "name": "stop1",
        "description": "float: upper bound of the value's current range"
    }, {
        "name": "start2",
        "description": "float: lower bound of the value's target range"
    }, {
        "name": "stop2",
        "description": "float: upper bound of the value's target range"
    }]
}, {
    "name": "sin()",
    "description": "\nCalculates the sine of an angle. This function expects the values of the angle parameter to be provided in radians (values from 0 to 6.28). Values are returned in the range -1 to 1.\n",
    "syntax": "sin(angle)",
    "returns": "float",
    "examples": ["\nfloat a = 0.0;\nfloat inc = TWO_PI/25.0;\n\nfor (int i = 0; i < 100; i=i+4) {\n  line(i, 50, i, 50+sin(a)*40.0);\n  a = a + inc;\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/sin_.png"],
    "parameters": [{
        "name": "angle",
        "description": "float: an angle in radians"
    }]
}, {
    "name": "random()",
    "description": "\nGenerates random numbers. Each time the random() function is called, it returns an unexpected value within the specified range. If only one parameter is passed to the function, it will return a float between zero and the value of the high parameter. For example, random(5) returns values between 0 and 5 (starting at zero, and up to, but not including, 5).\n\nIf two parameters are specified, the function will return a float with a value between the two values. For example, random(-5, 10.2) returns values starting at -5 and up to (but not including) 10.2. To convert a floating-point random number to an integer, use the int() function.\n",
    "syntax": "random(high)\nrandom(low, high)",
    "returns": "float",
    "examples": ["\nfor (int i = 0; i < 100; i++) {\n  float r = random(50);\n  stroke(r*5);\n  line(50, i, 50+r, i);\n}\n", "\nfor (int i = 0; i < 100; i++) {\n  float r = random(-50, 50);\n  println(r);\n}\n", "\n// Get a random element from an array\nString[] words = { \"apple\", \"bear\", \"cat\", \"dog\" };\nint index = int(random(words.length));  // Same as int(random(4))\nprintln(words[index]);  // Prints one of the four words\n"],
    "examples_img": [],
    "parameters": [{
        "name": "low",
        "description": "float: lower limit"
    }, {
        "name": "high",
        "description": "float: upper limit"
    }]
}, {
    "name": "randomSeed()",
    "description": "\nSets the seed value for random(). By default, random() produces different results each time the program is run. Set the seed parameter to a constant to return the same pseudo-random numbers each time the software is run.\n",
    "syntax": "randomSeed(seed)",
    "returns": "void",
    "examples": ["\nrandomSeed(0);\nfor (int i=0; i < 100; i++) {\n  float r = random(0, 255);\n  stroke(r);\n  line(i, 0, i, 100);\n}\n\n"],
    "examples_img": [],
    "parameters": [{
        "name": "seed",
        "description": "int: seed value"
    }]
}, {
    "name": "loadPixels()",
    "description": "\nLoads the pixel data for the display window into the pixels[] array. This function must always be called before reading from or writing to pixels[].\n\nCertain renderers may or may not seem to require loadPixels() or updatePixels(). However, the rule is that any time you want to manipulate the pixels[] array, you must first call loadPixels(), and after changes have been made, call updatePixels(). Even if the renderer may not seem to use this function in the current Processing release, this will always be subject to change.\n",
    "syntax": "loadPixels()",
    "returns": "void",
    "examples": ["\nint halfImage = width*height/2;\nPImage myImage = loadImage(\"apples.jpg\");\nimage(myImage, 0, 0);\n\nloadPixels();\nfor (int i = 0; i < halfImage; i++) {\n  pixels[i+halfImage] = pixels[i];\n}\nupdatePixels();\n"],
    "examples_img": ["https://www.processing.org/reference/images/loadPixels_.png"],
    "parameters": []
}, {
    "name": "sq()",
    "description": "\nSquares a number (multiplies a number by itself). The result is always a positive number, as multiplying two negative numbers always yields a positive result. For example, -1 * -1 = 1.\n",
    "syntax": "sq(n)",
    "returns": "float",
    "examples": ["\nnoStroke();\nfloat a = sq(1);   // Sets 'a' to 1\nfloat b = sq(-5);  // Sets 'b' to 25\nfloat c = sq(9);   // Sets 'c' to 81\nrect(0, 25, a, 10);\nrect(0, 45, b, 10);\nrect(0, 65, c, 10);\n"],
    "examples_img": ["https://www.processing.org/reference/images/sq_.png"],
    "parameters": [{
        "name": "n",
        "description": "float: number to square"
    }]
}, {
    "name": "set()",
    "description": "\nChanges the color of any pixel, or writes an image directly to the display window.\n\nThe x and y parameters specify the pixel to change and the c parameter specifies the color value. The c parameter is interpreted according to the current color mode.  (The default color mode is RGB values from 0 to 255.)  When setting an image, the x and y parameters define the coordinates for the upper-left corner of the image, regardless of the current imageMode().\n\nSetting the color of a single pixel with set(x, y) is easy, but not as fast as putting the data directly into pixels[]. The equivalent statement to set(x, y, #000000) using pixels[] is pixels[y*width+x] = #000000. See the reference for pixels[] for more information.\n",
    "syntax": "set(x, y, c)\nset(x, y, img)",
    "returns": "void",
    "examples": ["\ncolor black = color(0);\nset(30, 20, black);\nset(85, 20, black);\nset(85, 75, black);\nset(30, 75, black);\n", "\nfor (int i = 30; i < width-15; i++) {\n  for (int j = 20; j < height-25; j++) {\n    color c = color(204-j, 153-i, 0);\n    set(i, j, c);\n  }\n}\n", "\nsize(100, 100);\nPImage myImage = loadImage(\"apples.jpg\");\nset(0, 0, myImage);\nline(0, 0, width, height);\nline(0, height, width, 0);\n"],
    "examples_img": ["https://www.processing.org/reference/images/set_0.png", "https://www.processing.org/reference/images/set_1.png", "https://www.processing.org/reference/images/set_2.png"],
    "parameters": [{
        "name": "x",
        "description": "int: x-coordinate of the pixel"
    }, {
        "name": "y",
        "description": "int: y-coordinate of the pixel"
    }, {
        "name": "c",
        "description": "int: any value of the color datatype"
    }, {
        "name": "img",
        "description": "PImage: image to copy into the original image"
    }]
}, {
    "name": "beginRaw()",
    "description": "\nTo create vectors from 3D data, use the beginRaw() and endRaw() commands. These commands will grab the shape data just before it is rendered to the screen. At this stage, your entire scene is nothing but a long list of individual lines and triangles. This means that a shape created with sphere() function will be made up of hundreds of triangles, rather than a single object. Or that a multi-segment line shape (such as a curve) will be rendered as individual segments.\n\nWhen using beginRaw() and endRaw(), it's possible to write to either a 2D or 3D renderer. For instance, beginRaw() with the PDF library will write the geometry as flattened triangles and lines, even if recording from the P3D renderer. \n\nIf you want a background to show up in your files, use rect(0, 0, width, height) after setting the fill() to the background color. Otherwise the background will not be rendered to the file because the background is not shape.\n\nUsing hint(ENABLE_DEPTH_SORT) can improve the appearance of 3D geometry drawn to 2D file formats. See the hint() reference for more details.\n\nSee examples in the reference for the PDF and DXF libraries for more information.\n",
    "syntax": "beginRaw(renderer, filename)",
    "returns": "PGraphics or void",
    "examples": ["\nimport processing.pdf.*;\n\nvoid setup() {\n  size(400, 400);\n  beginRaw(PDF, \"raw.pdf\");\n}\n\nvoid draw() {\n  line(pmouseX, pmouseY, mouseX, mouseY);\n}\n\nvoid keyPressed() {\n  if (key == ' ') {\n    endRaw();\n    exit();\n  }\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "renderer",
        "description": "String: for example, PDF or DXF"
    }, {
        "name": "filename",
        "description": "String: filename for output"
    }]
}, {
    "name": "alpha()",
    "description": "\nExtracts the alpha value from a color.\n",
    "syntax": "alpha(rgb)",
    "returns": "float",
    "examples": ["\nnoStroke();\ncolor c = color(0, 126, 255, 102);\nfill(c);\nrect(15, 15, 35, 70);\nfloat value = alpha(c);  // Sets 'value' to 102\nfill(value);\nrect(50, 15, 35, 70);\n"],
    "examples_img": ["https://www.processing.org/reference/images/alpha_.png"],
    "parameters": [{
        "name": "rgb",
        "description": "int: any value of the color datatype"
    }]
}, {
    "name": "updatePixels()",
    "description": "\nUpdates the display window with the data in the pixels[] array. Use in conjunction with loadPixels(). If you're only reading pixels from the array, there's no need to call updatePixels()  updating is only necessary to apply changes.\n\nCertain renderers may or may not seem to require loadPixels() or updatePixels(). However, the rule is that any time you want to manipulate the pixels[] array, you must first call loadPixels(), and after changes have been made, call updatePixels(). Even if the renderer may not seem to use this function in the current Processing release, this will always be subject to change.\n\nCurrently, while none of the renderers use the additional parameters to updatePixels(), this may be implemented in the future.\n",
    "syntax": "updatePixels()",
    "returns": "void",
    "examples": ["\nPImage img = loadImage(\"rockies.jpg\");\nimage(img, 0, 0);\nint halfImage = img.width * img.height/2;\nloadPixels();\nfor (int i = 0; i < halfImage; i++) {\n  pixels[i+halfImage] = pixels[i];\n}\nupdatePixels();\n"],
    "examples_img": ["https://www.processing.org/reference/images/updatePixels_.png"],
    "parameters": []
}, {
    "name": "TAU",
    "description": "\nTAU is an alias for TWO_PI, a mathematical constant with the value 6.28318530717958647693. It is twice the ratio of the circumference of a circle to its diameter. It is useful in combination with the trigonometric functions sin() and cos().\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nfloat x = width/2;\nfloat y = height/2;\nfloat d = width * 0.8;\narc(x, y, d, d, 0, QUARTER_PI);\narc(x, y, d-20, d-20, 0, HALF_PI);\narc(x, y, d-40, d-40, 0, PI);\narc(x, y, d-60, d-60, 0, TAU);\n"],
    "examples_img": ["https://www.processing.org/reference/images/TWO_PI.png"],
    "parameters": []
}, {
    "name": "saveXML()",
    "description": "\nWrites the contents of an XML object to a file. By default, this file is saved to the sketch's folder. This folder is opened by selecting \"Show Sketch Folder\" from the \"Sketch\" menu.\n\nAlternatively, the file can be saved to any location on the computer by using an absolute path (something that starts with / on Unix and Linux, or a drive letter on Windows).\n\nAll files loaded and saved by the Processing API use UTF-8 encoding.\n",
    "syntax": "saveXML(xml, filename)\nsaveXML(xml, filename, options)",
    "returns": "boolean",
    "examples": ["\n// The following short XML file called \"mammals.xml\" is parsed \n// in the code below. It must be in the project's \"data\" folder.\n//\n// <?xml version=\"1.0\"?>\n// <mammals>\n//   <animal id=\"0\" species=\"Capra hircus\">Goat</animal>\n//   <animal id=\"1\" species=\"Panthera pardus\">Leopard</animal>\n//   <animal id=\"2\" species=\"Equus zebra\">Zebra</animal>\n// </mammals>\n\nXML xml;\n\nvoid setup() {\n  xml = loadXML(\"mammals.xml\");\n  XML firstChild = xml.getChild(\"animal\");\n  xml.removeChild(firstChild);\n  saveXML(xml, \"subset.xml\");\n}\n\n// Sketch saves the following to a file called \"subset.xml\":\n// <?xml version=\"1.0\"?>\n// <mammals>\n//   <animal id=\"1\" species=\"Panthera pardus\">Leopard</animal>\n//   <animal id=\"2\" species=\"Equus zebra\">Zebra</animal>\n// </mammals>\n"],
    "examples_img": [],
    "parameters": [{
        "name": "xml",
        "description": "XML: the XML object to save to disk"
    }, {
        "name": "filename",
        "description": "String: name of the file to write to"
    }]
}, {
    "name": "printProjection()",
    "description": "\nPrints the current projection matrix to the Console (the text window at the bottom of Processing).\n",
    "syntax": "printProjection()",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nprintProjection();\n\n// The program above prints this data:\n// 01.7321  00.0000  00.0000  00.0000\n// 00.0000 -01.7321  00.0000  00.0000\n// 00.0000  00.0000 -01.0202 -17.4955\n// 00.0000  00.0000 -01.0000  00.0000\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "degrees()",
    "description": "\nConverts a radian measurement to its corresponding value in degrees. Radians and degrees are two ways of measuring the same thing. There are 360 degrees in a circle and 2*PI radians in a circle. For example, 90 = PI/2 = 1.5707964. All trigonometric functions in Processing require their parameters to be specified in radians.\n",
    "syntax": "degrees(radians)",
    "returns": "float",
    "examples": ["\nfloat rad = PI/4;\nfloat deg = degrees(rad);\nprintln(rad + \" radians is \" + deg + \" degrees\");\n"],
    "examples_img": [],
    "parameters": [{
        "name": "radians",
        "description": "float: radian value to convert to degrees"
    }]
}, {
    "name": "fill()",
    "description": "\nSets the color used to fill shapes. For example, if you run fill(204, 102, 0), all subsequent shapes will be filled with orange. This color is either specified in terms of the RGB or HSB color depending on the current colorMode().  (The default color space is RGB, with each value in the range from 0 to 255.)\n\nWhen using hexadecimal notation to specify a color, use \"#\" or \"0x\" before the values (e.g., #CCFFAA or 0xFFCCFFAA). The # syntax uses six digits to specify a color (just as colors are typically specified in HTML and CSS). When using the hexadecimal notation starting with \"0x\", the hexadecimal value must be specified with eight characters; the first two characters define the alpha component, and the remainder define the red, green, and blue components. \n\nThe value for the \"gray\" parameter must be less than or equal to the current maximum value as specified by colorMode(). The default maximum value is 255.\n\nTo change the color of an image or a texture, use tint().\n",
    "syntax": "fill(rgb)\nfill(rgb, alpha)\nfill(gray)\nfill(gray, alpha)\nfill(v1, v2, v3)\nfill(v1, v2, v3, alpha)",
    "returns": "void",
    "examples": ["\nfill(153);\nrect(30, 20, 55, 55);\n", "\nfill(204, 102, 0);\nrect(30, 20, 55, 55);\n"],
    "examples_img": ["https://www.processing.org/reference/images/fill_0.png", "https://www.processing.org/reference/images/fill_1.png"],
    "parameters": [{
        "name": "rgb",
        "description": "int: color variable or hex value"
    }, {
        "name": "alpha",
        "description": "float: opacity of the fill"
    }, {
        "name": "gray",
        "description": "float: number specifying value between white and black"
    }, {
        "name": "v1",
        "description": "float: red or hue value (depending on current color mode)"
    }, {
        "name": "v2",
        "description": "float: green or saturation value (depending on current color mode)"
    }, {
        "name": "v3",
        "description": "float: blue or brightness value (depending on current color mode)"
    }]
}, {
    "name": "pixels[]",
    "description": "\nArray containing the values for all the pixels in the display window. These values are of the color datatype. This array is the size of the display window. For example, if the image is 100x100 pixels, there will be 10000 values and if the window is 200x300 pixels, there will be 60000 values. The index value defines the position of a value within the array. For example, the statement color b = pixels[230] will set the variable b to be equal to the value at that location in the array.\n\nBefore accessing this array, the data must loaded with the loadPixels() function. After the array data has been modified, the updatePixels() function must be run to update the changes. Without loadPixels(), running the code may (or will in future releases) result in a NullPointerException.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\ncolor pink = color(255, 102, 204);\nloadPixels();\nfor (int i = 0; i < (width*height/2)-width/2; i++) {\n  pixels[i] = pink;\n}\nupdatePixels();\n"],
    "examples_img": ["https://www.processing.org/reference/images/pixels.png"],
    "parameters": []
}, {
    "name": "minute()",
    "description": "\nProcessing communicates with the clock on your computer. The minute() function returns the current minute as a value from 0 - 59.\n",
    "syntax": "minute()",
    "returns": "int",
    "examples": ["\nvoid draw() {\n  background(204);\n  int s = second();  // Values from 0 - 59\n  int m = minute();  // Values from 0 - 59\n  int h = hour();    // Values from 0 - 23\n  line(s, 0, s, 33);\n  line(m, 33, m, 66);\n  line(h, 66, h, 100);\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "year()",
    "description": "\nProcessing communicates with the clock on your computer. The year() function returns the current year as an integer (2003, 2004, 2005, etc).\n",
    "syntax": "year()",
    "returns": "int",
    "examples": ["\nint d = day();    // Values from 1 - 31\nint m = month();  // Values from 1 - 12\nint y = year();   // 2003, 2004, 2005, etc.\n\nString s = String.valueOf(d);\ntext(s, 10, 28);\ns = String.valueOf(m);\ntext(s, 10, 56); \ns = String.valueOf(y);\ntext(s, 10, 84);\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "textureWrap()",
    "description": "\nDefines if textures repeat or draw once within a texture map. The two parameters are CLAMP (the default behavior) and REPEAT. This function only works with the P2D and P3D renderers.\n",
    "syntax": "textureWrap(wrap)",
    "returns": "void",
    "examples": ["\nPImage img;\n\nvoid setup() {\n  size(300, 300, P2D);\n  img = loadImage(\"berlin-1.jpg\");\n  textureMode(NORMAL);\n}\n\nvoid draw() {\n  background(0);\n  translate(width/2, height/2);\n  rotate(map(mouseX, 0, width, -PI, PI));\n  if (mousePressed) {\n    textureWrap(REPEAT); \n  } else {\n    textureWrap(CLAMP);\n  }\n  beginShape();\n  texture(img);\n  vertex(-100, -100, 0, 0);\n  vertex(100, -100, 2, 0);\n  vertex(100, 100, 2, 2);\n  vertex(-100, 100, 0, 2);\n  endShape();\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "wrap",
        "description": "int: Either CLAMP (default) or REPEAT"
    }]
}, {
    "name": "lights()",
    "description": "\nSets the default ambient light, directional light, falloff, and specular values. The defaults are ambientLight(128, 128, 128) and directionalLight(128, 128, 128, 0, 0, -1), lightFalloff(1, 0, 0), and lightSpecular(0, 0, 0). Lights need to be included in the draw() to remain persistent in a looping program. Placing them in the setup() of a looping program will cause them to only have an effect the first time through the loop.\n",
    "syntax": "lights()",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nbackground(0);\nnoStroke();\n// Sets the default ambient \n// and directional light\nlights();\ntranslate(20, 50, 0);\nsphere(30);\ntranslate(60, 0, 0);\nsphere(30);\n", "\nvoid setup() {\n  size(100, 100, P3D);\n  background(0);\n  noStroke();\n}\n\nvoid draw() {\n  // Include lights() at the beginning\n  // of draw() to keep them persistent \n  lights();\n  translate(20, 50, 0);\n  sphere(30);\n  translate(60, 0, 0);\n  sphere(30);\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/lights_0.png", "https://www.processing.org/reference/images/lights_1.png"],
    "parameters": []
}, {
    "name": "selectInput()",
    "description": "\nOpens a platform-specific file chooser dialog to select a file for input. After the selection is made, the selected File will be passed to the 'callback' function. If the dialog is closed or canceled, null will be sent to the function, so that the program is not waiting for additional input. The callback is necessary because of how threading works.\n",
    "syntax": "selectInput(prompt, callback)\nselectInput(prompt, callback, file)\nselectInput(prompt, callback, file, callbackObject)\nselectInput(prompt, callbackMethod, file, callbackObject, parent)",
    "returns": "void",
    "examples": ["\nvoid setup() {\n  selectInput(\"Select a file to process:\", \"fileSelected\");\n}\n\nvoid fileSelected(File selection) {\n  if (selection == null) {\n    println(\"Window was closed or the user hit cancel.\");\n  } else {\n    println(\"User selected \" + selection.getAbsolutePath());\n  }\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "prompt",
        "description": "String: message to the user"
    }, {
        "name": "callback",
        "description": "String: name of the method to be called when the selection is made"
    }]
}, {
    "name": "noStroke()",
    "description": "\nDisables drawing the stroke (outline). If both noStroke() and noFill() are called, nothing will be drawn to the screen.\n",
    "syntax": "noStroke()",
    "returns": "void",
    "examples": ["\nnoStroke();\nrect(30, 20, 55, 55);\n"],
    "examples_img": ["https://www.processing.org/reference/images/noStroke_.png"],
    "parameters": []
}, {
    "name": "createImage()",
    "description": "\nCreates a new PImage (the datatype for storing images). This provides a fresh buffer of pixels to play with. Set the size of the buffer with the width and height parameters. The format parameter defines how the pixels are stored. See the PImage reference for more information.\n \nBe sure to include all three parameters, specifying only the width and height (but no format) will produce a strange error.\n \nAdvanced users please note that createImage() should be used instead of the syntax new PImage(). \n",
    "syntax": "createImage(w, h, format)",
    "returns": "PImage",
    "examples": ["\nPImage img = createImage(66, 66, RGB);\nimg.loadPixels();\nfor (int i = 0; i < img.pixels.length; i++) {\n  img.pixels[i] = color(0, 90, 102); \n}\nimg.updatePixels();\nimage(img, 17, 17);\n", "\nPImage img = createImage(66, 66, ARGB);\nimg.loadPixels();\nfor (int i = 0; i < img.pixels.length; i++) {\n  img.pixels[i] = color(0, 90, 102, i % img.width * 2); \n}\nimg.updatePixels();\nimage(img, 17, 17);\nimage(img, 34, 34);\n"],
    "examples_img": ["https://www.processing.org/reference/images/createImage_0.png", "https://www.processing.org/reference/images/createImage_1.png"],
    "parameters": [{
        "name": "w",
        "description": "int: width in pixels"
    }, {
        "name": "h",
        "description": "int: height in pixels"
    }, {
        "name": "format",
        "description": "int: Either RGB, ARGB, ALPHA (grayscale alpha channel)"
    }]
}, {
    "name": "lightSpecular()",
    "description": "\nSets the specular color for lights. Like fill(), it affects only the elements which are created after it in the code. Specular refers to light which bounces off a surface in a preferred direction (rather than bouncing in all directions like a diffuse light) and is used for creating highlights. The specular quality of a light interacts with the specular material qualities set through the specular() and shininess() functions.\n",
    "syntax": "lightSpecular(v1, v2, v3)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nbackground(0);\nnoStroke();\ndirectionalLight(102, 102, 102, 0, 0, -1);\nlightSpecular(204, 204, 204);\ndirectionalLight(102, 102, 102, 0, 1, -1);\nlightSpecular(102, 102, 102);\ntranslate(20, 50, 0);\nspecular(51, 51, 51);\nsphere(30);\ntranslate(60, 0, 0);\nspecular(102, 102, 102);\nsphere(30);\n"],
    "examples_img": ["https://www.processing.org/reference/images/lightSpecular_.png"],
    "parameters": [{
        "name": "v1",
        "description": "float: red or hue value (depending on current color mode)"
    }, {
        "name": "v2",
        "description": "float: green or saturation value (depending on current color mode)"
    }, {
        "name": "v3",
        "description": "float: blue or brightness value (depending on current color mode)"
    }]
}, {
    "name": "atan()",
    "description": "\nThe inverse of tan(), returns the arc tangent of a value. This function expects the values in the range of -Infinity to Infinity (exclusive) and values are returned in the range -PI/2 to PI/2 .\n",
    "syntax": "atan(value)",
    "returns": "float",
    "examples": ["\nfloat a = PI/3;\nfloat t = tan(a);\nfloat at = atan(t);\n// Prints \"1.0471976 : 1.7320509 : 1.0471976\"\nprintln(a + \" : \" + t + \" : \" +  at);\n", "\nfloat a = PI + PI/3.0;\nfloat t = tan(a);\nfloat at = atan(t);\n// Prints \"4.1887903 : 1.7320513 : 1.0471977\"\nprintln(a + \" : \" + t + \" : \" +  at);\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value",
        "description": "float: -Infinity to Infinity (exclusive)"
    }]
}, {
    "name": "rotateY()",
    "description": "\nRotates a shape around the y-axis the amount specified by the angle parameter. Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the radians() function. Objects are always rotated around their relative position to the origin and positive numbers rotate objects in a counterclockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling rotateY(PI/2) and then rotateY(PI/2) is the same as rotateY(PI). If rotateY() is called within the draw(), the transformation is reset when the loop begins again. This function requires using P3D as a third parameter to size() as shown in the examples above. \n",
    "syntax": "rotateY(angle)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\ntranslate(width/2, height/2);\nrotateY(PI/3.0);\nrect(-26, -26, 52, 52);\n", "\nsize(100, 100, P3D);\ntranslate(width/2, height/2);\nrotateY(radians(60));\nrect(-26, -26, 52, 52);\n"],
    "examples_img": ["https://www.processing.org/reference/images/rotateY_0.png", "https://www.processing.org/reference/images/rotateY_1.png"],
    "parameters": [{
        "name": "angle",
        "description": "float: angle of rotation specified in radians"
    }]
}, {
    "name": "pow()",
    "description": "\nFacilitates exponential expressions. The pow() function is an efficient way of multiplying numbers by themselves (or their reciprocals) in large quantities. For example, pow(3, 5) is equivalent to the expression 3*3*3*3*3 and pow(3, -5) is equivalent to 1 / 3*3*3*3*3.\n",
    "syntax": "pow(n, e)",
    "returns": "float",
    "examples": ["\nfloat a = pow( 1, 3);  // Sets 'a' to 1*1*1 = 1\nfloat b = pow( 3, 5);  // Sets 'b' to 3*3*3*3*3 = 243\nfloat c = pow( 3,-5);  // Sets 'c' to 1 / 3*3*3*3*3 = 1 / 243 = .0041\nfloat d = pow(-3, 5);  // Sets 'd' to -3*-3*-3*-3*-3 = -243\n"],
    "examples_img": [],
    "parameters": [{
        "name": "n",
        "description": "float: base of the exponential expression"
    }, {
        "name": "e",
        "description": "float: power by which to raise the base"
    }]
}, {
    "name": "perspective()",
    "description": "\nSets a perspective projection applying foreshortening, making distant objects appear smaller than closer ones. The parameters define a viewing volume with the shape of truncated pyramid. Objects near to the front of the volume appear their actual size, while farther objects appear smaller. This projection simulates the perspective of the world more accurately than orthographic projection. The version of perspective without parameters sets the default perspective and the version with four parameters allows the programmer to set the area precisely. The default values are: perspective(PI/3.0, width/height, cameraZ/10.0, cameraZ*10.0) where cameraZ is ((height/2.0) / tan(PI*60.0/360.0));\n",
    "syntax": "perspective()\nperspective(fovy, aspect, zNear, zFar)",
    "returns": "void",
    "examples": ["\n// Re-creates the default perspective\nsize(100, 100, P3D);\nnoFill();\nfloat fov = PI/3.0;\nfloat cameraZ = (height/2.0) / tan(fov/2.0);\nperspective(fov, float(width)/float(height), \n            cameraZ/10.0, cameraZ*10.0);\ntranslate(50, 50, 0);\nrotateX(-PI/6);\nrotateY(PI/3);\nbox(45);\n"],
    "examples_img": ["https://www.processing.org/reference/images/perspective_.png"],
    "parameters": [{
        "name": "fovy",
        "description": "float: field-of-view angle (in radians) for vertical direction"
    }, {
        "name": "aspect",
        "description": "float: ratio of width to height"
    }, {
        "name": "zNear",
        "description": "float: z-position of nearest clipping plane"
    }, {
        "name": "zFar",
        "description": "float: z-position of farthest clipping plane"
    }]
}, {
    "name": "curveVertex()",
    "description": "\nSpecifies vertex coordinates for curves. This function may only be used between beginShape() and endShape() and only when there is no MODE parameter specified to beginShape(). The first and last points in a series of curveVertex() lines will be used to guide the beginning and end of a the curve. A minimum of four points is required to draw a tiny curve between the second and third points. Adding a fifth point with curveVertex() will draw the curve between the second, third, and fourth points. The curveVertex() function is an implementation of Catmull-Rom splines. Using the 3D version requires rendering with P3D (see the Environment reference for more information).\n",
    "syntax": "curveVertex(x, y)\ncurveVertex(x, y, z)",
    "returns": "void",
    "examples": ["\nnoFill();\nbeginShape();\ncurveVertex(84,  91);\ncurveVertex(84,  91);\ncurveVertex(68,  19);\ncurveVertex(21,  17);\ncurveVertex(32, 100);\ncurveVertex(32, 100);\nendShape();\n"],
    "examples_img": ["https://www.processing.org/reference/images/curveVertex_.png"],
    "parameters": [{
        "name": "x",
        "description": "float: the x-coordinate of the vertex"
    }, {
        "name": "y",
        "description": "float: the y-coordinate of the vertex"
    }, {
        "name": "z",
        "description": "float: the z-coordinate of the vertex"
    }]
}, {
    "name": "createWriter()",
    "description": "\nCreates a new file in the sketch folder, and a PrintWriter object to write to it. For the file to be made correctly, it should be flushed and must be closed with its flush() and close() methods (see above example). \n \nStarting with Processing release 0134, all files loaded and saved by the Processing API use UTF-8 encoding. In previous releases, the default encoding for your platform was used, which causes problems when files are moved to other platforms.\n",
    "syntax": "createWriter(filename)",
    "returns": "PrintWriter",
    "examples": ["\nPrintWriter output;\n\nvoid setup() {\n  // Create a new file in the sketch directory\n  output = createWriter(\"positions.txt\"); \n}\n\nvoid draw() {\n  point(mouseX, mouseY);\n  output.println(mouseX + \"t\" + mouseY); // Write the coordinate to the file\n}\n\nvoid keyPressed() {\n  output.flush(); // Writes the remaining data to the file\n  output.close(); // Finishes the file\n  exit(); // Stops the program\n}\n\n"],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: name of the file to be created"
    }]
}, {
    "name": "lightFalloff()",
    "description": "\nSets the falloff rates for point lights, spot lights, and ambient lights. Like fill(), it affects only the elements which are created after it in the code. The default value is lightFalloff(1.0, 0.0, 0.0), and the parameters are used to calculate the falloff with the following equation:\n\nd = distance from light position to vertex position\nfalloff = 1 / (CONSTANT + d * LINEAR + (d*d) * QUADRATIC)\n\nThinking about an ambient light with a falloff can be tricky. If you want a region of your scene to be lit ambiently with one color and another region to be lit ambiently with another color, you could use an ambient light with location and falloff. You can think of it as a point light that doesn't care which direction a surface is facing.\n",
    "syntax": "lightFalloff(constant, linear, quadratic)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nnoStroke();\nbackground(0);\nlightFalloff(1.0, 0.001, 0.0);\npointLight(150, 250, 150, 50, 50, 50);\nbeginShape();\nvertex(0, 0, 0);\nvertex(100, 0, -100);\nvertex(100, 100, -100);\nvertex(0, 100, 0);\nendShape(CLOSE);\n"],
    "examples_img": ["https://www.processing.org/reference/images/lightFalloff_.png"],
    "parameters": [{
        "name": "constant",
        "description": "float: constant value or determining falloff"
    }, {
        "name": "linear",
        "description": "float: linear value for determining falloff"
    }, {
        "name": "quadratic",
        "description": "float: quadratic value for determining falloff"
    }]
}, {
    "name": "lerpColor()",
    "description": "\nCalculates a color or colors between two color at a specific increment. The amt parameter is the amount to interpolate between the two values where 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is halfway in between, etc. \n\nAn amount below 0 will be treated as 0. Likewise, amounts above 1 will be capped at 1. This is different from the behavior of lerp(), but necessary because otherwise numbers outside the range will produce strange and unexpected colors.\n",
    "syntax": "lerpColor(c1, c2, amt)",
    "returns": "int",
    "examples": ["\nstroke(255);\nbackground(51);\ncolor from = color(204, 102, 0);\ncolor to = color(0, 102, 153);\ncolor interA = lerpColor(from, to, .33);\ncolor interB = lerpColor(from, to, .66);\nfill(from);\nrect(10, 20, 20, 60);\nfill(interA);\nrect(30, 20, 20, 60);\nfill(interB);\nrect(50, 20, 20, 60);\nfill(to);\nrect(70, 20, 20, 60);\n"],
    "examples_img": ["https://www.processing.org/reference/images/lerpColor_.png"],
    "parameters": [{
        "name": "c1",
        "description": "int: interpolate from this color"
    }, {
        "name": "c2",
        "description": "int: interpolate to this color"
    }, {
        "name": "amt",
        "description": "float: between 0.0 and 1.0"
    }]
}, {
    "name": "noLights()",
    "description": "\nDisable all lighting. Lighting is turned off by default and enabled with the lights() function. This function can be used to disable lighting so that 2D geometry (which does not require lighting) can be drawn after a set of lighted 3D geometry.\n",
    "syntax": "noLights()",
    "returns": "void",
    "examples": [],
    "examples_img": [],
    "parameters": []
}, {
    "name": "modelX()",
    "description": "\nReturns the three-dimensional X, Y, Z position in model space. This returns the X value for a given coordinate based on the current set of transformations (scale, rotate, translate, etc.) The X value can be used to place an object in space relative to the location of the original point once the transformations are no longer in use. \n \nIn the example, the modelX(), modelY(), and modelZ() functions record the location of a box in space after being placed using a series of translate and rotate commands. After popMatrix() is called, those transformations no longer apply, but the (x, y, z) coordinate returned by the model functions is used to place another box in the same location.\n",
    "syntax": "modelX(x, y, z)",
    "returns": "float",
    "examples": ["\nvoid setup() {\n  size(500, 500, P3D);\n  noFill();\n}\n\nvoid draw() {\n  background(0);\n \n  pushMatrix();\n  // start at the middle of the screen\n  translate(width/2, height/2, -200);     \n  // some random rotation to make things interesting\n  rotateY(1.0); //yrot);\n  rotateZ(2.0); //zrot);\n  // rotate in X a little more each frame\n  rotateX(frameCount / 100.0);\n  // offset from center\n  translate(0, 150, 0);\n \n  // draw a white box outline at (0, 0, 0)\n  stroke(255);\n  box(50);\n \n  // the box was drawn at (0, 0, 0), store that location\n  float x = modelX(0, 0, 0);\n  float y = modelY(0, 0, 0);\n  float z = modelZ(0, 0, 0);\n  // clear out all the transformations\n  popMatrix();\n\n  // draw another box at the same (x, y, z) coordinate as the other\n  pushMatrix();\n  translate(x, y, z);\n  stroke(255, 0, 0);\n  box(50);\n  popMatrix();\n} \n"],
    "examples_img": [],
    "parameters": [{
        "name": "x",
        "description": "float: 3D x-coordinate to be mapped"
    }, {
        "name": "y",
        "description": "float: 3D y-coordinate to be mapped"
    }, {
        "name": "z",
        "description": "float: 3D z-coordinate to be mapped"
    }]
}, {
    "name": "millis()",
    "description": "\nReturns the number of milliseconds (thousandths of a second) since starting the program. This information is often used for timing events and animation sequences. \n",
    "syntax": "millis()",
    "returns": "int",
    "examples": ["\nvoid draw() {\n  int m = millis();\n  noStroke();\n  fill(m % 255);\n  rect(25, 25, 50, 50);\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "blue()",
    "description": "\nExtracts the blue value from a color, scaled to match current colorMode(). The value is always returned as a float, so be careful not to assign it to an int value.\n\nThe blue() function is easy to use and understand, but it is slower than a technique called bit masking. When working in colorMode(RGB, 255), you can acheive the same results as blue() but with greater speed by using a bit mask to remove the other color components. For example, the following two lines of code are equivalent means of getting the blue value of the color value c:\n\nfloat b1 = blue(c);   // Simpler, but slower to calculate\nfloat b2 = c & 0xFF;  // Very fast to calculate\n",
    "syntax": "blue(rgb)",
    "returns": "float",
    "examples": ["\ncolor c = color(175, 100, 220);  // Define color 'c'\nfill(c);  // Use color variable 'c' as fill color\nrect(15, 20, 35, 60);  // Draw left rectangle\n\nfloat blueValue = blue(c);  // Get blue in 'c'\nprintln(blueValue);  // Prints \"220.0\"\nfill(0, 0, blueValue);  // Use 'blueValue' in new fill\nrect(50, 20, 35, 60);  // Draw right rectangle\n"],
    "examples_img": ["https://www.processing.org/reference/images/blue_.png"],
    "parameters": [{
        "name": "rgb",
        "description": "int: any value of the color datatype"
    }]
}, {
    "name": "box()",
    "description": "\nA box is an extruded rectangle. A box with equal dimensions on all sides is a cube.\n",
    "syntax": "box(size)\nbox(w, h, d)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\ntranslate(58, 48, 0); \nrotateY(0.5);\nnoFill();\nbox(40);\n", "\nsize(100, 100, P3D);\ntranslate(58, 48, 0); \nrotateY(0.5);\nnoFill();\nbox(40, 20, 50);\n"],
    "examples_img": ["https://www.processing.org/reference/images/box_0.png", "https://www.processing.org/reference/images/box_1.png"],
    "parameters": [{
        "name": "size",
        "description": "float: dimension of the box in all dimensions (creates a cube)"
    }, {
        "name": "w",
        "description": "float: dimension of the box in the x-dimension"
    }, {
        "name": "h",
        "description": "float: dimension of the box in the y-dimension"
    }, {
        "name": "d",
        "description": "float: dimension of the box in the z-dimension"
    }]
}, {
    "name": "rotateZ()",
    "description": "\nRotates a shape around the z-axis the amount specified by the angle parameter. Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the radians() function. Objects are always rotated around their relative position to the origin and positive numbers rotate objects in a counterclockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling rotateZ(PI/2) and then rotateZ(PI/2) is the same as rotateZ(PI). If rotateZ() is called within the draw(), the transformation is reset when the loop begins again. This function requires using P3D as a third parameter to size() as shown in the examples above. \n",
    "syntax": "rotateZ(angle)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\ntranslate(width/2, height/2);\nrotateZ(PI/3.0);\nrect(-26, -26, 52, 52);\n", "\nsize(100, 100, P3D);\ntranslate(width/2, height/2);\nrotateZ(radians(60));\nrect(-26, -26, 52, 52);\n"],
    "examples_img": ["https://www.processing.org/reference/images/rotateZ_0.png", "https://www.processing.org/reference/images/rotateZ_1.png"],
    "parameters": [{
        "name": "angle",
        "description": "float: angle of rotation specified in radians"
    }]
}, {
    "name": "ambientLight()",
    "description": "\nAdds an ambient light. Ambient light doesn't come from a specific direction, the rays have light have bounced around so much that objects are evenly lit from all sides. Ambient lights are almost always used in combination with other types of lights. Lights need to be included in the draw() to remain persistent in a looping program. Placing them in the setup() of a looping program will cause them to only have an effect the first time through the loop. The v1, v2, and v3 parameters are interpreted as either RGB or HSB values, depending on the current color mode.\n",
    "syntax": "ambientLight(v1, v2, v3)\nambientLight(v1, v2, v3, x, y, z)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nbackground(0);\nnoStroke();\n// The spheres are white by default so\n// the ambient light changes their color\nambientLight(51, 102, 126);\ntranslate(20, 50, 0);\nsphere(30);\ntranslate(60, 0, 0);\nsphere(30);\n", "\nsize(100, 100, P3D);\nbackground(0);\nnoStroke();\ndirectionalLight(126, 126, 126, 0, 0, -1);\nambientLight(102, 102, 102);\ntranslate(32, 50, 0);\nrotateY(PI/5);\nbox(40);\ntranslate(60, 0, 0);\nsphere(30);\n"],
    "examples_img": ["https://www.processing.org/reference/images/ambientLight_0.png", "https://www.processing.org/reference/images/ambientLight_1.png"],
    "parameters": [{
        "name": "v1",
        "description": "float: red or hue value (depending on current color mode)"
    }, {
        "name": "v2",
        "description": "float: green or saturation value (depending on current color mode)"
    }, {
        "name": "v3",
        "description": "float: blue or brightness value (depending on current color mode)"
    }, {
        "name": "x",
        "description": "float: x-coordinate of the light"
    }, {
        "name": "y",
        "description": "float: y-coordinate of the light"
    }, {
        "name": "z",
        "description": "float: z-coordinate of the light"
    }]
}, {
    "name": "screenZ()",
    "description": "\nTakes a three-dimensional X, Y, Z position and returns the Z value for where it will appear on a (two-dimensional) screen.\n",
    "syntax": "screenZ(x, y, z)",
    "returns": "float",
    "examples": ["\nComing soon...\n\n"],
    "examples_img": [],
    "parameters": [{
        "name": "x",
        "description": "float: 3D x-coordinate to be mapped"
    }, {
        "name": "y",
        "description": "float: 3D y-coordinate to be mapped"
    }, {
        "name": "z",
        "description": "float: 3D z-coordinate to be mapped"
    }]
}, {
    "name": "saveJSONObject()",
    "description": "\nWrites the contents of a JSONObject object to a file. By default, this file is saved to the sketch's folder. This folder is opened by selecting \"Show Sketch Folder\" from the \"Sketch\" menu.\n\nAlternatively, the file can be saved to any location on the computer by using an absolute path (something that starts with / on Unix and Linux, or a drive letter on Windows).\n\nAll files loaded and saved by the Processing API use UTF-8 encoding.\n",
    "syntax": "saveJSONObject(json, filename)\nsaveJSONObject(json, filename, options)",
    "returns": "boolean",
    "examples": ["\nJSONObject json;\n\nvoid setup() {\n\n  json = new JSONObject();\n\n  json.setInt(\"id\", 0);\n  json.setString(\"species\", \"Panthera leo\");\n  json.setString(\"name\", \"Lion\");\n\n  saveJSONObject(json, \"data/new.json\");\n}\n\n// Sketch saves the following to a file called \"new.json\":\n// {\n//   \"id\": 0,\n//   \"species\": \"Panthera leo\",\n//   \"name\": \"Lion\"\n// }\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "directionalLight()",
    "description": "\nAdds a directional light. Directional light comes from one direction: it is stronger when hitting a surface squarely, and weaker if it hits at a gentle angle. After hitting a surface, directional light scatters in all directions. Lights need to be included in the draw() to remain persistent in a looping program. Placing them in the setup() of a looping program will cause them to only have an effect the first time through the loop. The v1, v2, and v3 parameters are interpreted as either RGB or HSB values, depending on the current color mode. The nx, ny, and nz parameters specify the direction the light is facing. For example, setting ny to -1 will cause the geometry to be lit from below (since the light would be facing directly upward).\n",
    "syntax": "directionalLight(v1, v2, v3, nx, ny, nz)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nbackground(0);\nnoStroke();\ndirectionalLight(51, 102, 126, -1, 0, 0);\ntranslate(20, 50, 0);\nsphere(30);\n", "\nsize(100, 100, P3D);\nbackground(0);\nnoStroke();\ndirectionalLight(51, 102, 126, 0, -1, 0);\ntranslate(80, 50, 0);\nsphere(30);\n"],
    "examples_img": ["https://www.processing.org/reference/images/directionalLight_0.png", "https://www.processing.org/reference/images/directionalLight_1.png"],
    "parameters": [{
        "name": "v1",
        "description": "float: red or hue value (depending on current color mode)"
    }, {
        "name": "v2",
        "description": "float: green or saturation value (depending on current color mode)"
    }, {
        "name": "v3",
        "description": "float: blue or brightness value (depending on current color mode)"
    }, {
        "name": "nx",
        "description": "float: direction along the x-axis"
    }, {
        "name": "ny",
        "description": "float: direction along the y-axis"
    }, {
        "name": "nz",
        "description": "float: direction along the z-axis"
    }]
}, {
    "name": "QUARTER_PI",
    "description": "\nQUARTER_PI is a mathematical constant with the value 0.7853982. It is one quarter the ratio of the circumference of a circle to its diameter. It is useful in combination with the trigonometric functions sin() and cos(). \n",
    "syntax": "",
    "returns": "",
    "examples": ["\nfloat x = width/2;\nfloat y = height/2;\nfloat d = width * 0.8;\narc(x, y, d, d, 0, QUARTER_PI);\narc(x, y, d-20, d-20, 0, HALF_PI);\narc(x, y, d-40, d-40, 0, PI);\narc(x, y, d-60, d-60, 0, TWO_PI);\n"],
    "examples_img": ["https://www.processing.org/reference/images/QUARTER_PI.png"],
    "parameters": []
}, {
    "name": "normal()",
    "description": "\nSets the current normal vector. Used for drawing three dimensional shapes and surfaces, normal() specifies a vector perpendicular to a shape's surface which, in turn, determines how lighting affects it. Processing attempts to automatically assign normals to shapes, but since that's imperfect, this is a better option when you want more control. This function is identical to glNormal3f() in OpenGL.\n",
    "syntax": "normal(nx, ny, nz)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nnoStroke();\nbackground(0);\npointLight(150, 250, 150, 10, 30, 50);\nbeginShape();\nnormal(0, 0, 1);\nvertex(20, 20, -10);\nvertex(80, 20, 10);\nvertex(80, 80, -10);\nvertex(20, 80, 10);\nendShape(CLOSE);\n"],
    "examples_img": ["https://www.processing.org/reference/images/normal_.png"],
    "parameters": [{
        "name": "nx",
        "description": "float: x direction"
    }, {
        "name": "ny",
        "description": "float: y direction"
    }, {
        "name": "nz",
        "description": "float: z direction"
    }]
}, {
    "name": "saveTable()",
    "description": "\nWrites the contents of a Table object to a file. By default, this file is saved to the sketch's folder. This folder is opened by selecting \"Show Sketch Folder\" from the \"Sketch\" menu.\n\nAlternatively, the file can be saved to any location on the computer by using an absolute path (something that starts with / on Unix and Linux, or a drive letter on Windows).\n\nAll files loaded and saved by the Processing API use UTF-8 encoding.\n",
    "syntax": "saveTable(table, filename)\nsaveTable(table, filename, options)",
    "returns": "boolean",
    "examples": ["\nTable table;\n\nvoid setup() {\n\n  table = new Table();\n  \n  table.addColumn(\"id\");\n  table.addColumn(\"species\");\n  table.addColumn(\"name\");\n  \n  TableRow newRow = table.addRow();\n  newRow.setInt(\"id\", table.getRowCount() - 1);\n  newRow.setString(\"species\", \"Panthera leo\");\n  newRow.setString(\"name\", \"Lion\");\n  \n  saveTable(table, \"data/new.csv\");\n}\n\n// Sketch saves the following to a file called \"new.csv\":\n// id,species,name\n// 0,Panthera leo,Lion\n"],
    "examples_img": [],
    "parameters": [{
        "name": "table",
        "description": "Table: the Table object to save to a file"
    }, {
        "name": "filename",
        "description": "String: the filename to which the Table should be saved"
    }, {
        "name": "options",
        "description": "String: can be one of \"tsv\", \"csv\", \"bin\", or \"html\""
    }]
}, {
    "name": "screenX()",
    "description": "\nTakes a three-dimensional X, Y, Z position and returns the X value for where it will appear on a (two-dimensional) screen.\n",
    "syntax": "screenX(x, y)\nscreenX(x, y, z)",
    "returns": "float",
    "examples": ["\nvoid setup() {\n  size(100, 100, P3D);\n}\n\nvoid draw() {\n  background(204);\n  \n  float x = mouseX;\n  float y = mouseY;\n  float z = -100;\n  \n  // Draw \"X\" at z = -100\n  stroke(255);\n  line(x-10, y-10, z, x+10, y+10, z); \n  line(x+10, y-10, z, x-10, y+10, z); \n  \n  // Draw gray line at z = 0 and same \n  // x value. Notice the parallax\n  stroke(102);\n  line(x, 0, 0, x, height, 0);\n  \n  // Draw black line at z = 0 to match \n  // the x value element drawn at z = -100 \n  stroke(0);\n  float theX = screenX(x, y, z);\n  line(theX, 0, 0, theX, height, 0);    \n} \n"],
    "examples_img": [],
    "parameters": [{
        "name": "x",
        "description": "float: 3D x-coordinate to be mapped"
    }, {
        "name": "y",
        "description": "float: 3D y-coordinate to be mapped"
    }, {
        "name": "z",
        "description": "float: 3D z-coordinate to be mapped"
    }]
}, {
    "name": "month()",
    "description": "\nProcessing communicates with the clock on your computer. The month() function returns the current month as a value from 1 - 12.\n",
    "syntax": "month()",
    "returns": "int",
    "examples": ["\nint d = day();    // Values from 1 - 31\nint m = month();  // Values from 1 - 12\nint y = year();   // 2003, 2004, 2005, etc.\n\nString s = String.valueOf(d);\ntext(s, 10, 28);\ns = String.valueOf(m);\ntext(s, 10, 56); \ns = String.valueOf(y);\ntext(s, 10, 84);\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "filter()",
    "description": "\nFilters the display window using a preset filter or with a custom shader. Using a shader with filter() is much faster than without. Shaders require the P2D or P3D renderer in size().\n\nThe presets options are:\n\nTHRESHOLD\nConverts the image to black and white pixels depending if they are above or below the threshold defined by the level parameter. The parameter must be between 0.0 (black) and 1.0 (white). If no level is specified, 0.5 is used.\n\nGRAY\nConverts any colors in the image to grayscale equivalents. No parameter is used.\n\nOPAQUE\nSets the alpha channel to entirely opaque. No parameter is used.\n\nINVERT\nSets each pixel to its inverse value. No parameter is used.\n\nPOSTERIZE\nLimits each channel of the image to the number of colors specified as the parameter. The parameter can be set to values between 2 and 255, but results are most noticeable in the lower ranges.\n\nBLUR\nExecutes a Guassian blur with the level parameter specifying the extent of the blurring. If no parameter is used, the blur is equivalent to Guassian blur of radius 1. Larger values increase the blur.\n\nERODE\nReduces the light areas. No parameter is used.\n\nDILATE\nIncreases the light areas. No parameter is used.\n",
    "syntax": "filter(shader)\nfilter(kind)\nfilter(kind, param)",
    "returns": "void",
    "examples": ["\nPImage img;\nimg = loadImage(\"apples.jpg\");\nimage(img, 0, 0);\nfilter(THRESHOLD);\n", "\nPImage img;\nimg = loadImage(\"apples.jpg\");\nimage(img, 0, 0);\nfilter(GRAY);\n", "\nPImage img;\nimg = loadImage(\"apples.jpg\");\nimage(img, 0, 0);\nfilter(INVERT);\n", "\nPImage img;\nimg = loadImage(\"apples.jpg\");\nimage(img, 0, 0);\nfilter(POSTERIZE, 4);\n", "\nPImage img;\nimg = loadImage(\"apples.jpg\");\nimage(img, 0, 0);\nfilter(BLUR, 6);\n", "\nPImage img;\nimg = loadImage(\"apples.jpg\");\nimage(img, 0, 0);\nfilter(ERODE);\n", "\nPImage img;\nimg = loadImage(\"apples.jpg\");\nimage(img, 0, 0);\nfilter(DILATE);\n", "\nPShader blur;\nPImage img;\n\nvoid setup() {\n  size(100, 100, P2D);\n  blur = loadShader(\"blur.glsl\");\n  img = loadImage(\"apples.jpg\");\n  image(img, 0, 0); \n}\n\nvoid draw() {\n  filter(blur); // Blurs more each time through draw()\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/filter_0_threshold.png", "https://www.processing.org/reference/images/filter_1_gray.png", "https://www.processing.org/reference/images/filter_2_invert.png", "https://www.processing.org/reference/images/filter_3_posterize.png", "https://www.processing.org/reference/images/filter_4_blur.png", "https://www.processing.org/reference/images/filter_5_erode.png", "https://www.processing.org/reference/images/filter_6_dilate.png", "https://www.processing.org/reference/images/filter_4_blur.png"],
    "parameters": [{
        "name": "shader",
        "description": "PShader: the fragment shader to apply"
    }, {
        "name": "kind",
        "description": "int: Either THRESHOLD, GRAY, OPAQUE, INVERT, POSTERIZE, BLUR, ERODE, or DILATE"
    }, {
        "name": "param",
        "description": "float: unique for each, see above"
    }]
}, {
    "name": "PImage",
    "description": "\nDatatype for storing images. Processing can display .gif, .jpg, .tga, and .png images. Images may be displayed in 2D and 3D space. Before an image is used, it must be loaded with the loadImage() function. The PImage class contains fields for the width and height of the image, as well as an array called pixels[] that contains the values for every pixel in the image. The methods described below allow easy access to the image's pixels and alpha channel and simplify the process of compositing.\n\nBefore using the pixels[] array, be sure to use the loadPixels() method on the image to make sure that the pixel data is properly loaded.\n\nTo create a new image, use the createImage() function. Do not use the syntax new PImage(). \n",
    "syntax": "",
    "returns": "",
    "examples": ["\nPImage photo;\n\nvoid setup() {\n  size(100, 100);\n  photo = loadImage(\"laDefense.jpg\");\n}\n\nvoid draw() {\n  image(photo, 0, 0);\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/PImage.png"],
    "parameters": []
}, {
    "name": "saturation()",
    "description": "\nExtracts the saturation value from a color.\n",
    "syntax": "saturation(rgb)",
    "returns": "float",
    "examples": ["\nnoStroke();\ncolorMode(HSB, 255);\ncolor c = color(0, 126, 255);\nfill(c);\nrect(15, 20, 35, 60);\nfloat value = saturation(c);  // Sets 'value' to 126\nfill(value);\nrect(50, 20, 35, 60);\n"],
    "examples_img": ["https://www.processing.org/reference/images/saturation_.png"],
    "parameters": [{
        "name": "rgb",
        "description": "int: any value of the color datatype"
    }]
}, {
    "name": "translate()",
    "description": "\nSpecifies an amount to displace objects within the display window. The x parameter specifies left/right translation, the y parameter specifies up/down translation, and the z parameter specifies translations toward/away from the screen. Using this function with the z parameter requires using P3D as a parameter in combination with size as shown in the above example.\n\nTransformations are cumulative and apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling translate(50, 0) and then translate(20, 0) is the same as translate(70, 0). If translate() is called within draw(), the transformation is reset when the loop begins again. This function can be further controlled by using pushMatrix() and popMatrix().\n",
    "syntax": "translate(x, y)\ntranslate(x, y, z)",
    "returns": "void",
    "examples": ["\ntranslate(30, 20);\nrect(0, 0, 55, 55);\n", "\n// Translating in 3D requires P3D\n// as the parameter to size()\nsize(100, 100, P3D);\n// Translate 30 across, 20 down, and\n// 50 back, or \"away\" from the screen.\ntranslate(30, 20, -50);\nrect(0, 0, 55, 55);\n", "\nrect(0, 0, 55, 55);  // Draw rect at original 0,0\ntranslate(30, 20);\nrect(0, 0, 55, 55);  // Draw rect at new 0,0\ntranslate(14, 14);\nrect(0, 0, 55, 55);  // Draw rect at new 0,0\n"],
    "examples_img": ["https://www.processing.org/reference/images/translate_0.png", "https://www.processing.org/reference/images/translate_1.png", "https://www.processing.org/reference/images/translate_2.png"],
    "parameters": [{
        "name": "x",
        "description": "float: left/right translation"
    }, {
        "name": "y",
        "description": "float: up/down translation"
    }, {
        "name": "z",
        "description": "float: forward/backward translation"
    }]
}, {
    "name": "shearY()",
    "description": "\nShears a shape around the y-axis the amount specified by the angle parameter. Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the radians() function. Objects are always sheared around their relative position to the origin and positive numbers shear objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling shearY(PI/2) and then shearY(PI/2) is the same as shearY(PI). If shearY() is called within the draw(), the transformation is reset when the loop begins again.\n \nTechnically, shearY() multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by the pushMatrix() and popMatrix() functions.\n",
    "syntax": "shearY(angle)",
    "returns": "void",
    "examples": ["\nsize(100, 100);\ntranslate(width/4, height/4);\nshearY(PI/4.0);\nrect(0, 0, 30, 30);\n"],
    "examples_img": ["https://www.processing.org/reference/images/shearY_.png"],
    "parameters": [{
        "name": "angle",
        "description": "float: angle of shear specified in radians"
    }]
}, {
    "name": "colorMode()",
    "description": "\nChanges the way Processing interprets color data. By default, the parameters for fill(), stroke(), background(), and color() are defined by values between 0 and 255 using the RGB color model. The colorMode() function is used to change the numerical range used for specifying colors and to switch color systems. For example, calling colorMode(RGB, 1.0) will specify that values are specified between 0 and 1. The limits for defining colors are altered by setting the parameters max, max1, max2, max3, and maxA. \n",
    "syntax": "colorMode(mode)\ncolorMode(mode, max)\ncolorMode(mode, max1, max2, max3)\ncolorMode(mode, max1, max2, max3, maxA)",
    "returns": "void",
    "examples": ["\nnoStroke();\ncolorMode(RGB, 100);\nfor (int i = 0; i < 100; i++) {\n  for (int j = 0; j < 100; j++) {\n    stroke(i, j, 0);\n    point(i, j);\n  }\n}\n", "\nnoStroke();\ncolorMode(HSB, 100);\nfor (int i = 0; i < 100; i++) {\n  for (int j = 0; j < 100; j++) {\n    stroke(i, j, 100);\n    point(i, j);\n  }\n}\n", "\n// If the color is defined here, it won't be \n// affected by the colorMode() in setup(). \n// Instead, just declare the variable here and \n// assign the value after the colorMode() in setup()\n//color bg = color(180, 50, 50);  // No\ncolor bg;  // Yes, but assign it in setup()\n\nvoid setup() {\n  size(100, 100);\n  colorMode(HSB, 360, 100, 100);\n  bg = color(180, 50, 50);\n}\n\nvoid draw() {\n  background(bg);\t\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/colorMode_0.png", "https://www.processing.org/reference/images/colorMode_1.png", "https://www.processing.org/reference/images/colorMode_2.png"],
    "parameters": [{
        "name": "mode",
        "description": "int: Either RGB or HSB, corresponding to Red/Green/Blue and Hue/Saturation/Brightness"
    }, {
        "name": "max",
        "description": "float: range for all color elements"
    }, {
        "name": "max1",
        "description": "float: range for the red or hue depending on the current color mode"
    }, {
        "name": "max2",
        "description": "float: range for the green or saturation depending on the current color mode"
    }, {
        "name": "max3",
        "description": "float: range for the blue or brightness depending on the current color mode"
    }, {
        "name": "maxA",
        "description": "float: range for the alpha"
    }]
}, {
    "name": "shininess()",
    "description": "\nSets the amount of gloss in the surface of shapes. Used in combination with ambient(), specular(), and emissive() in setting the material properties of shapes.\n",
    "syntax": "shininess(shine)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D); \nbackground(0);\nnoStroke();\nbackground(0); \nfill(0, 51, 102); \nambientLight(102, 102, 102);\nlightSpecular(204, 204, 204);\ndirectionalLight(102, 102, 102, 0, 0, -1);\nspecular(255, 255, 255);\ntranslate(30, 50, 0);\nshininess(1.0);\nsphere(20);  // Left sphere\ntranslate(40, 0, 0); \nshininess(5.0); \nsphere(20);  // Right sphere\n"],
    "examples_img": ["https://www.processing.org/reference/images/shininess_.png"],
    "parameters": [{
        "name": "shine",
        "description": "float: degree of shininess"
    }]
}, {
    "name": "smooth()",
    "description": "\nDraws all geometry with smooth (anti-aliased) edges. smooth() will also improve image quality of resized images. Note that smooth() is active by default; noSmooth() can be used to disable smoothing of geometry, images, and fonts.\n\nThe level parameter increases the level of smoothness with the P2D and P3D renderers. This is the level of over sampling applied to the graphics buffer. The value \"2\" will double the rendering size before scaling it down to the display size. This is called \"2x anti-aliasing.\" The value 4 is used for 4x anti-aliasing and 8 is specified for 8x anti-aliasing. If level is set to 0, it will disable all smoothing; it's the equivalent of the function noSmooth(). The maximum anti-aliasing level is determined by the hardware of the machine that is running the software.\n\nWith the default renderer, smooth(2) is bilinear and smooth(4) is bicubic. Nothing implemented on Android 2D.\n",
    "syntax": "smooth()\nsmooth(level)",
    "returns": "void",
    "examples": ["\nbackground(0);\nnoStroke();\nsmooth();\nellipse(30, 48, 36, 36);\nnoSmooth();\nellipse(70, 48, 36, 36);\n"],
    "examples_img": ["https://www.processing.org/reference/images/smooth_.png"],
    "parameters": [{
        "name": "level",
        "description": "int: either 2, 4, or 8"
    }]
}, {
    "name": "imageMode()",
    "description": "\nModifies the location from which images are drawn by changing the way in which parameters given to image() are intepreted.\n\nThe default mode is imageMode(CORNER), which interprets the second and third parameters of image() as the upper-left corner of the image. If two additional parameters are specified, they are used to set the image's width and height.\n\nimageMode(CORNERS) interprets the second and third parameters of image() as the  location of one corner, and the fourth and fifth parameters as the opposite corner.\n\nimageMode(CENTER) interprets the second and third parameters of image() as the image's center point. If two additional parameters are specified, they are used to set the image's width and height.\n\nThe parameter must be written in ALL CAPS because Processing is a case-sensitive language.\n",
    "syntax": "imageMode(mode)",
    "returns": "void",
    "examples": ["\nPImage img;\n\nvoid setup() {\n  img = loadImage(\"laDefense.jpg\");\n}\n\nvoid draw() {\n  imageMode(CORNER);\n  image(img, 10, 10, 50, 50);  // Draw image using CORNER mode\n}\n", "\nPImage img;\n\nvoid setup() {\n  img = loadImage(\"laDefense.jpg\");\n}\n\nvoid draw() {\n  imageMode(CORNERS);\n  image(img, 10, 10, 90, 40);  // Draw image using CORNERS mode\n}\n", "\nPImage img;\n\nvoid setup() {\n  img = loadImage(\"laDefense.jpg\");\n}\n\nvoid draw() {\n  imageMode(CENTER);\n  image(img, 50, 50, 80, 80);  // Draw image using CENTER mode\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/imageMode_0.png", "https://www.processing.org/reference/images/imageMode_1.png", "https://www.processing.org/reference/images/imageMode_2.png"],
    "parameters": [{
        "name": "mode",
        "description": "int: either CORNER, CORNERS, or CENTER"
    }]
}, {
    "name": "max()",
    "description": "\nDetermines the largest value in a sequence of numbers, and then returns that value. max() accepts either two or three float or int values as parameters, or an array of any length.\n",
    "syntax": "max(a, b)\nmax(a, b, c)\nmax(list)",
    "returns": "int or float",
    "examples": ["\nint a = max(5, 9);            // Sets 'a' to 9\nint b = max(-4, -12);         // Sets 'b' to -4\nfloat c = max(12.3, 230.24);  // Sets 'c' to 230.24\n", "\nint[] values = { 9, -4, 362, 21 };  // Create an array of ints\nint d = max(values);                // Sets 'd' to 362\n"],
    "examples_img": [],
    "parameters": [{
        "name": "a",
        "description": "float, or int: first number to compare"
    }, {
        "name": "b",
        "description": "float, or int: second number to compare"
    }, {
        "name": "c",
        "description": "float, or int: third number to compare"
    }, {
        "name": "list",
        "description": "float[], or int[]: array of numbers to compare"
    }]
}, {
    "name": "norm()",
    "description": "\nNormalizes a number from another range into a value between 0 and 1. Identical to map(value, low, high, 0, 1).\n\nNumbers outside of the range are not clamped to 0 and 1, because out-of-range values are often intentional and useful.  (See the second example above.)\n",
    "syntax": "norm(value, start, stop)",
    "returns": "float",
    "examples": ["\nfloat value = 20;\nfloat n = norm(value, 0, 50);\nprintln(n);  // Prints \"0.4\"\n", "\nfloat value = -10;\nfloat n = norm(value, 0, 100);\nprintln(n);  // Prints \"-0.1\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value",
        "description": "float: the incoming value to be converted"
    }, {
        "name": "start",
        "description": "float: lower bound of the value's current range"
    }, {
        "name": "stop",
        "description": "float: upper bound of the value's current range"
    }]
}, {
    "name": "beginCamera()",
    "description": "\nThe beginCamera() and endCamera() functions enable advanced customization of the camera space. The functions are useful if you want to more control over camera movement, however for most users, the camera() function will be sufficient.The camera functions will replace any transformations (such as rotate() or translate()) that occur before them in draw(), but they will not automatically replace the camera transform itself. For this reason, camera functions should be placed at the beginning of draw() (so that transformations happen afterwards), and the camera() function can be used after beginCamera() if you want to reset the camera before applying transformations.This function sets the matrix mode to the camera matrix so calls such as translate(), rotate(), applyMatrix() and resetMatrix() affect the camera. beginCamera() should always be used with a following endCamera() and pairs of beginCamera() and endCamera() cannot be nested.\n",
    "syntax": "beginCamera()",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nnoFill();\n\nbeginCamera();\ncamera();\nrotateX(-PI/6);\nendCamera();\n\ntranslate(50, 50, 0);\nrotateY(PI/3);\nbox(45);\n"],
    "examples_img": ["https://www.processing.org/reference/images/beginCamera_.png"],
    "parameters": []
}, {
    "name": "noFill()",
    "description": "\nDisables filling geometry. If both noStroke() and noFill() are called, nothing will be drawn to the screen.\n",
    "syntax": "noFill()",
    "returns": "void",
    "examples": ["\nrect(15, 10, 55, 55);\nnoFill();\nrect(30, 20, 55, 55);\n"],
    "examples_img": ["https://www.processing.org/reference/images/noFill_.png"],
    "parameters": []
}, {
    "name": "rotateX()",
    "description": "\nRotates a shape around the x-axis the amount specified by the angle parameter. Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the radians() function. Objects are always rotated around their relative position to the origin and positive numbers rotate objects in a counterclockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling rotateX(PI/2) and then rotateX(PI/2) is the same as rotateX(PI). If rotateX() is called within the draw(), the transformation is reset when the loop begins again. This function requires using P3D as a third parameter to size() as shown in the example above. \n",
    "syntax": "rotateX(angle)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\ntranslate(width/2, height/2);\nrotateX(PI/3.0);\nrect(-26, -26, 52, 52);\n", "\nsize(100, 100, P3D);\ntranslate(width/2, height/2);\nrotateX(radians(60));\nrect(-26, -26, 52, 52);\n"],
    "examples_img": ["https://www.processing.org/reference/images/rotateX_0.png", "https://www.processing.org/reference/images/rotateX_1.png"],
    "parameters": [{
        "name": "angle",
        "description": "float: angle of rotation specified in radians"
    }]
}, {
    "name": "frustum()",
    "description": "\nSets a perspective matrix as defined by the parameters.\n\nA frustum is a geometric form: a pyramid with its top cut off.  With the viewer's eye at the imaginary top of the pyramid, the six planes of the frustum act as clipping planes when rendering a 3D view.  Thus, any form inside the clipping planes is rendered and visible; anything outside those planes is not visible.\n\nSetting the frustum has the effect of changing the perspective with which the scene is rendered.  This can be acheived more simply in many cases by using perspective().\n\nNote that the near value must be greater than zero (as the point of the frustum \"pyramid\" cannot converge \"behind\" the viewer).  Similarly, the far value must be greater than the near value (as the \"far\" plane of the frustum must be \"farther away\" from the viewer than the near plane).\n\nWorks like glFrustum, except it wipes out the current perspective matrix rather than multiplying itself with it.\n",
    "syntax": "frustum(left, right, bottom, top, near, far)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);  \nnoFill();\nbackground(204);\nfrustum(-10, 0, 0, 10, 10, 200);\nrotateY(PI/6);\nbox(45);\n"],
    "examples_img": ["https://www.processing.org/reference/images/frustum_.png"],
    "parameters": [{
        "name": "left",
        "description": "float: left coordinate of the clipping plane"
    }, {
        "name": "right",
        "description": "float: right coordinate of the clipping plane"
    }, {
        "name": "bottom",
        "description": "float: bottom coordinate of the clipping plane"
    }, {
        "name": "top",
        "description": "float: top coordinate of the clipping plane"
    }, {
        "name": "near",
        "description": "float: near component of the clipping plane; must be greater than zero"
    }, {
        "name": "far",
        "description": "float: far component of the clipping plane; must be greater than the near value"
    }]
}, {
    "name": "hue()",
    "description": "\nExtracts the hue value from a color.\n",
    "syntax": "hue(rgb)",
    "returns": "float",
    "examples": ["\nnoStroke();\ncolorMode(HSB, 255);\ncolor c = color(0, 126, 255);\nfill(c);\nrect(15, 20, 35, 60);\nfloat value = hue(c);  // Sets 'value' to \"0\"\nfill(value);\nrect(50, 20, 35, 60);\n"],
    "examples_img": ["https://www.processing.org/reference/images/hue_.png"],
    "parameters": [{
        "name": "rgb",
        "description": "int: any value of the color datatype"
    }]
}, {
    "name": "popMatrix()",
    "description": "\nPops the current transformation matrix off the matrix stack. Understanding pushing and popping requires understanding the concept of a matrix stack. The pushMatrix() function saves the current coordinate system to the stack and popMatrix() restores the prior coordinate system. pushMatrix() and popMatrix() are used in conjuction with the other transformation functions and may be embedded to control the scope of the transformations.\n",
    "syntax": "popMatrix()",
    "returns": "void",
    "examples": ["\nfill(255);\nrect(0, 0, 50, 50);  // White rectangle\n\npushMatrix();\ntranslate(30, 20);\nfill(0);  \nrect(0, 0, 50, 50);  // Black rectangle\npopMatrix();\n\nfill(100);  \nrect(15, 10, 50, 50);  // Gray rectangle\n"],
    "examples_img": ["https://www.processing.org/reference/images/popMatrix_.png"],
    "parameters": []
}, {
    "name": "scale()",
    "description": "\nIncreases or decreases the size of a shape by expanding and contracting vertices. Objects always scale from their relative origin to the coordinate system. Scale values are specified as decimal percentages. For example, the function call scale(2.0) increases the dimension of a shape by 200%.\n\nTransformations apply to everything that happens after and subsequent calls to the function multiply the effect. For example, calling scale(2.0) and then scale(1.5) is the same as scale(3.0). If scale() is called within draw(), the transformation is reset when the loop begins again. Using this fuction with the z parameter requires using P3D as a parameter for size(), as shown in the third example above. This function can be further controlled with pushMatrix() and popMatrix().\n",
    "syntax": "scale(s)\nscale(x, y)\nscale(x, y, z)",
    "returns": "void",
    "examples": ["\nrect(30, 20, 50, 50);\nscale(0.5);\nrect(30, 20, 50, 50);\n", "\nrect(30, 20, 50, 50);\nscale(0.5, 1.3);\nrect(30, 20, 50, 50);\n", "\n// Scaling in 3D requires P3D \n// as a parameter to size()\nsize(100, 100, P3D);\nnoFill();\ntranslate(width/2+12, height/2);\nbox(20, 20, 20);\nscale(2.5, 2.5, 2.5);\nbox(20, 20, 20);\n"],
    "examples_img": ["https://www.processing.org/reference/images/scale_0.png", "https://www.processing.org/reference/images/scale_1.png", "https://www.processing.org/reference/images/scale_2.png"],
    "parameters": [{
        "name": "s",
        "description": "float: percentage to scale the object"
    }, {
        "name": "x",
        "description": "float: percentage to scale the object in the x-axis"
    }, {
        "name": "y",
        "description": "float: percentage to scale the object in the y-axis"
    }, {
        "name": "z",
        "description": "float: percentage to scale the object in the z-axis"
    }]
}, {
    "name": "blend()",
    "description": "\nBlends a region of pixels from one image into another (or in itself again) with full alpha channel support. There is a choice of the following modes to blend the source pixels (A) with the ones of pixels in the destination image (B):\n\nBLEND - linear interpolation of colours: C = A*factor + B\n\nADD - additive blending with white clip: C = min(A*factor + B, 255)\n\nSUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n\nDARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n\nLIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n\nDIFFERENCE - subtract colors from underlying image.\n\nEXCLUSION - similar to DIFFERENCE, but less extreme.\n\nMULTIPLY - Multiply the colors, result will always be darker.\n\nSCREEN - Opposite multiply, uses inverse values of the colors.\n\nOVERLAY - A mix of MULTIPLY and SCREEN. Multiplies dark values,\nand screens light values.\n\nHARD_LIGHT - SCREEN when greater than 50% gray, MULTIPLY when lower.\n\nSOFT_LIGHT - Mix of DARKEST and LIGHTEST. \nWorks like OVERLAY, but not as harsh.\n\nDODGE - Lightens light tones and increases contrast, ignores darks.\nCalled \"Color Dodge\" in Illustrator and Photoshop.\n\nBURN - Darker areas are applied, increasing contrast, ignores lights.\nCalled \"Color Burn\" in Illustrator and Photoshop.\n\nAll modes use the alpha information (highest byte) of source image pixels as the blending factor. If the source and destination regions are different sizes, the image will be automatically resized to match the destination size. If the srcImg parameter is not used, the display window is used as the source image.\n\nAs of release 0149, this function ignores imageMode().\n",
    "syntax": "blend(sx, sy, sw, sh, dx, dy, dw, dh, mode)\nblend(src, sx, sy, sw, sh, dx, dy, dw, dh, mode)",
    "returns": "void",
    "examples": ["\nbackground(loadImage(\"rockies.jpg\"));\nPImage img = loadImage(\"bricks.jpg\");\nimage(img, 0, 0);\nblend(img, 0, 0, 33, 100, 67, 0, 33, 100, ADD);\n", "\nbackground(loadImage(\"rockies.jpg\"));\nPImage img = loadImage(\"bricks.jpg\");\nimage(img, 0, 0);\nblend(img, 0, 0, 33, 100, 67, 0, 33, 100, SUBTRACT);\n", "\nbackground(loadImage(\"rockies.jpg\"));\nPImage img = loadImage(\"bricks.jpg\");\nimage(img, 0, 0);\nblend(img, 0, 0, 33, 100, 67, 0, 33, 100, DARKEST);\n", "\nbackground(loadImage(\"rockies.jpg\"));\nPImage img = loadImage(\"bricks.jpg\");\nimage(img, 0, 0);\nblend(img, 0, 0, 33, 100, 67, 0, 33, 100, LIGHTEST);\n"],
    "examples_img": ["https://www.processing.org/reference/images/blend_0_add.png", "https://www.processing.org/reference/images/blend_1_subtract.png", "https://www.processing.org/reference/images/blend_2_darkest.png", "https://www.processing.org/reference/images/blend_3_lightest.png"],
    "parameters": [{
        "name": "src",
        "description": "PImage: an image variable referring to the source image"
    }, {
        "name": "sx",
        "description": "int: X coordinate of the source's upper left corner"
    }, {
        "name": "sy",
        "description": "int: Y coordinate of the source's upper left corner"
    }, {
        "name": "sw",
        "description": "int: source image width"
    }, {
        "name": "sh",
        "description": "int: source image height"
    }, {
        "name": "dx",
        "description": "int: X coordinate of the destinations's upper left corner"
    }, {
        "name": "dy",
        "description": "int: Y coordinate of the destinations's upper left corner"
    }, {
        "name": "dw",
        "description": "int: destination image width"
    }, {
        "name": "dh",
        "description": "int: destination image height"
    }, {
        "name": "mode",
        "description": "int: Either BLEND, ADD, SUBTRACT, LIGHTEST, DARKEST, DIFFERENCE, EXCLUSION, MULTIPLY, SCREEN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, DODGE, BURN"
    }]
}, {
    "name": "strokeCap()",
    "description": "\nSets the style for rendering line endings. These ends are either squared, extended, or rounded, each of which specified with the corresponding parameters: SQUARE, PROJECT, and ROUND. The default cap is ROUND.\n",
    "syntax": "strokeCap(cap)",
    "returns": "void",
    "examples": ["\nstrokeWeight(12.0);\nstrokeCap(ROUND);\nline(20, 30, 80, 30);\nstrokeCap(SQUARE);\nline(20, 50, 80, 50);\nstrokeCap(PROJECT);\nline(20, 70, 80, 70);\n"],
    "examples_img": ["https://www.processing.org/reference/images/strokeCap_.png"],
    "parameters": [{
        "name": "cap",
        "description": "int: either SQUARE, PROJECT, or ROUND"
    }]
}, {
    "name": "printMatrix()",
    "description": "\nPrints the current matrix to the Console (the text window at the bottom of Processing).\n",
    "syntax": "printMatrix()",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nprintMatrix();\n// Prints:\n// 01.0000  00.0000  00.0000 -50.0000\n// 00.0000  01.0000  00.0000 -50.0000\n// 00.0000  00.0000  01.0000 -86.6025\n// 00.0000  00.0000  00.0000  01.0000\n\nresetMatrix();\nprintMatrix();\n// Prints:\n// 1.0000  0.0000  0.0000  0.0000\n// 0.0000  1.0000  0.0000  0.0000\n// 0.0000  0.0000  1.0000  0.0000\n// 0.0000  0.0000  0.0000  1.0000\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "brightness()",
    "description": "\nExtracts the brightness value from a color.\n",
    "syntax": "brightness(rgb)",
    "returns": "float",
    "examples": ["\nnoStroke();\ncolorMode(HSB, 255);\ncolor c = color(0, 126, 255);\nfill(c);\nrect(15, 20, 35, 60);\nfloat value = brightness(c);  // Sets 'value' to 255\nfill(value);\nrect(50, 20, 35, 60);\n"],
    "examples_img": ["https://www.processing.org/reference/images/brightness_.png"],
    "parameters": [{
        "name": "rgb",
        "description": "int: any value of the color datatype"
    }]
}, {
    "name": "asin()",
    "description": "\nThe inverse of sin(), returns the arc sine of a value. This function expects the values in the range of -1 to 1 and values are returned in the range -PI/2 to PI/2.\n",
    "syntax": "asin(value)",
    "returns": "float",
    "examples": ["\nfloat a = PI/3;\nfloat s = sin(a);\nfloat as = asin(s);\n// Prints \"1.0471976 : 0.86602545 : 1.0471976\"\nprintln(a + \" : \" + s + \" : \" +  as);\n", "\nfloat a = PI + PI/3.0;\nfloat s = sin(a);\nfloat as = asin(s);\n// Prints \"4.1887903 : -0.86602545 : -1.0471976\"\nprintln(a + \" : \" + s + \" : \" +  as);\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value",
        "description": "float: the value whose arc sine is to be returned"
    }]
}, {
    "name": "pushMatrix()",
    "description": "\nPushes the current transformation matrix onto the matrix stack. Understanding pushMatrix() and popMatrix() requires understanding the concept of a matrix stack. The pushMatrix() function saves the current coordinate system to the stack and popMatrix() restores the prior coordinate system. pushMatrix() and popMatrix() are used in conjuction with the other transformation functions and may be embedded to control the scope of the transformations.\n",
    "syntax": "pushMatrix()",
    "returns": "void",
    "examples": ["\nfill(255);\nrect(0, 0, 50, 50);  // White rectangle\n\npushMatrix();\ntranslate(30, 20);\nfill(0);  \nrect(0, 0, 50, 50);  // Black rectangle\npopMatrix();\n\nfill(100);  \nrect(15, 10, 50, 50);  // Gray rectangle\n"],
    "examples_img": ["https://www.processing.org/reference/images/pushMatrix_.png"],
    "parameters": []
}, {
    "name": "randomGaussian()",
    "description": "\nReturns a float from a random series of numbers having a mean of 0 and standard deviation of 1. Each time the randomGaussian() function is called, it returns a number fitting a Gaussian, or normal, distribution. There is theoretically no minimum or maximum value that randomGaussian() might return. Rather, there is just a very low probability that values far from the mean will be returned; and a higher probability that numbers near the mean will be returned.\n",
    "syntax": "randomGaussian()",
    "returns": "float",
    "examples": ["\nfor (int y = 0; y < 100; y++) {\n  float x = randomGaussian() * 15;\n  line(50, y, 50 + x, y);\n}\n", "\nfloat[] distribution = new float[360];\n\nvoid setup() {\n  size(100, 100);\n  for (int i = 0; i < distribution.length; i++) {\n    distribution[i] = int(randomGaussian() * 15);\n  }\n}\n\nvoid draw() {\n  background(204);\n  \n  translate(width/2, width/2);\n\n  for (int i = 0; i < distribution.length; i++) {\n    rotate(TWO_PI/distribution.length);\n    stroke(0);\n    float dist = abs(distribution[i]);\n    line(0, 0, dist, 0);\n  }\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/randomGaussian_0.png", "https://www.processing.org/reference/images/randomGaussian_1.png"],
    "parameters": []
}, {
    "name": "emissive()",
    "description": "\nSets the emissive color of the material used for drawing shapes drawn to the screen. Used in combination with ambient(), specular(), and shininess() in setting the material properties of shapes.\n",
    "syntax": "emissive(rgb)\nemissive(gray)\nemissive(v1, v2, v3)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nbackground(0);\nnoStroke();\nbackground(0);\ndirectionalLight(204, 204, 204, .5, 0, -1);\nemissive(0, 26, 51);\ntranslate(70, 50, 0);\nsphere(30);\n"],
    "examples_img": ["https://www.processing.org/reference/images/emissive_.png"],
    "parameters": [{
        "name": "rgb",
        "description": "int: color to set"
    }, {
        "name": "v1",
        "description": "float: red or hue value (depending on current color mode)"
    }, {
        "name": "v2",
        "description": "float: green or saturation value (depending on current color mode)"
    }, {
        "name": "v3",
        "description": "float: blue or brightness value (depending on current color mode)"
    }]
}, {
    "name": "ortho()",
    "description": "\nSets an orthographic projection and defines a parallel clipping volume. All objects with the same dimension appear the same size, regardless of whether they are near or far from the camera. The parameters to this function specify the clipping volume where left and right are the minimum and maximum x values, top and bottom are the minimum and maximum y values, and near and far are the minimum and maximum z values. If no parameters are given, the default is used: ortho(0, width, 0, height).\n",
    "syntax": "ortho()\northo(left, right, bottom, top)\northo(left, right, bottom, top, near, far)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nnoFill();\northo(0, width, 0, height); // same as ortho()\ntranslate(width/2, height/2, 0);\nrotateX(-PI/6);\nrotateY(PI/3);\nbox(45);\n"],
    "examples_img": ["https://www.processing.org/reference/images/ortho_.png"],
    "parameters": [{
        "name": "left",
        "description": "float: left plane of the clipping volume"
    }, {
        "name": "right",
        "description": "float: right plane of the clipping volume"
    }, {
        "name": "bottom",
        "description": "float: bottom plane of the clipping volume"
    }, {
        "name": "top",
        "description": "float: top plane of the clipping volume"
    }, {
        "name": "near",
        "description": "float: maximum distance from the origin to the viewer"
    }, {
        "name": "far",
        "description": "float: maximum distance from the origin away from the viewer"
    }]
}, {
    "name": "cos()",
    "description": "\nCalculates the cosine of an angle. This function expects the values of the angle parameter to be provided in radians (values from 0 to PI*2). Values are returned in the range -1 to 1.\n",
    "syntax": "cos(angle)",
    "returns": "float",
    "examples": ["\nfloat a = 0.0;\nfloat inc = TWO_PI/25.0;\nfor (int i = 0; i < 25; i++) {\n  line(i*4, 50, i*4, 50+cos(a)*40.0);\n  a = a + inc;\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/cos_.png"],
    "parameters": [{
        "name": "angle",
        "description": "float: an angle in radians"
    }]
}, {
    "name": "atan2()",
    "description": "\nCalculates the angle (in radians) from a specified point to the coordinate origin as measured from the positive x-axis. Values are returned as a float in the range from PI to -PI. The atan2() function is most often used for orienting geometry to the position of the cursor.  Note: The y-coordinate of the point is the first parameter, and the x-coordinate is the second parameter, due the the structure of calculating the tangent.\n",
    "syntax": "atan2(y, x)",
    "returns": "float",
    "examples": ["\nvoid draw() {\n  background(204);\n  translate(width/2, height/2);\n  float a = atan2(mouseY-height/2, mouseX-width/2);\n  rotate(a);\n  rect(-30, -5, 60, 10);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "y",
        "description": "float: y-coordinate of the point"
    }, {
        "name": "x",
        "description": "float: x-coordinate of the point"
    }]
}, {
    "name": "noiseDetail()",
    "description": "\nAdjusts the character and level of detail produced by the Perlin noise function. Similar to harmonics in physics, noise is computed over several octaves. Lower octaves contribute more to the output signal and as such define the overal intensity of the noise, whereas higher octaves create finer-grained details in the noise sequence.\n\nBy default, noise is computed over 4 octaves with each octave contributing exactly half than its predecessor, starting at 50% strength for the first octave. This falloff amount can be changed by adding an additional function parameter. For example, a falloff factor of 0.75 means each octave will now have 75% impact (25% less) of the previous lower octave. While any number between 0.0 and 1.0 is valid, note that values greater than 0.5 may result in noise() returning values greater than 1.0.\n\nBy changing these parameters, the signal created by the noise() function can be adapted to fit very specific needs and characteristics.\n",
    "syntax": "noiseDetail(lod)\nnoiseDetail(lod, falloff)",
    "returns": "void",
    "examples": ["\nfloat noiseVal;\nfloat noiseScale=0.02;\n\nvoid draw() {\n  for (int y = 0; y < height; y++) {\n    for (int x = 0; x < width/2; x++) {\n      noiseDetail(3,0.5);\n      noiseVal = noise((mouseX+x) * noiseScale, (mouseY+y) * noiseScale);\n      stroke(noiseVal*255);\n      point(x,y);\n      noiseDetail(8,0.65);\n      noiseVal = noise((mouseX + x + width/2) * noiseScale, \n                       (mouseY + y) * noiseScale);\n      stroke(noiseVal * 255);\n      point(x + width/2, y);\n    }\n  }\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "lod",
        "description": "int: number of octaves to be used by the noise"
    }, {
        "name": "falloff",
        "description": "float: falloff factor for each octave"
    }]
}, {
    "name": "copy()",
    "description": "\nCopies a region of pixels from the display window to another area of the display window and copies a region of pixels from an image used as the srcImg parameter into the display window. If the source and destination regions aren't the same size, it will automatically resize the source pixels to fit the specified target region. No alpha information is used in the process, however if the source image has an alpha channel set, it will be copied as well.\n\nAs of release 0149, this function ignores imageMode().\n",
    "syntax": "copy()\ncopy(sx, sy, sw, sh, dx, dy, dw, dh)\ncopy(src, sx, sy, sw, sh, dx, dy, dw, dh)",
    "returns": "void or PImage",
    "examples": ["\nPImage img = loadImage(\"eames.jpg\");\nimage(img, 0, 0, width, height);\ncopy(7, 22, 10, 10, 35, 25, 50, 50);\nstroke(255);\nnoFill();\n// Rectangle shows area being copied\nrect(7, 22, 10, 10);\n"],
    "examples_img": ["https://www.processing.org/reference/images/copy_.png"],
    "parameters": [{
        "name": "sx",
        "description": "int: X coordinate of the source's upper left corner"
    }, {
        "name": "sy",
        "description": "int: Y coordinate of the source's upper left corner"
    }, {
        "name": "sw",
        "description": "int: source image width"
    }, {
        "name": "sh",
        "description": "int: source image height"
    }, {
        "name": "dx",
        "description": "int: X coordinate of the destination's upper left corner"
    }, {
        "name": "dy",
        "description": "int: Y coordinate of the destination's upper left corner"
    }, {
        "name": "dw",
        "description": "int: destination image width"
    }, {
        "name": "dh",
        "description": "int: destination image height"
    }, {
        "name": "src",
        "description": "PImage: an image variable referring to the source image."
    }]
}, {
    "name": "green()",
    "description": "\nExtracts the green value from a color, scaled to match current colorMode(). The value is always returned as a float, so be careful not to assign it to an int value.\n\nThe green() function is easy to use and understand, but it is slower than a technique called bit shifting. When working in colorMode(RGB, 255), you can acheive the same results as green() but with greater speed by using the right shift operator (>>) with a bit mask. For example, the following two lines of code are equivalent means of getting the green value of the color value c:\n\nfloat r1 = green(c);  // Simpler, but slower to calculate\nfloat r2 = c >> 8 & 0xFF;  // Very fast to calculate\n",
    "syntax": "green(rgb)",
    "returns": "float",
    "examples": ["\ncolor c = color(20, 75, 200);  // Define color 'c'\nfill(c);  // Use color variable 'c' as fill color\nrect(15, 20, 35, 60);  // Draw left rectangle\n\nfloat greenValue = green(c);  // Get green in 'c'\nprintln(greenValue);  // Print \"75.0\"\nfill(0, greenValue, 0);  // Use 'greenValue' in new fill\nrect(50, 20, 35, 60);  // Draw right rectangle\n"],
    "examples_img": ["https://www.processing.org/reference/images/green_.png"],
    "parameters": [{
        "name": "rgb",
        "description": "int: any value of the color datatype"
    }]
}, {
    "name": "save()",
    "description": "\nSaves an image from the display window. Append a file extension to the name of the file, to indicate the file format to be used: either TIFF (.tif), TARGA (.tga), JPEG (.jpg), or PNG (.png). If no extension is included in the filename, the image will save in TIFF format and .tif will be added to the name. These files are saved to the sketch's folder, which may be opened by selecting \"Show sketch folder\" from the \"Sketch\" menu. Alternatively, the files can be saved to any location on the computer by using an absolute path (something that starts with / on Unix and Linux, or a drive letter on Windows).\n\nAll images saved from the main drawing window will be opaque. To save images without a background, use createGraphics().\n",
    "syntax": "save(filename)",
    "returns": "void",
    "examples": ["\nline(20, 20, 80, 80);\n// Saves a TIFF file named \"diagonal.tif\"\nsave(\"diagonal.tif\");\n// Saves a TARGA file named \"cross.tga\"\nline(80, 20, 20, 80);\nsave(\"cross.tga\");\n"],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: any sequence of letters and numbers"
    }]
}, {
    "name": "printCamera()",
    "description": "\nPrints the current camera matrix to the Console (the text window at the bottom of Processing).\n",
    "syntax": "printCamera()",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nprintCamera();\n\n// The program above prints this data:\n// 01.0000  00.0000  00.0000 -50.0000\n// 00.0000  01.0000  00.0000 -50.0000\n// 00.0000  00.0000  01.0000 -86.6025\n// 00.0000  00.0000  00.0000  01.0000\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "specular()",
    "description": "\nSets the specular color of the materials used for shapes drawn to the screen, which sets the color of highlights. Specular refers to light which bounces off a surface in a preferred direction (rather than bouncing in all directions like a diffuse light). Used in combination with emissive(), ambient(), and shininess() in setting the material properties of shapes.\n",
    "syntax": "specular(rgb)\nspecular(gray)\nspecular(v1, v2, v3)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nbackground(0);\nnoStroke();\nbackground(0);\nfill(0, 51, 102);\nlightSpecular(255, 255, 255);\ndirectionalLight(204, 204, 204, 0, 0, -1);\ntranslate(20, 50, 0);\nspecular(255, 255, 255);\nsphere(30);\ntranslate(60, 0, 0);\nspecular(204, 102, 0);\nsphere(30);\n"],
    "examples_img": ["https://www.processing.org/reference/images/specular_.png"],
    "parameters": [{
        "name": "rgb",
        "description": "int: color to set"
    }, {
        "name": "v1",
        "description": "float: red or hue value (depending on current color mode)"
    }, {
        "name": "v2",
        "description": "float: green or saturation value (depending on current color mode)"
    }, {
        "name": "v3",
        "description": "float: blue or brightness value (depending on current color mode)"
    }]
}, {
    "name": "acos()",
    "description": "\nThe inverse of cos(), returns the arc cosine of a value. This function expects the values in the range of -1 to 1 and values are returned in the range 0 to PI (3.1415927).\n",
    "syntax": "acos(value)",
    "returns": "float",
    "examples": ["\nfloat a = PI;\nfloat c = cos(a);\nfloat ac = acos(c);\n// Prints \"3.1415927 : -1.0 : 3.1415927\"\nprintln(a + \" : \" + c + \" : \" +  ac);\n", "\nfloat a = PI + PI/4.0;\nfloat c = cos(a);\nfloat ac = acos(c);\n// Prints \"3.926991 : -0.70710665 : 2.3561943\"\nprintln(a + \" : \" + c + \" : \" +  ac);\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value",
        "description": "float: the value whose arc cosine is to be returned"
    }]
}, {
    "name": "applyMatrix()",
    "description": "\nMultiplies the current matrix by the one specified through the parameters. This is very slow because it will try to calculate the inverse of the transform, so avoid it whenever possible. The equivalent function in OpenGL is glMultMatrix().\n",
    "syntax": "applyMatrix(source)\napplyMatrix(n00, n01, n02, n10, n11, n12)\napplyMatrix(n00, n01, n02, n03, n10, n11, n12, n13, n20, n21, n22, n23, n30, n31, n32, n33)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nnoFill();\ntranslate(50, 50, 0);\nrotateY(PI/6); \nstroke(153);\nbox(35);\n// Set rotation angles\nfloat ct = cos(PI/9.0);\nfloat st = sin(PI/9.0);          \n// Matrix for rotation around the Y axis\napplyMatrix(  ct, 0.0,  st,  0.0,\n             0.0, 1.0, 0.0,  0.0,\n             -st, 0.0,  ct,  0.0,\n             0.0, 0.0, 0.0,  1.0);  \nstroke(255);\nbox(50);\n"],
    "examples_img": ["https://www.processing.org/reference/images/applyMatrix_.png"],
    "parameters": [{
        "name": "n00",
        "description": "float: numbers which define the 4x4 matrix to be multiplied"
    }, {
        "name": "n01",
        "description": "float: numbers which define the 4x4 matrix to be multiplied"
    }, {
        "name": "n02",
        "description": "float: numbers which define the 4x4 matrix to be multiplied"
    }, {
        "name": "n10",
        "description": "float: numbers which define the 4x4 matrix to be multiplied"
    }, {
        "name": "n11",
        "description": "float: numbers which define the 4x4 matrix to be multiplied"
    }, {
        "name": "n12",
        "description": "float: numbers which define the 4x4 matrix to be multiplied"
    }, {
        "name": "n03",
        "description": "float: numbers which define the 4x4 matrix to be multiplied"
    }, {
        "name": "n13",
        "description": "float: numbers which define the 4x4 matrix to be multiplied"
    }, {
        "name": "n20",
        "description": "float: numbers which define the 4x4 matrix to be multiplied"
    }, {
        "name": "n21",
        "description": "float: numbers which define the 4x4 matrix to be multiplied"
    }, {
        "name": "n22",
        "description": "float: numbers which define the 4x4 matrix to be multiplied"
    }, {
        "name": "n23",
        "description": "float: numbers which define the 4x4 matrix to be multiplied"
    }, {
        "name": "n30",
        "description": "float: numbers which define the 4x4 matrix to be multiplied"
    }, {
        "name": "n31",
        "description": "float: numbers which define the 4x4 matrix to be multiplied"
    }, {
        "name": "n32",
        "description": "float: numbers which define the 4x4 matrix to be multiplied"
    }, {
        "name": "n33",
        "description": "float: numbers which define the 4x4 matrix to be multiplied"
    }]
}, {
    "name": "createInput()",
    "description": "\nThis is a shorthand function for advanced programmers to initialize and open a Java InputStream. It's useful if you want to use the facilities provided by PApplet to easily open files from the data folder or from a URL, but you need an InputStream object so that you can use other parts of Java to take more control of how the stream is read.\n\nThe filename passed in can be:\n- A URL, as in: createInput(\"http://processing.org/\")\n- The name of a file in the sketch's data folder\n- The full path to a file to be opened locally (when running as an application)\n\nIf the requested item doesn't exist, null is returned. If not online, this will also check to see if the user is asking for a file whose name isn't properly capitalized. If capitalization is different, an error will be printed to the console. This helps prevent issues that appear when a sketch is exported to the web, where case sensitivity matters, as opposed to running from inside the Processing Development Environment on Windows or Mac OS, where case sensitivity is preserved but ignored.\n\nIf the file ends with .gz, the stream will automatically be gzip decompressed. If you don't want the automatic decompression, use the related function createInputRaw().\n\nIn earlier releases, this function was called openStream().\n",
    "syntax": "createInput(filename)",
    "returns": "InputStream",
    "examples": ["\n// Load the local file 'data.txt' and initialize a new InputStream\nInputStream input = createInput(\"data.txt\");\n\nString content = \"\";\n\ntry {\n  int data = input.read();\n  while (data != -1) {\n    content += data;\n    data = input.read();\n  }\n}\ncatch (IOException e) {\n  e.printStackTrace();\n}\nfinally {\n  try {\n    input.close();\n  } \n  catch (IOException e) {\n    e.printStackTrace();\n  }\n}\n\nprintln(content);\n"],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: the name of the file to use as input"
    }]
}, {
    "name": "color()",
    "description": "\nCreates colors for storing in variables of the color datatype. The parameters are interpreted as RGB or HSB values depending on the current colorMode(). The default mode is RGB values from 0 to 255 and, therefore, color(255, 204, 0) will return a bright yellow color (see the first example above).\n\nNote that if only one value is provided to color(), it will be interpreted as a grayscale value. Add a second value, and it will be used for alpha transparency. When three values are specified, they are interpreted as either RGB or HSB values. Adding a fourth value applies alpha transparency.\n\nNote that when using hexadecimal notation, it is not necessary to use color(), as in: color c = #006699\n\nMore about how colors are stored can be found in the reference for the color datatype.\n",
    "syntax": "color(gray)\ncolor(gray, alpha)\ncolor(v1, v2, v3)\ncolor(v1, v2, v3, alpha)",
    "returns": "int",
    "examples": ["\ncolor c = color(255, 204, 0);  // Define color 'c'\nfill(c);  // Use color variable 'c' as fill color\nnoStroke();  // Don't draw a stroke around shapes\nrect(30, 20, 55, 55);  // Draw rectangle\n", "\ncolor c = color(255, 204, 0);  // Define color 'c'\nfill(c);  // Use color variable 'c' as fill color\nnoStroke();  // Don't draw a stroke around shapes\nellipse(25, 25, 80, 80);  // Draw left circle\n\n// Using only one value with color()\n// generates a grayscale value.\nc = color(65);  // Update 'c' with grayscale value\nfill(c);  // Use updated 'c' as fill color\nellipse(75, 75, 80, 80);  // Draw right circle\n", "\ncolor c;  // Declare color 'c'\nnoStroke();  // Don't draw a stroke around shapes\n\n// If no colorMode is specified, then the\n// default of RGB with scale of 0-255 is used.\nc = color(50, 55, 100);  // Create a color for 'c'\nfill(c);  // Use color variable 'c' as fill color\nrect(0, 10, 45, 80);  // Draw left rect\n\ncolorMode(HSB, 100);  // Use HSB with scale of 0-100\nc = color(50, 55, 100);  // Update 'c' with new color\nfill(c);  // Use updated 'c' as fill color\nrect(55, 10, 45, 80);  // Draw right rect\n"],
    "examples_img": ["https://www.processing.org/reference/images/color_0.png", "https://www.processing.org/reference/images/color_1.png", "https://www.processing.org/reference/images/color_2.png"],
    "parameters": [{
        "name": "gray",
        "description": "int: number specifying value between white and black"
    }, {
        "name": "alpha",
        "description": "float, or int: relative to current color range"
    }, {
        "name": "v1",
        "description": "float, or int: red or hue values relative to the current color range"
    }, {
        "name": "v2",
        "description": "float, or int: green or saturation values relative to the current color range"
    }, {
        "name": "v3",
        "description": "float, or int: blue or brightness values relative to the current color range"
    }]
}, {
    "name": "rectMode()",
    "description": "\nModifies the location from which rectangles are drawn by changing the way in which parameters given to rect() are intepreted.\n\nThe default mode is rectMode(CORNER), which interprets the first two parameters of rect() as the upper-left corner of the shape, while the third and fourth parameters are its width and height.\n\nrectMode(CORNERS) interprets the first two parameters of rect() as the location of one corner, and the third and fourth parameters as the location of the opposite corner.\n\nrectMode(CENTER) interprets the first two parameters of rect() as the shape's center point, while the third and fourth parameters are its width and height.\n\nrectMode(RADIUS) also uses the first two parameters of rect() as the shape's center point, but uses the third and fourth parameters to specify half of the shapes's width and height.\n\nThe parameter must be written in ALL CAPS because Processing is a case-sensitive language.\n",
    "syntax": "rectMode(mode)",
    "returns": "void",
    "examples": ["\nrectMode(CORNER);  // Default rectMode is CORNER\nfill(255);  // Set fill to white\nrect(25, 25, 50, 50);  // Draw white rect using CORNER mode\n\nrectMode(CORNERS);  // Set rectMode to CORNERS\nfill(100);  // Set fill to gray\nrect(25, 25, 50, 50);  // Draw gray rect using CORNERS mode\n", "\nrectMode(RADIUS);  // Set rectMode to RADIUS\nfill(255);  // Set fill to white\nrect(50, 50, 30, 30);  // Draw white rect using RADIUS mode\n\nrectMode(CENTER);  // Set rectMode to CENTER\nfill(100);  // Set fill to gray\nrect(50, 50, 30, 30);  // Draw gray rect using CENTER mode\n"],
    "examples_img": ["https://www.processing.org/reference/images/rectMode_0.png", "https://www.processing.org/reference/images/rectMode_1.png"],
    "parameters": [{
        "name": "mode",
        "description": "int: either CORNER, CORNERS, CENTER, or RADIUS"
    }]
}, {
    "name": "BufferedReader",
    "description": "\nA BufferedReader object is used to read files line-by-line as individual String objects.\n\nStarting with Processing release 0134, all files loaded and saved by the Processing API use UTF-8 encoding. In previous releases, the default encoding for your platform was used, which causes problems when files are moved to other platforms.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nBufferedReader reader;\nString line;\n \nvoid setup() {\n  // Open the file from the createWriter() example\n  reader = createReader(\"positions.txt\");    \n}\n \nvoid draw() {\n  try {\n    line = reader.readLine();\n  } catch (IOException e) {\n    e.printStackTrace();\n    line = null;\n  }\n  if (line == null) {\n    // Stop reading because of an error or file is empty\n    noLoop();  \n  } else {\n    String[] pieces = split(line, TAB);\n    int x = int(pieces[0]);\n    int y = int(pieces[1]);\n    point(x, y);\n  }\n} \n"],
    "examples_img": [],
    "parameters": [{
        "name": "",
        "description": ""
    }]
}, {
    "name": "pointLight()",
    "description": "\nAdds a point light. Lights need to be included in the draw() to remain persistent in a looping program. Placing them in the setup() of a looping program will cause them to only have an effect the first time through the loop. The v1, v2, and v3 parameters are interpreted as either RGB or HSB values, depending on the current color mode. The x, y, and z parameters set the position of the light.\n",
    "syntax": "pointLight(v1, v2, v3, x, y, z)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nbackground(0);\nnoStroke();\npointLight(51, 102, 126, 35, 40, 36);\ntranslate(80, 50, 0);\nsphere(30);\n"],
    "examples_img": ["https://www.processing.org/reference/images/pointLight_.png"],
    "parameters": [{
        "name": "v1",
        "description": "float: red or hue value (depending on current color mode)"
    }, {
        "name": "v2",
        "description": "float: green or saturation value (depending on current color mode)"
    }, {
        "name": "v3",
        "description": "float: blue or brightness value (depending on current color mode)"
    }, {
        "name": "x",
        "description": "float: x-coordinate of the light"
    }, {
        "name": "y",
        "description": "float: y-coordinate of the light"
    }, {
        "name": "z",
        "description": "float: z-coordinate of the light"
    }]
}, {
    "name": "sqrt()",
    "description": "\nCalculates the square root of a number. The square root of a number is always positive, even though there may be a valid negative root. The square root s of number a is such that s*s = a. It is the opposite of squaring.\n",
    "syntax": "sqrt(n)",
    "returns": "float",
    "examples": ["\nnoStroke();\nfloat a = sqrt(6561);  // Sets 'a' to 81\nfloat b = sqrt(625);   // Sets 'b' to 25\nfloat c = sqrt(1);     // Sets 'c' to 1\nrect(0, 25, a, 10);\nrect(0, 45, b, 10);\nrect(0, 65, c, 10);\n"],
    "examples_img": ["https://www.processing.org/reference/images/sqrt_.png"],
    "parameters": [{
        "name": "n",
        "description": "float: non-negative number"
    }]
}, {
    "name": "screenY()",
    "description": "\nTakes a three-dimensional X, Y, Z position and returns the Y value for where it will appear on a (two-dimensional) screen.\n",
    "syntax": "screenY(x, y)\nscreenY(x, y, z)",
    "returns": "float",
    "examples": ["\nvoid setup() {\n  size(100, 100, P3D);\n}\n\nvoid draw() {\n  background(204);\n  \n  float x = mouseX;\n  float y = mouseY;\n  float z = -100;\n  \n  // Draw \"X\" at z = -100\n  stroke(255);\n  line(x-10, y-10, z, x+10, y+10, z); \n  line(x+10, y-10, z, x-10, y+10, z); \n  \n  // Draw gray line at z = 0 and same \n  // y value. Notice the parallax\n  stroke(102);\n  line(0, y, 0, width, y, 0);\n  \n  // Draw black line at z = 0 to match \n  // the y value element drawn at z = -100 \n  stroke(0);\n  float theY = screenY(x, y, z);\n  line(0, theY, 0, width, theY, 0);    \n}  \n"],
    "examples_img": [],
    "parameters": [{
        "name": "x",
        "description": "float: 3D x-coordinate to be mapped"
    }, {
        "name": "y",
        "description": "float: 3D y-coordinate to be mapped"
    }, {
        "name": "z",
        "description": "float: 3D z-coordinate to be mapped"
    }]
}, {
    "name": "red()",
    "description": "\nExtracts the red value from a color, scaled to match current colorMode(). The value is always returned as a float, so be careful not to assign it to an int value.\n\nThe red() function is easy to use and understand, but it is slower than a technique called bit shifting. When working in colorMode(RGB, 255), you can acheive the same results as red() but with greater speed by using the right shift operator (>>) with a bit mask. For example, the following two lines of code are equivalent means of getting the red value of the color value c:\n\nfloat r1 = red(c);  // Simpler, but slower to calculate\nfloat r2 = c >> 16 & 0xFF;  // Very fast to calculate\n",
    "syntax": "red(rgb)",
    "returns": "float",
    "examples": ["\ncolor c = color(255, 204, 0);  // Define color 'c'\nfill(c);  // Use color variable 'c' as fill color\nrect(15, 20, 35, 60);  // Draw left rectangle\n\t\nfloat redValue = red(c);  // Get red in 'c'\nprintln(redValue);  // Print \"255.0\"\nfill(redValue, 0, 0);  // Use 'redValue' in new fill\nrect(50, 20, 35, 60);  // Draw right rectangle\n"],
    "examples_img": ["https://www.processing.org/reference/images/red_.png"],
    "parameters": [{
        "name": "rgb",
        "description": "int: any value of the color datatype"
    }]
}, {
    "name": "saveStrings()",
    "description": "\nWrites an array of Strings to a file, one line per String. By default, this file is saved to the sketch's folder. This folder is opened by selecting \"Show Sketch Folder\" from the \"Sketch\" menu.\n\nAlternatively, the file can be saved to any location on the computer by using an absolute path (something that starts with / on Unix and Linux, or a drive letter on Windows).\n\nStarting with Processing 1.0, all files loaded and saved by the Processing API use UTF-8 encoding. In earlier releases, the default encoding for your platform was used, which causes problems when files are moved to other platforms.\n",
    "syntax": "saveStrings(filename, data)",
    "returns": "void",
    "examples": ["\nString words = \"apple bear cat dog\";\nString[] list = split(words, ' ');\n\n// Writes the strings to a file, each on a separate line\nsaveStrings(\"nouns.txt\", list);\n"],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: filename for output"
    }, {
        "name": "data",
        "description": "String[]: string array to be written"
    }]
}, {
    "name": "round()",
    "description": "\nCalculates the integer closest to the n parameter. For example, round(133.8) returns the value 134.\n",
    "syntax": "round(n)",
    "returns": "int",
    "examples": ["\nfloat x = 9.2;  \nint rx = round(x);  // Sets 'rx' to 9\n\nfloat y = 9.5;\nint ry = round(y);  // Sets 'ry' to 10\n\nfloat z = 9.9;\nint rz = round(z);  // Sets 'rz' to 10\n\n"],
    "examples_img": [],
    "parameters": [{
        "name": "n",
        "description": "float: number to round"
    }]
}, {
    "name": "-- (decrement)",
    "description": "\nSubstracts the value of an integer variable by 1. Equivalent to the operation i = i - 1. If the value of the variable i is five, then the expression i-- decreases the value of i to 4.\n",
    "syntax": "\nvar--\n",
    "returns": "",
    "examples": ["\nint a = 5;    // Sets 'a' to 5 \nint b = a--;  // Sets 'b' to 5, then decrements 'a' to 4\nint c = a;    // Sets 'c' to 4 \n"],
    "examples_img": [],
    "parameters": [{
        "name": "var",
        "description": "int"
    }]
}, {
    "name": "match()",
    "description": "\nThis function is used to apply a regular expression to a piece of text, and return matching groups (elements found inside parentheses) as a String array. If there are no matches, a null value will be returned. If no groups are specified in the regular expression, but the sequence matches, an array of length 1 (with the matched text as the first element of the array) will be returned.\n\nTo use the function, first check to see if the result is null. If the result is null, then the sequence did not match at all. If the sequence did match, an array is returned.\n\nIf there are groups (specified by sets of parentheses) in the regular expression, then the contents of each will be returned in the array. Element [0] of a regular expression match returns the entire matching string, and the match groups start at element [1] (the first group is [1], the second [2], and so on).\n\nThe syntax can be found in the reference for Java's Pattern class. For regular expression syntax, read the Java Tutorial on the topic.\n",
    "syntax": "match(str, regexp)",
    "returns": "String[]",
    "examples": ["\nString s = \"Inside a tag, you will find <tag>content</tag>.\";\nString[] m = match(s, \"<tag>(.*?)</tag>\");\nprintln(\"Found '\" + m[1] + \"' inside the tag.\");\n// Prints to the console:\n// \"Found 'content' inside the tag.\"\n", "\nString s1 = \"Have you ever heard of a thing called fluoridation. \"; \n       s1 += \"Fluoridation of water?\";\nString s2 = \"Uh? Yes, I-I have heard of that, Jack, yes. Yes.\";\n\nString[] m1 = match(s1, \"fluoridation\");\nif (m1 != null) {  // If not null, then a match was found\n  // This will print to the console, since a match was found.\n  println(\"Found a match in '\" + s1 + \"'\");  \n} else {\n  println(\"No match found in '\" + s1 + \"'\");\n}\n\nString[] m2 = match(s2, \"fluoridation\");\nif (m2 != null) {\n  println(\"Found a match in '\" + s2 + \"'\");\n} else {\n  // This will print to the console, since no match was found.\n  println(\"No match found in '\" + s2 + \"'\");  \n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "str",
        "description": "String: the String to be searched"
    }, {
        "name": "regexp",
        "description": "String: the regexp to be used for matching"
    }]
}, {
    "name": "while",
    "description": "\nControls a sequence of repetitions. The while structure executes a series of statements continuously while the expression is true. The expression must be updated during the repetitions or the program will never \"break out\" of while.\n \nThis function can be dangerous because the code inside the while loop will not finish until the expression inside while becomes false. It will lock out all other code from running (e.g., mouse and keyboard events will not be updated). Be careful  if used incorrectly, this can lock up your code (and sometimes even the Processing environment itself).\n",
    "syntax": "\nwhile (expression) {\n  statements\n}\n",
    "returns": "",
    "examples": ["\nint i = 0;\nwhile (i < 80) {\n  line(30, i, 80, i);\n  i = i + 5;\n} \n"],
    "examples_img": ["https://www.processing.org/reference/images/while_.png"],
    "parameters": [{
        "name": "expression",
        "description": "a valid expression"
    }, {
        "name": "statements",
        "description": "one or more statements"
    }]
}, {
    "name": "float",
    "description": "\nData type for floating-point numbers, e.g. numbers that have a decimal point.\n\nFloats are not precise, so adding small values (such as 0.0001) may not always increment precisely due to rounding errors. If you want to increment a value in small intervals, use an int, and divide by a float value before using it. (See the second example above.)\n\nFloating-point numbers can be as large as 3.40282347E+38 and as low as -3.40282347E+38. They are stored as 32 bits (4 bytes) of information. The float data type is inherited from Java; you can read more about the technical details here and here.\n\nProcessing supports the double datatype from Java as well. However, none of the Processing functions use double values, which use more memory and are typically overkill for most work created in Processing. We do not plan to add support for double values, as doing so would require increasing the number of API functions significantly.\n",
    "syntax": "\nfloat var\nfloat var = value\n",
    "returns": "",
    "examples": ["\nfloat a;           // Declare variable 'a' of type float\na = 1.5387;        // Assign 'a' the value 1.5387\nfloat b = -2.984;  // Declare variable 'b' and assign it the value -2.984\nfloat c = a + b;   // Declare variable 'c' and assign it the sum of 'a' and 'b'\n", "\nfloat f = 0;\nfor (int i = 0 ; i < 100000; i++) {  \n  f = f + 0.0001;  // Bad idea! See below.\n}\n\nfor (int i = 0; i < 100000; i++) {\n  // The variable 'f' will work better here, less affected by rounding\n  float f = i / 1000.0;  // Count by thousandths\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "var",
        "description": "variable name referencing the float"
    }, {
        "name": "value",
        "description": "any floating-point value"
    }]
}, {
    "name": "spotLight()",
    "description": "\nAdds a spot light. Lights need to be included in the draw() to remain persistent in a looping program. Placing them in the setup() of a looping program will cause them to only have an effect the first time through the loop. The v1, v2, and v3 parameters are interpreted as either RGB or HSB values, depending on the current color mode. The x, y, and z parameters specify the position of the light and nx, ny, nz specify the direction of light. The angle parameter affects angle of the spotlight cone, while concentration sets the bias of light focusing toward the center of that cone.\n",
    "syntax": "spotLight(v1, v2, v3, x, y, z, nx, ny, nz, angle, concentration)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nbackground(0);\nnoStroke();\nspotLight(51, 102, 126, 80, 20, 40, -1, 0, 0, PI/2, 2);\ntranslate(20, 50, 0);\nsphere(30);\n", "\nsize(100, 100, P3D); \nint concentration = 600;  // Try 1 -> 10000\nbackground(0); \nnoStroke(); \nspotLight(51, 102, 126, 50, 50, 400, \n          0, 0, -1, PI/16, concentration); \ntranslate(80, 50, 0); \nsphere(30);\n"],
    "examples_img": ["https://www.processing.org/reference/images/spotLight_0.png", "https://www.processing.org/reference/images/spotLight_1.png"],
    "parameters": [{
        "name": "v1",
        "description": "float: red or hue value (depending on current color mode)"
    }, {
        "name": "v2",
        "description": "float: green or saturation value (depending on current color mode)"
    }, {
        "name": "v3",
        "description": "float: blue or brightness value (depending on current color mode)"
    }, {
        "name": "x",
        "description": "float: x-coordinate of the light"
    }, {
        "name": "y",
        "description": "float: y-coordinate of the light"
    }, {
        "name": "z",
        "description": "float: z-coordinate of the light"
    }, {
        "name": "nx",
        "description": "float: direction along the x axis"
    }, {
        "name": "ny",
        "description": "float: direction along the y axis"
    }, {
        "name": "nz",
        "description": "float: direction along the z axis"
    }, {
        "name": "angle",
        "description": "float: angle of the spotlight cone"
    }, {
        "name": "concentration",
        "description": "float: exponent determining the center bias of the cone"
    }]
}, {
    "name": "hex()",
    "description": "\nConverts an int, byte, char, or color to a String containing the equivalent hexadecimal notation. For example, the color value produced by color(0, 102, 153) will convert to the String value \"FF006699\". This function can help make your geeky debugging sessions much happier.\n\nNote that the maximum number of digits is 8, because an int value can only represent up to 32 bits. Specifying more than 8 digits will not increase the length of the String further.\n",
    "syntax": "hex(value)\nhex(value, digits)",
    "returns": "String",
    "examples": ["\ncolor c = #ffcc00;\nprintln(c);          // Prints \"-13312\"\nprintln(hex(c));     // Prints \"FFFFCC00\"\nprintln(hex(c, 6));  // Prints \"FFCC00\"\n", "\ncolor c = color(255, 204, 0);\nprintln(c);          // Prints \"-13312\"\nprintln(hex(c));     // Prints \"FFFFCC00\"\nprintln(hex(c, 6));  // Prints \"FFCC00\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value",
        "description": "int, char, or byte: the value to convert"
    }, {
        "name": "digits",
        "description": "int: the number of digits (maximum 8)"
    }]
}, {
    "name": ". (dot)",
    "description": "\nProvides access to an object's methods and data. An object is one instance of a class and may contain both methods (object functions) and data (object variables and constants), as specified in the class definition. The dot operator directs the program to the information encapsulated within an object.\n",
    "syntax": "\nobject.method()\nobject.data\n",
    "returns": "",
    "examples": ["\n// Declare and construct two objects (h1 and h2) of the class HLine\nHLine h1 = new HLine(20, 1.0);\nHLine h2 = new HLine(50, 5.0);\n\nvoid setup() {\n  size(200, 200);\n}\n\nvoid draw() {\n  if (h2.speed > 1.0) {  // Dot syntax can be used to get a value\n    h2.speed -= 0.01;    // or set a value.\n  }\n  h1.update();  // Calls the h1 object's update() function\n  h2.update();  // Calls the h2 object's update() function\n}\n\nclass HLine {  // Class definition\n  float ypos, speed;  // Data\n  HLine (float y, float s) {  // Object constructor\n    ypos = y;\n    speed = s;\n  }\n  void update() {  // Update method\n    ypos += speed;\n    if (ypos > width) {\n      ypos = 0;\n    }\n    line(0, ypos, width, ypos);\n  }\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "object",
        "description": "the object to be accessed"
    }, {
        "name": "method()",
        "description": "a method encapsulated in the object"
    }, {
        "name": "data",
        "description": "a variable or constant encapsulated in the object"
    }]
}, {
    "name": "curveDetail()",
    "description": "\nSets the resolution at which curves display. The default value is 20. This function is only useful when using the P3D renderer as the default P2D renderer does not use this information.\n",
    "syntax": "curveDetail(detail)",
    "returns": "void",
    "examples": ["\nvoid setup() {\n  size(100, 100, P3D);\n  noFill();\n  noLoop();\n}\n\nvoid draw() {\n  curveDetail(1);\n  drawCurves(-15);\n  stroke(126);\n  curveDetail(2);\n  drawCurves(0);\n  stroke(255);\n  curveDetail(4);\n  drawCurves(15);\n}\n\nvoid drawCurves(float y) {\n  curve( 5, 28+y,  5, 28+y, 73, 26+y, 73, 63+y);\n  curve( 5, 28+y, 73, 26+y, 73, 63+y, 15, 67+y); \n  curve(73, 26+y, 73, 63+y, 15, 67+y, 15, 67+y);\n}\n\n"],
    "examples_img": ["https://www.processing.org/reference/images/curveDetail_.png"],
    "parameters": [{
        "name": "detail",
        "description": "int: resolution of the curves"
    }]
}, {
    "name": "rotate()",
    "description": "\nRotates a shape the amount specified by the angle parameter. Angles must be specified in radians (values from 0 to TWO_PI), or they can be converted from degrees to radians with the radians() function. \n \nObjects are always rotated around their relative position to the origin, and positive numbers rotate objects in a clockwise direction. Transformations apply to everything that happens afterward, and subsequent calls to the function compound the effect. For example, calling rotate(HALF_PI) once and then calling rotate(HALF_PI) a second time is the same as a single rotate(PI). All tranformations are reset when draw() begins again. \n \nTechnically, rotate() multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by pushMatrix() and popMatrix().\n",
    "syntax": "rotate(angle)\nrotate(angle, x, y, z)",
    "returns": "void",
    "examples": ["\ntranslate(width/2, height/2);\nrotate(PI/3.0);\nrect(-26, -26, 52, 52);\n"],
    "examples_img": ["https://www.processing.org/reference/images/rotate_.png"],
    "parameters": [{
        "name": "angle",
        "description": "float: angle of rotation specified in radians"
    }]
}, {
    "name": "!= (inequality)",
    "description": "\nDetermines if one expression is not equivalent to another.\n",
    "syntax": "\nvalue1 != value2\n",
    "returns": "",
    "examples": ["\nint a = 22;\nint b = 23;\nif (a != b) {\n  println(\"variable a is not equal to variable b\");\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1",
        "description": "int, float, char, byte, boolean"
    }, {
        "name": "value2",
        "description": "int, float, char, byte, boolean"
    }]
}, {
    "name": "HashMap",
    "description": "\nA HashMap stores a collection of objects, each referenced by a key. This is similar to an Array, only instead of accessing elements with a numeric index, a String is used. (If you are familiar with associative arrays from other languages, this is the same idea.) The above example covers basic use, but there's a more extensive example included with the Processing examples.  In addition, for simple pairings of Strings and integers, Strings and floats, or Strings and Strings, you can now use the simpler IntDict, FloatDict, and StringDict classes.\n\nFor a list of the numerous HashMap features, please read the Java reference description.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nimport java.util.Map;\n\n// Note the HashMap's \"key\" is a String and \"value\" is an Integer\nHashMap<String,Integer> hm = new HashMap<String,Integer>();\n\n// Putting key-value pairs in the HashMap\nhm.put(\"Ava\", 1);\nhm.put(\"Cait\", 35);\nhm.put(\"Casey\", 36);\n\n// Using an enhanced loop to interate over each entry\nfor (Map.Entry me : hm.entrySet()) {\n  print(me.getKey() + \" is \");\n  println(me.getValue());\n}\n\n// We can also access values by their key\nint val = hm.get(\"Casey\");\nprintln(\"Casey is \" + val);\n\n"],
    "examples_img": [],
    "parameters": [{
        "name": "Key",
        "description": "Class Name: the data type for the HashMap's keys"
    }, {
        "name": "Value",
        "description": "Class Name: the data type for the HashMap's values"
    }, {
        "name": "initialCapacity",
        "description": "int: defines the initial capacity of the map; the default is 16"
    }, {
        "name": "loadFactor",
        "description": "float: the load factor for the map; the default is 0.75"
    }, {
        "name": "m",
        "description": "Map: gives the new HashMap the same mappings as this Map"
    }]
}, {
    "name": "int",
    "description": "\nDatatype for integers, numbers without a decimal point. Integers can be as large as 2,147,483,647 and as low as -2,147,483,648. They are stored as 32 bits of information. The first time a variable is written, it must be declared with a statement expressing its datatype. Subsequent uses of this variable must not reference the datatype because Processing will think the variable is being declared again.\n",
    "syntax": "\nint var\nint var = value\n",
    "returns": "",
    "examples": ["\nint a;          // Declare variable 'a' of type int\na = 23;         // Assign 'a' the value 23\nint b = -256;   // Declare variable 'b' and assign it the value -256\nint c = a + b;  // Declare variable 'c' and assign it the sum of 'a' and 'b'\n"],
    "examples_img": [],
    "parameters": [{
        "name": "var",
        "description": "variable name referencing the value"
    }, {
        "name": "value",
        "description": "any integer value"
    }]
}, {
    "name": "requestImage()",
    "description": "\nThis function loads images on a separate thread so that your sketch doesn't freeze while images load during setup(). While the image is loading, its width and height will be 0. If an error occurs while loading the image, its width and height will be set to -1. You'll know when the image has loaded properly because its width and height will be greater than 0. Asynchronous image loading (particularly when downloading from a server) can dramatically improve performance.\n\nThe extension parameter is used to determine the image type in cases where the image filename does not end with a proper extension. Specify the extension as the second parameter to requestImage().\n",
    "syntax": "requestImage(filename)\nrequestImage(filename, extension)",
    "returns": "PImage",
    "examples": ["\nPImage bigImage;\n \nvoid setup() {\n  bigImage = requestImage(\"something.jpg\");\n}\n \nvoid draw() {\n  if (bigImage.width == 0) {\n    // Image is not yet loaded\n  } else if (bigImage.width == -1) {\n    // This means an error occurred during image loading\n  } else {\n    // Image is ready to go, draw it\n    image(bigImage, 0, 0);\n  }\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "filename",
        "description": "String: name of the file to load, can be .gif, .jpg, .tga, or a handful of other image types depending on your platform"
    }, {
        "name": "extension",
        "description": "String: the type of image to load, for example \"png\", \"gif\", \"jpg\""
    }]
}, {
    "name": "selectFolder()",
    "description": "\nOpens a platform-specific file chooser dialog to select a folder. After the selection is made, the selection will be passed to the 'callback' function. If the dialog is closed or canceled, null will be sent to the function, so that the program is not waiting for additional input. The callback is necessary because of how threading works.\n",
    "syntax": "selectFolder(prompt, callback)\nselectFolder(prompt, callback, file)\nselectFolder(prompt, callback, file, callbackObject)\nselectFolder(prompt, callbackMethod, defaultSelection, callbackObject, parentFrame)",
    "returns": "void",
    "examples": ["\nvoid setup() {\n  selectFolder(\"Select a folder to process:\", \"folderSelected\");\n}\n\nvoid folderSelected(File selection) {\n  if (selection == null) {\n    println(\"Window was closed or the user hit cancel.\");\n  } else {\n    println(\"User selected \" + selection.getAbsolutePath());\n  }\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "prompt",
        "description": "String: message to the user"
    }, {
        "name": "callback",
        "description": "String: name of the method to be called when the selection is made"
    }]
}, {
    "name": "tint()",
    "description": "\nSets the fill value for displaying images. Images can be tinted to specified colors or made transparent by including an alpha value. \n\nTo apply transparency to an image without affecting its color, use white as the tint color and specify an alpha value. For instance, tint(255, 128) will make an image 50% transparent (assuming the default alpha range of 0-255, which can be changed with colorMode()).\n\nWhen using hexadecimal notation to specify a color, use \"#\" or \"0x\" before the values (e.g., #CCFFAA or 0xFFCCFFAA). The # syntax uses six digits to specify a color (just as colors are typically specified in HTML and CSS). When using the hexadecimal notation starting with \"0x\", the hexadecimal value must be specified with eight characters; the first two characters define the alpha component, and the remainder define the red, green, and blue components. \n\nThe value for the gray parameter must be less than or equal to the current maximum value as specified by colorMode(). The default maximum value is 255.\n\nThe tint() function is also used to control the coloring of textures in 3D. \n",
    "syntax": "tint(rgb)\ntint(rgb, alpha)\ntint(gray)\ntint(gray, alpha)\ntint(v1, v2, v3)\ntint(v1, v2, v3, alpha)",
    "returns": "void",
    "examples": ["\nPImage img;\nimg = loadImage(\"laDefense.jpg\");\nimage(img, 0, 0);\ntint(0, 153, 204);  // Tint blue\nimage(img, 50, 0);\n", "\nPImage img;\nimg = loadImage(\"laDefense.jpg\");\nimage(img, 0, 0);\ntint(0, 153, 204, 126);  // Tint blue and set transparency\nimage(img, 50, 0);\n", "\nPImage img;\nimg = loadImage(\"laDefense.jpg\");\nimage(img, 0, 0);\ntint(255, 126);  // Apply transparency without changing color\nimage(img, 50, 0);\n"],
    "examples_img": ["https://www.processing.org/reference/images/tint_0.png", "https://www.processing.org/reference/images/tint_1.png", "https://www.processing.org/reference/images/tint_2.png"],
    "parameters": [{
        "name": "rgb",
        "description": "int: color value in hexadecimal notation"
    }, {
        "name": "alpha",
        "description": "float: opacity of the image"
    }, {
        "name": "gray",
        "description": "float: specifies a value between white and black"
    }, {
        "name": "v1",
        "description": "float: red or hue value (depending on current color mode)"
    }, {
        "name": "v2",
        "description": "float: green or saturation value (depending on current color mode)"
    }, {
        "name": "v3",
        "description": "float: blue or brightness value (depending on current color mode)"
    }]
}, {
    "name": "noTint()",
    "description": "\nRemoves the current fill value for displaying images and reverts to displaying images with their original hues.\n",
    "syntax": "noTint()",
    "returns": "void",
    "examples": ["\nPImage img;\nimg = loadImage(\"laDefense.jpg\");\ntint(0, 153, 204);  // Tint blue\nimage(img, 0, 0);\nnoTint();  // Disable tint\nimage(img, 50, 0);\n"],
    "examples_img": ["https://www.processing.org/reference/images/noTint_.png"],
    "parameters": []
}, {
    "name": "noSmooth()",
    "description": "\nDraws all geometry with jagged (aliased) edges.  Note that smooth() is active by default, so it is necessary to call noSmooth() to disable smoothing of geometry, images, and fonts.\n",
    "syntax": "noSmooth()",
    "returns": "void",
    "examples": ["\nbackground(0);\nnoStroke();\nsmooth();\nellipse(30, 48, 36, 36);\nnoSmooth();\nellipse(70, 48, 36, 36);\n"],
    "examples_img": ["https://www.processing.org/reference/images/noSmooth_.png"],
    "parameters": []
}, {
    "name": "PrintWriter",
    "description": "\nAllows characters to print to a text-output stream. A new PrintWriter object is created with the createWriter() function. For the file to be made correctly, it should be flushed and must be closed with its flush() and close() methods (see above example). \n",
    "syntax": "",
    "returns": "",
    "examples": ["\nPrintWriter output;\n\nvoid setup() {\n  // Create a new file in the sketch directory\n  output = createWriter(\"positions.txt\"); \n}\n\nvoid draw() {\n  point(mouseX, mouseY);\n  output.println(mouseX);  // Write the coordinate to the file\n}\n\nvoid keyPressed() {\n  output.flush();  // Writes the remaining data to the file\n  output.close();  // Finishes the file\n  exit();  // Stops the program\n}\n\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "get()",
    "description": "\nReads the color of any pixel or grabs a section of an image. If no parameters are specified, the entire image is returned. Use the x and y parameters to get the value of one pixel. Get a section of the display window by specifying additional w and h parameters. When getting an image, the x and y parameters define the coordinates for the upper-left corner of the image, regardless of the current imageMode().\n\nIf the pixel requested is outside of the image window, black is returned. The numbers returned are scaled according to the current color ranges, but only RGB values are returned by this function. For example, even though you may have drawn a shape with colorMode(HSB), the numbers returned will be in RGB format.\n\nGetting the color of a single pixel with get(x, y) is easy, but not as fast as grabbing the data directly from pixels[]. The equivalent statement to get(x, y) using pixels[] is pixels[y*width+x]. See the reference for pixels[] for more information.\n",
    "syntax": "get(x, y)\nget(x, y, w, h)\nget()",
    "returns": "int or PImage",
    "examples": ["\nPImage myImage = loadImage(\"apples.jpg\");\nimage(myImage, 0, 0);\nPImage c = get();\nimage(c, width/2, 0);\n", "\nPImage myImage = loadImage(\"apples.jpg\");\nimage(myImage, 0, 0);\ncolor c = get(25, 25);\nfill(c);\nnoStroke();\nrect(25, 25, 50, 50);\n"],
    "examples_img": ["https://www.processing.org/reference/images/get_0.png", "https://www.processing.org/reference/images/get_1.png"],
    "parameters": [{
        "name": "x",
        "description": "int: x-coordinate of the pixel"
    }, {
        "name": "y",
        "description": "int: y-coordinate of the pixel"
    }, {
        "name": "w",
        "description": "int: width of pixel rectangle to get"
    }, {
        "name": "h",
        "description": "int: height of pixel rectangle to get"
    }]
}, {
    "name": "+= (add assign)",
    "description": "\nCombines addition with assignment. The expression a += b is equivalent to a = a + b. \n",
    "syntax": "\nvalue1 += value2\n",
    "returns": "",
    "examples": ["\nint a = 50;\nint b = 23;\na += b;  // Sets 'a' to 73\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1",
        "description": "int or float"
    }, {
        "name": "value2",
        "description": "any numerical value the same datatype as value1"
    }]
}, {
    "name": "/* */ (multiline comment)",
    "description": "\nExplanatory notes embedded within the code. Comments are used to remind yourself and to inform others about the function of your program. Multiline comments are used for large text descriptions of code or to comment out chunks of code while debugging applications. Comments are ignored by the compiler\n",
    "syntax": "\n/*\n  comment\n*/\n",
    "returns": "",
    "examples": ["\n/*\n   Draws two lines which divides the window \n   into four quadrants. First draws a horizontal\n   line and then the vertical line \n*/ \nline(0, 50, 100, 50);\nline(50, 0, 50, 100);\n"],
    "examples_img": [],
    "parameters": [{
        "name": "comment",
        "description": "any sequence of characters"
    }]
}, {
    "name": "setup()",
    "description": "\nThe setup() function is called once when the program starts. It's used to define initial \nenviroment properties such as screen size and background color and to load media such as images\nand fonts as the program starts. There can only be one setup() function for each program and \nit shouldn't be called again after its initial execution. Note: Variables declared within \nsetup() are not accessible within other functions, including draw(). \n",
    "syntax": "setup()",
    "returns": "void",
    "examples": ["\nvoid setup() {\n  size(200, 200);\n  background(0);\n  noStroke();\n  fill(102);\n}\n\nint a = 0;\n\nvoid draw() {\n  rect(a++%width, 10, 2, 80); \n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "|| (logical OR)",
    "description": "\nCompares two expressions and returns true if one or both evaluate to true. Returns false only if both expressions are false. The following list shows all possible combinations:true || false   // Evaluates true because the first is true false || true   // Evaluates true because the second is true true || true    // Evaluates true because both are true false || false  // Evaluates false because both are false \n",
    "syntax": "\nexpression1 || expression2\n",
    "returns": "",
    "examples": ["\nfor (int i = 5 ; i  60)) {\n    line(30, i, 80, i);\n  }\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/logicalOR.png"],
    "parameters": [{
        "name": "expression1",
        "description": "any valid expression"
    }, {
        "name": "expression2",
        "description": "any valid expression"
    }]
}, {
    "name": "char()",
    "description": "\nConverts any value of a primitive data type (boolean, byte, char, color, double, float, int, or long) to its numeric character representation.\n\nWhen an array of values is passed in, then a char array of the same length is returned.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nint i = 65;\nchar c = char(i);\nprintln(i + \" : \" + c);  // Prints \"65 : A\"\n\nbyte b = 65;\nc = char(b);\nprintln(b + \" : \" + c);  // Prints \"65 : A\"\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "hour()",
    "description": "\nProcessing communicates with the clock on your computer. The hour() function returns the current hour as a value from 0 - 23.\n",
    "syntax": "hour()",
    "returns": "int",
    "examples": ["\nvoid draw() {\n  background(204);\n  int s = second();  // Values from 0 - 59\n  int m = minute();  // Values from 0 - 59\n  int h = hour();    // Values from 0 - 23\n  line(s, 0, s, 33);\n  line(m, 33, m, 66);\n  line(h, 66, h, 100);\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "& (bitwise AND)",
    "description": "\nCompares each corresponding bit in the binary representation of the values. For each comparison two 1's yield 1, 1 and 0 yield 0, and two 0's yield 0. This is easy to see when we look at the binary representation of numbers\n\n  11010110  // 214\n& 01011100  // 92\n  --------\n  01010100  // 84\n\nTo see the binary representation of a number, use the binary() function with println().\n",
    "syntax": "value & value2",
    "returns": "",
    "examples": ["\nint a = 207;    // In binary: 11001111\nint b = 61;     // In binary: 00111101\nint c = a & b; // In binary: 00001101\nprintln(c);     // Prints \"13\", the decimal equivalent to 00001101\n", "\ncolor argb = color(204, 204, 51, 255);\n// The sytax \"& 0xFF\" compares the binary\n// representation of the two values and\n// makes all but the last 8 bits into a 0.\n// \"0xFF\" is 00000000000000000000000011111111\nint a = argb >> 24 & 0xFF;\nint r = argb >> 16 & 0xFF;\nint g = argb >> 8 & 0xFF;\nint b = argb & 0xFF;\nfill(r, g, b, a);\nrect(30, 20, 55, 55);\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1",
        "description": "int, char, byte"
    }, {
        "name": "value2",
        "description": "int, char, byte"
    }]
}, {
    "name": "endCamera()",
    "description": "\nThe beginCamera() and endCamera() functions enable advanced customization of the camera space. Please see the reference for beginCamera() for a description of how the functions are used.\n",
    "syntax": "endCamera()",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nnoFill();\n\nbeginCamera();\ncamera();\nrotateX(-PI/6);\nendCamera();\n\ntranslate(50, 50, 0);\nrotateY(PI/3);\nbox(45);\n"],
    "examples_img": ["https://www.processing.org/reference/images/endCamera_.png"],
    "parameters": []
}, {
    "name": "popStyle()",
    "description": "\nThe pushStyle() function saves the current style settings and popStyle() restores the prior settings; these functions are always used together. They allow you to change the style settings and later return to what you had. When a new style is started with pushStyle(), it builds on the current style information. The pushStyle() and popStyle() functions can be embedded to provide more control (see the second example above for a demonstration.)\n",
    "syntax": "popStyle()",
    "returns": "void",
    "examples": ["\nellipse(0, 50, 33, 33);  // Left circle\n\npushStyle();  // Start a new style\nstrokeWeight(10);\nfill(204, 153, 0);\nellipse(50, 50, 33, 33);  // Middle circle\npopStyle();  // Restore original style\n\nellipse(100, 50, 33, 33);  // Right circle\n", "\nellipse(0, 50, 33, 33);  // Left circle\n\npushStyle();  // Start a new style\nstrokeWeight(10);\nfill(204, 153, 0);\nellipse(33, 50, 33, 33);  // Left-middle circle\n\npushStyle();  // Start another new style\nstroke(0, 102, 153);\nellipse(66, 50, 33, 33);  // Right-middle circle\npopStyle();  // Restore the previous style\n\npopStyle();  // Restore original style\n\nellipse(100, 50, 33, 33);  // Right circle\n"],
    "examples_img": ["https://www.processing.org/reference/images/popStyle_0.png", "https://www.processing.org/reference/images/popStyle_1.png"],
    "parameters": []
}, {
    "name": "mouseWheel()",
    "description": "\nThe mouseWheel() function returns positive values when the mouse wheel is rotated down (toward the user), and negative values for the other direction (up or away from the user). On OS X with \"natural\" scrolling enabled, the values are opposite.\n\nMouse and keyboard events only work when a program has draw(). Without draw(), the code is only run once and then stops listening for events.\n",
    "syntax": "mouseWheel(event)",
    "returns": "void",
    "examples": ["\nvoid setup() {\n  size(100, 100);\n}\n\nvoid draw() {} \n\nvoid mouseWheel(MouseEvent event) {\n  float e = event.getCount();\n  println(e);\n}\n\n"],
    "examples_img": [],
    "parameters": [{
        "name": "event",
        "description": "MouseEvent: the MouseEvent"
    }]
}, {
    "name": "frameCount",
    "description": "\nThe system variable frameCount contains the number of frames that have been displayed since the program started. Inside setup() the value is 0, after the first iteration of draw it is 1, etc.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nvoid setup() {\n  frameRate(30);\n}\n\nvoid draw() {\n  line(0, 0, width, height);\n  println(frameCount);\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "mouseY",
    "description": "\nThe system variable mouseY always contains the current vertical coordinate of the mouse.\n\nNote that Processing can only track the mouse position when the pointer is over the current window. The default value of mouseY is 0, so 0 will be returned until the mouse moves in front of the sketch window. (This typically happens when a sketch is first run.)  Once the mouse moves away from the window, mouseY will continue to report its most recent position.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nvoid draw() {\n  background(204);\n  line(20, mouseY, 80, mouseY);\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "/ (divide)",
    "description": "\nDivides the value of the first parameter by the value of the second parameter. The answer to the equation 20 / 4 is 5. The number 20 is the sum of four occurences of the number 5. As an equation we see that 5 + 5 + 5 + 5 = 20.\n",
    "syntax": "\nvalue1 / value2\n",
    "returns": "",
    "examples": ["\nint g = 50 / 5;  // Assigns 10 to 'g'\nint h = g / 5;   // Assigns 2 to 'h'\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1",
        "description": "int or float"
    }, {
        "name": "value2",
        "description": "int or float, but not zero (it is not possible  divide by zero)"
    }]
}, {
    "name": "dist()",
    "description": "\nCalculates the distance between two points.\n",
    "syntax": "dist(x1, y1, x2, y2)\ndist(x1, y1, z1, x2, y2, z2)",
    "returns": "float",
    "examples": ["\n// Sets the background gray value based on the distance \n// of the mouse from the center of the screen\nvoid draw() {\n  noStroke();\n  float d = dist(width/2, height/2, mouseX, mouseY);\n  float maxDist = dist(0, 0, width/2, height/2);\n  float gray = map(d, 0, maxDist, 0, 255);\n  fill(gray);\n  rect(0, 0, width, height);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "x1",
        "description": "float: x-coordinate of the first point"
    }, {
        "name": "y1",
        "description": "float: y-coordinate of the first point"
    }, {
        "name": "z1",
        "description": "float: z-coordinate of the first point"
    }, {
        "name": "x2",
        "description": "float: x-coordinate of the second point"
    }, {
        "name": "y2",
        "description": "float: y-coordinate of the second point"
    }, {
        "name": "z2",
        "description": "float: z-coordinate of the second point"
    }]
}, {
    "name": "bezier()",
    "description": "\nDraws a Bezier curve on the screen. These curves are defined by a series of anchor and control points. The first two parameters specify the first anchor point and the last two parameters specify the other anchor point. The middle parameters specify the control points which define the shape of the curve. Bezier curves were developed by French engineer Pierre Bezier. Using the 3D version requires rendering with P3D (see the Environment reference for more information).\n",
    "syntax": "bezier(x1, y1, x2, y2, x3, y3, x4, y4)\nbezier(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4)",
    "returns": "void",
    "examples": ["\nnoFill();\nstroke(255, 102, 0);\nline(85, 20, 10, 10);\nline(90, 90, 15, 80);\nstroke(0, 0, 0);\nbezier(85, 20, 10, 10, 90, 90, 15, 80);\n", "\nnoFill();\nstroke(255, 102, 0);\nline(30, 20, 80, 5);\nline(80, 75, 30, 75);\nstroke(0, 0, 0);\nbezier(30, 20,  80, 5,  80, 75,  30, 75);\n"],
    "examples_img": ["https://www.processing.org/reference/images/bezier_0.png", "https://www.processing.org/reference/images/bezier_1.png"],
    "parameters": [{
        "name": "x1",
        "description": "float: coordinates for the first anchor point"
    }, {
        "name": "y1",
        "description": "float: coordinates for the first anchor point"
    }, {
        "name": "z1",
        "description": "float: coordinates for the first anchor point"
    }, {
        "name": "x2",
        "description": "float: coordinates for the first control point"
    }, {
        "name": "y2",
        "description": "float: coordinates for the first control point"
    }, {
        "name": "z2",
        "description": "float: coordinates for the first control point"
    }, {
        "name": "x3",
        "description": "float: coordinates for the second control point"
    }, {
        "name": "y3",
        "description": "float: coordinates for the second control point"
    }, {
        "name": "z3",
        "description": "float: coordinates for the second control point"
    }, {
        "name": "x4",
        "description": "float: coordinates for the second anchor point"
    }, {
        "name": "y4",
        "description": "float: coordinates for the second anchor point"
    }, {
        "name": "z4",
        "description": "float: coordinates for the second anchor point"
    }]
}, {
    "name": "arc()",
    "description": "\nDraws an arc to the screen. Arcs are drawn along the outer edge of an ellipse defined by the a, b, c, and d parameters. The origin of the arc's ellipse may be changed with the ellipseMode() function. Use the start and stop parameters to specify the angles (in radians) at which to draw the arc.\n\nThere are three ways to draw an arc; the rendering technique used is defined by the optional seventh paramter. The three options, depicted in the above examples, are PIE, OPEN, and CHORD. The default mode is the OPEN stroke with a PIE fill.\n",
    "syntax": "arc(a, b, c, d, start, stop)\narc(a, b, c, d, start, stop, mode)",
    "returns": "void",
    "examples": ["\narc(50, 55, 50, 50, 0, HALF_PI);\nnoFill();\narc(50, 55, 60, 60, HALF_PI, PI);\narc(50, 55, 70, 70, PI, PI+QUARTER_PI);\narc(50, 55, 80, 80, PI+QUARTER_PI, TWO_PI);\n", "\narc(50, 50, 80, 80, 0, PI+QUARTER_PI, OPEN);\n", "\narc(50, 50, 80, 80, 0, PI+QUARTER_PI, CHORD);\n", "\narc(50, 50, 80, 80, 0, PI+QUARTER_PI, PIE);\n"],
    "examples_img": ["https://www.processing.org/reference/images/arc_.png", "https://www.processing.org/reference/images/arc_2.png", "https://www.processing.org/reference/images/arc_3.png", "https://www.processing.org/reference/images/arc_4.png"],
    "parameters": [{
        "name": "a",
        "description": "float: x-coordinate of the arc's ellipse"
    }, {
        "name": "b",
        "description": "float: y-coordinate of the arc's ellipse"
    }, {
        "name": "c",
        "description": "float: width of the arc's ellipse by default"
    }, {
        "name": "d",
        "description": "float: height of the arc's ellipse by default"
    }, {
        "name": "start",
        "description": "float: angle to start the arc, specified in radians"
    }, {
        "name": "stop",
        "description": "float: angle to stop the arc, specified in radians"
    }]
}, {
    "name": "quad()",
    "description": "\nA quad is a quadrilateral, a four sided polygon. It is similar to a rectangle, but the angles between its edges are not constrained to ninety degrees. The first pair of parameters (x1,y1) sets the first vertex and the subsequent pairs should proceed clockwise or counter-clockwise around the defined shape.\n",
    "syntax": "quad(x1, y1, x2, y2, x3, y3, x4, y4)",
    "returns": "void",
    "examples": ["\nquad(38, 31, 86, 20, 69, 63, 30, 76);\n"],
    "examples_img": ["https://www.processing.org/reference/images/quad_.png"],
    "parameters": [{
        "name": "x1",
        "description": "float: x-coordinate of the first corner"
    }, {
        "name": "y1",
        "description": "float: y-coordinate of the first corner"
    }, {
        "name": "x2",
        "description": "float: x-coordinate of the second corner"
    }, {
        "name": "y2",
        "description": "float: y-coordinate of the second corner"
    }, {
        "name": "x3",
        "description": "float: x-coordinate of the third corner"
    }, {
        "name": "y3",
        "description": "float: y-coordinate of the third corner"
    }, {
        "name": "x4",
        "description": "float: x-coordinate of the fourth corner"
    }, {
        "name": "y4",
        "description": "float: y-coordinate of the fourth corner"
    }]
}, {
    "name": "sort()",
    "description": "\nSorts an array of numbers from smallest to largest, or puts an array of words in alphabetical order. The original array is not modified; a re-ordered array is returned. The count parameter states the number of elements to sort. For example, if there are 12 elements in an array and count is set to 5, only the first 5 elements in the array will be sorted. \n",
    "syntax": "sort(list)\nsort(list, count)",
    "returns": "byte[], char[], int[], float[], or String[]",
    "examples": ["\nfloat[] a = { 3.4, 3.6, 2, 0, 7.1 };\na = sort(a);\nprintln(a);\n// Prints the contents of the sorted array:\n// [0] 0.0\n// [1] 2.0\n// [2] 3.4\n// [3] 3.6\n// [4] 7.1\n", "\nString[] s = { \"deer\", \"elephant\", \"bear\", \"aardvark\", \"cat\" };\ns = sort(s);\nprintln(s);\n// Prints the contents of the sorted array:\n// [0] \"aardvark\"\n// [1] \"bear\"\n// [2] \"cat\"\n// [3] \"deer\"\n// [4] \"elephant\"\n", "\nString[] s = { \"deer\", \"elephant\", \"bear\", \"aardvark\", \"cat\" };\ns = sort(s, 3);\nprintln(s);\n// Prints the contents of the array, with the first 3 elements sorted:\n// [0] \"bear\"\n// [1] \"deer\"\n// [2] \"elephant\"\n// [3] \"aardvark\"\n// [4] \"cat\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "list",
        "description": "String[], float[], int[], char[], or byte[]: array to sort"
    }, {
        "name": "count",
        "description": "int: number of elements to sort, starting from 0"
    }]
}, {
    "name": "*= (multiply assign)",
    "description": "\nCombines multiplication with assignment. The expression a *= b is equivalent to a = a * b. \n",
    "syntax": "\nvalue1 *= value2\n",
    "returns": "",
    "examples": ["\nint a = 5;\nint b = 2;\na *= b;  // Sets 'a' to 10\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1",
        "description": "int or float"
    }, {
        "name": "value2",
        "description": "any numerical value the same datatype as value1"
    }]
}, {
    "name": "false",
    "description": "\nReserved word representing the logical value \"false\". Only variables of type boolean may be assigned the value false.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nrect(30, 20, 50, 50);\nboolean b = false;\nif (b == false) {\n  line(20, 10, 90, 80);  // This line is drawn\n} else {\n  line(20, 80, 90, 10);  // This line is not drawn\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "modelZ()",
    "description": "\nReturns the three-dimensional X, Y, Z position in model space. This returns the Z value for a given coordinate based on the current set of transformations (scale, rotate, translate, etc.) The Z value can be used to place an object in space relative to the location of the original point once the transformations are no longer in use.\n\nIn the example, the modelX(), modelY(), and modelZ() functions record the location of a box in space after being placed using a series of translate and rotate commands. After popMatrix() is called, those transformations no longer apply, but the (x, y, z) coordinate returned by the model functions is used to place another box in the same location.\n",
    "syntax": "modelZ(x, y, z)",
    "returns": "float",
    "examples": ["\nvoid setup() {\n  size(500, 500, P3D);\n  noFill();\n}\n\nvoid draw() {\n  background(0);\n \n  pushMatrix();\n  // start at the middle of the screen\n  translate(width/2, height/2, -200);     \n  // some random rotation to make things interesting\n  rotateY(1.0); //yrot);\n  rotateZ(2.0); //zrot);\n  // rotate in X a little more each frame\n  rotateX(frameCount / 100.0);\n  // offset from center\n  translate(0, 150, 0);\n \n  // draw a white box outline at (0, 0, 0)\n  stroke(255);\n  box(50);\n \n  // the box was drawn at (0, 0, 0), store that location\n  float x = modelX(0, 0, 0);\n  float y = modelY(0, 0, 0);\n  float z = modelZ(0, 0, 0);\n  // clear out all the transformations\n  popMatrix();\n\n  // draw another box at the same (x, y, z) coordinate as the other\n  pushMatrix();\n  translate(x, y, z);\n  stroke(255, 0, 0);\n  box(50);\n  popMatrix();\n} \n"],
    "examples_img": [],
    "parameters": [{
        "name": "x",
        "description": "float: 3D x-coordinate to be mapped"
    }, {
        "name": "y",
        "description": "float: 3D y-coordinate to be mapped"
    }, {
        "name": "z",
        "description": "float: 3D z-coordinate to be mapped"
    }]
}, {
    "name": "clear()",
    "description": "\nClears the pixels within a buffer. This function only works on PGraphics objects created with the createGraphics() function; it won't work with the main display window. Unlike the main graphics context (the display window), pixels in additional graphics areas created with createGraphics() can be entirely or partially transparent. This function clears everything to make all of the pixels 100% transparent. \n",
    "syntax": "clear()",
    "returns": "void",
    "examples": ["\nPGraphics pg;\n\nvoid setup() {\n  size(200, 200);\n  pg = createGraphics(100, 100);\n}\n\nvoid draw() {\n  background(204);\n  pg.beginDraw();\n  pg.stroke(0, 102, 153);\n  pg.line(0, 0, mouseX, mouseY);\n  pg.endDraw();\n  image(pg, 50, 50); \n}\n\n// Click to clear the PGraphics object\nvoid mousePressed() {\n  pg.clear();\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": ">= (greater than or equal to)",
    "description": "\nTests if the value on the left is larger than the value on the right or if the values are equivalent. \n",
    "syntax": "\nvalue1 >= value2\n",
    "returns": "",
    "examples": ["\nint a = 23;\nint b = 23;\nif (a >= b) {\n  println(\"variable a is greater or equal to variable b \")\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1",
        "description": "int, float, char, or byte"
    }, {
        "name": "value2",
        "description": "int, float, char, or byte"
    }]
}, {
    "name": "unbinary()",
    "description": "\nConverts a String representation of a binary number to its equivalent integer value. For example, unbinary(\"00001000\") will return 8.\n",
    "syntax": "unbinary(value)",
    "returns": "int",
    "examples": ["\nString s1 = \"00010000\";\nString s2 = \"00001000\";\nString s3 = \"00000100\";\nprintln(unbinary(s1));  // Prints \"16\"\nprintln(unbinary(s2));  // Prints \"8\"\nprintln(unbinary(s3));  // Prints \"4\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value",
        "description": "String: String to convert to an integer"
    }]
}, {
    "name": "floor()",
    "description": "\nCalculates the closest int value that is less than or equal to the value of the parameter.\n",
    "syntax": "floor(n)",
    "returns": "int",
    "examples": ["\nfloat x = 2.88;  \nint a = floor(x);  // Sets 'a' to 2\n"],
    "examples_img": [],
    "parameters": [{
        "name": "n",
        "description": "float: number to round down"
    }]
}, {
    "name": "mouseX",
    "description": "\nThe system variable mouseX always contains the current horizontal coordinate of the mouse.\n\nNote that Processing can only track the mouse position when the pointer is over the current window. The default value of mouseX is 0, so 0 will be returned until the mouse moves in front of the sketch window. (This typically happens when a sketch is first run.)  Once the mouse moves away from the window, mouseX will continue to report its most recent position.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nvoid draw() {\n  background(204);\n  line(mouseX, 20, mouseX, 80);\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "arrayCopy()",
    "description": "\nCopies an array (or part of an array) to another array. The src array is copied to the dst array, beginning at the position specified by srcPosition and into the position specified by dstPosition. The number of elements to copy is determined by length. Note that copying values overwrites existing values in the destination array. To append values instead of overwriting them, use concat().\n\nThe simplified version with only two arguments  arrayCopy(src, dst)  copies an entire array to another of the same size. It is equivalent to arrayCopy(src, 0, dst, 0, src.length).\n\nUsing this function is far more efficient for copying array data than iterating through a for() loop and copying each element individually. This function only copies references, which means that for most purposes it only copies one-dimensional arrays (a single set of brackets). If used with a two (or three or more) dimensional array, it will only copy the references at the first level, because a two dimensional array is simply an \"array of arrays\". This does not produce an error, however, because this is often the desired behavior. Internally, this function calls Java's System.arraycopy() method, so most things that apply there are inherited.\n",
    "syntax": "arrayCopy(src, srcPosition, dst, dstPosition, length)\narrayCopy(src, dst, length)\narrayCopy(src, dst)",
    "returns": "void",
    "examples": ["\nString[] north = { \"OH\", \"IN\", \"MI\" };\nString[] south = { \"GA\", \"FL\", \"NC\" };\narrayCopy(north, south);\nprintln(south);\n// Prints updated array contents to the console:\n// [0] \"OH\"\n// [1] \"IN\"\n// [2] \"MI\"\n", "\nString[] north = { \"OH\", \"IN\", \"MI\"};\nString[] south = { \"GA\", \"FL\", \"NC\"}; \narrayCopy(north, 1, south, 0, 2);\nprintln(south);\n// Prints updated array contents to the console:\n// [0] \"IN\"\n// [1] \"MI\"\n// [2] \"NC\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "src",
        "description": "Object: the source array"
    }, {
        "name": "srcPosition",
        "description": "int: starting position in the source array"
    }, {
        "name": "dst",
        "description": "Object: the destination array of the same data type as the source array"
    }, {
        "name": "dstPosition",
        "description": "int: starting position in the destination array"
    }, {
        "name": "length",
        "description": "int: number of array elements to be copied"
    }]
}, {
    "name": "+ (addition)",
    "description": "\nAdds two values or concatenates string values. As a mathematical operator, it calculates the sum of two values. As a string operator, it combines two strings into one and converts from primitive datatypes into the String datatype if necessary. \n",
    "syntax": "\nvalue1 + value2\n",
    "returns": "",
    "examples": ["\nint a = 50 + 5;  // Sets 'a' to 55\nint b = a + 5;   // Sets 'b' to 60\n", "\nString s1 = \"Chernenko\";\nString s2 = \"Brezhnev\";\nString sc1 = s1 + s2;\nString sc2 = s1 + \", Andropov, \" + s2;\nprintln(sc1);  // Prints \"ChernenkoBrezhnev\"\nprintln(sc2);  // Prints \"Chernenko, Andropov, Brezhnev\"\n", "\nString s1 = \"Gorbachev\";\nint i = 1987;\nString sc1 = s1 + i;\nprintln(sc1);  // Prints \"Gorbachev1987\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1",
        "description": "String, int, float, char, byte, boolean"
    }, {
        "name": "value2",
        "description": "String, int, float, char, byte, boolean"
    }]
}, {
    "name": "IntDict",
    "description": "\nA simple class to use a String as a lookup for an int value. String \"keys\" are associated with integer values.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nIntDict inventory;\n\nvoid setup() {\n  size(200, 200);\n  inventory = new IntDict();\n  inventory.set(\"cd\",84);\n  inventory.set(\"tapes\",15);\n  inventory.set(\"records\",102);\n  println(inventory);\n  noLoop();\n  fill(0);\n  textAlign(CENTER);\n}\n\nvoid draw() {\n  int numRecords = inventory.get(\"records\");\n  text(numRecords, width/2, height/2);\n}\n\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "- (minus)",
    "description": "\nSubtracts one value from another and may also be used to negate a value. As a subtraction operator, the value of the second parameter is subtracted from the first. For example, 5 - 3 yields the number 2. As a negation operator, it is equivalent to multiplying a number by -1. For example, -5 is the same as 5 * -1.  \n",
    "syntax": "\n-value1\nvalue1 - value2\n",
    "returns": "",
    "examples": ["\nint c = 50 - 5;  // Sets 'c' to 45\nint d = c - 5;   // Sets 'd' to 40\nint e = d - 60;  // Sets 'e' to -20\n", "\nint a = 5;         // Sets 'a' to 5 \nint b = -a;        // Sets 'b' to -5 \nint c = -(5 + 3);  // Sets 'c' to -8 \n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1",
        "description": "int or float"
    }, {
        "name": "value2",
        "description": "int or float"
    }]
}, {
    "name": "log()",
    "description": "\nCalculates the natural logarithm (the base-e logarithm) of a number. This function expects the n parameter to be a value greater than 0.0.\n",
    "syntax": "log(n)",
    "returns": "float",
    "examples": ["\nvoid setup() {\n  int i = 12;\n  println(log(i));\n  println(log10(i));\n}\n\n// Calculates the base-10 logarithm of a number\nfloat log10 (int x) {\n  return (log(x) / log(10));\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "n",
        "description": "float: number greater than 0.0"
    }]
}, {
    "name": "line()",
    "description": "\nDraws a line (a direct path between two points) to the screen. The version of line() with four parameters draws the line in 2D.  To color a line, use the stroke() function. A line cannot be filled, therefore the fill() function will not affect the color of a line. 2D lines are drawn with a width of one pixel by default, but this can be changed with the strokeWeight() function. The version with six parameters allows the line to be placed anywhere within XYZ space. Drawing this shape in 3D with the z parameter requires the P3D parameter in combination with size() as shown in the above example.\n",
    "syntax": "line(x1, y1, x2, y2)\nline(x1, y1, z1, x2, y2, z2)",
    "returns": "void",
    "examples": ["\nline(30, 20, 85, 75);\n", "\nline(30, 20, 85, 20);\nstroke(126);\nline(85, 20, 85, 75);\nstroke(255);\nline(85, 75, 30, 75);\n", "\n// Drawing lines in 3D requires P3D\n// as a parameter to size()\nsize(100, 100, P3D);\nline(30, 20, 0, 85, 20, 15);\nstroke(126);\nline(85, 20, 15, 85, 75, 0);\nstroke(255);\nline(85, 75, 0, 30, 75, -50);\n"],
    "examples_img": ["https://www.processing.org/reference/images/line_0.png", "https://www.processing.org/reference/images/line_1.png", "https://www.processing.org/reference/images/line_2.png"],
    "parameters": [{
        "name": "x1",
        "description": "float: x-coordinate of the first point"
    }, {
        "name": "y1",
        "description": "float: y-coordinate of the first point"
    }, {
        "name": "x2",
        "description": "float: x-coordinate of the second point"
    }, {
        "name": "y2",
        "description": "float: y-coordinate of the second point"
    }, {
        "name": "z1",
        "description": "float: z-coordinate of the first point"
    }, {
        "name": "z2",
        "description": "float: z-coordinate of the second point"
    }]
}, {
    "name": "triangle()",
    "description": "\nA triangle is a plane created by connecting three points. The first two arguments specify the first point, the middle two arguments specify the second point, and the last two arguments specify the third point. \n",
    "syntax": "triangle(x1, y1, x2, y2, x3, y3)",
    "returns": "void",
    "examples": ["\ntriangle(30, 75, 58, 20, 86, 75);\n"],
    "examples_img": ["https://www.processing.org/reference/images/triangle_.png"],
    "parameters": [{
        "name": "x1",
        "description": "float: x-coordinate of the first point"
    }, {
        "name": "y1",
        "description": "float: y-coordinate of the first point"
    }, {
        "name": "x2",
        "description": "float: x-coordinate of the second point"
    }, {
        "name": "y2",
        "description": "float: y-coordinate of the second point"
    }, {
        "name": "x3",
        "description": "float: x-coordinate of the third point"
    }, {
        "name": "y3",
        "description": "float: y-coordinate of the third point"
    }]
}, {
    "name": "keyPressed()",
    "description": "\nThe keyPressed() function is called once every time a key is pressed. The key that was pressed is stored in the key variable. \n \nFor non-ASCII keys, use the keyCode variable. The keys included in the ASCII specification (BACKSPACE, TAB, ENTER, RETURN, ESC, and DELETE) do not require checking to see if the key is coded; for those keys, you should simply use the key variable directly (and not keyCode).  If you're making cross-platform projects, note that the ENTER key is commonly used on PCs and Unix, while the RETURN key is used on Macs. Make sure your program will work on all platforms by checking for both ENTER and RETURN.\n \nBecause of how operating systems handle key repeats, holding down a key may cause multiple calls to keyPressed(). The rate of repeat is set by the operating system, and may be configured differently on each computer.\n\nNote that there is a similarly named boolean variable called keyPressed.  See its reference page for more information.\n\nMouse and keyboard events only work when a program has draw(). Without draw(), the code is only run once and then stops listening for events.\n",
    "syntax": "keyPressed()\nkeyPressed(event)",
    "returns": "void",
    "examples": ["\n// Click on the image to give it focus,\n// and then press any key.\n\nint value = 0;\n\nvoid draw() {\n  fill(value);\n  rect(25, 25, 50, 50);\n}\n\nvoid keyPressed() {\n  if (value == 0) {\n    value = 255;\n  } else {\n    value = 0;\n  }\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "| (bitwise OR)",
    "description": "\nCompares each corresponding bit in the binary representation of the values. For each comparison two 1's yield 1, 1 and 0 yield 1, and two 0's yield 0. This is easy to see when we look at the binary representation of numbers\n\n  11010110  // 214\n| 01011100  // 92\n  --------\n  11011110  // 222\n\nTo see the binary representation of a number, use the binary() function with println().\n",
    "syntax": "\nvalue | value2\n",
    "returns": "",
    "examples": ["\nint a = 205;   // In binary: 11001101\nint b = 45;    // In binary: 00101101\nint c = a | b; // In binary: 11101101\nprintln(c);    // Prints \"237\", the decimal equivalent to 11101101\n", "\n\nint a = 255 << 24; // Binary: 11111111000000000000000000000000\nint r = 204 << 16; // Binary: 00000000110011000000000000000000\nint g = 204 << 8;  // Binary  00000000000000001100110000000000\nint b = 51;        // Binary: 00000000000000000000000000110011\n// OR the values together:    11111111110011001100110000110011 \ncolor argb = a | r | g | b; \nfill(argb); \nrect(30, 20, 55, 55); \n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1",
        "description": "int, char, byte"
    }, {
        "name": "value2",
        "description": "int, char, byte"
    }]
}, {
    "name": "mag()",
    "description": "\nCalculates the magnitude (or length) of a vector. A vector is a direction in space commonly used in computer graphics and linear algebra. Because it has no \"start\" position, the magnitude of a vector can be thought of as the distance from the coordinate 0,0 to its x,y value. Therefore, mag() is a shortcut for writing dist(0, 0, x, y). \n",
    "syntax": "mag(a, b)\nmag(a, b, c)",
    "returns": "float",
    "examples": ["\nfloat x1 = 20;\nfloat x2 = 80;\nfloat y1 = 30;\nfloat y2 = 70;\n\nline(0, 0, x1, y1);\nprintln(mag(x1, y1));  // Prints \"36.05551\"\nline(0, 0, x2, y1);\nprintln(mag(x2, y1));  // Prints \"85.44004\"\nline(0, 0, x1, y2);\nprintln(mag(x1, y2));  // Prints \"72.8011\"\nline(0, 0, x2, y2);\nprintln(mag(x2, y2));  // Prints \"106.30146\"\n"],
    "examples_img": ["https://www.processing.org/reference/images/mag_.png"],
    "parameters": [{
        "name": "a",
        "description": "float: first value"
    }, {
        "name": "b",
        "description": "float: second value"
    }, {
        "name": "c",
        "description": "float: third value"
    }]
}, {
    "name": "Object",
    "description": "\nObjects are instances of classes. A class is a grouping of related methods (functions) and fields (variables and constants).\n",
    "syntax": "\nClassName instanceName\n",
    "returns": "",
    "examples": ["\n// Declare and construct two objects (h1, h2) from the class HLine \nHLine h1 = new HLine(20, 2.0); \nHLine h2 = new HLine(50, 2.5); \n \nvoid setup() \n{\n  size(200, 200);\n  frameRate(30);\n}\n\nvoid draw() { \n  background(204);\n  h1.update(); \n  h2.update();  \n} \n \nclass HLine { \n  float ypos, speed; \n  HLine (float y, float s) {  \n    ypos = y; \n    speed = s; \n  } \n  void update() { \n    ypos += speed; \n    if (ypos > width) { \n      ypos = 0; \n    } \n    line(0, ypos, width, ypos); \n  } \n} \n"],
    "examples_img": [],
    "parameters": [{
        "name": "ClassName",
        "description": "the class from which to create the new object"
    }, {
        "name": "instanceName",
        "description": "the name for the new object"
    }]
}, {
    "name": "* (multiply)",
    "description": "\nMultiplies the values of the two parameters. Multiplication is equivalent to a sequence of addition. For example 5 * 4 is equivalent to 5 + 5 + 5 + 5.\n",
    "syntax": "\nvalue1 * value2\n",
    "returns": "",
    "examples": ["\nint e = 50 * 5;  // Sets 'e' to 250\nint f = e * 5;   // Sets 'f' to 1250\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1",
        "description": "int, float, byte, or char"
    }, {
        "name": "value2",
        "description": "int, float, byte, or char"
    }]
}, {
    "name": "char",
    "description": "\nDatatype for characters, typographic symbols such as A, d, and $. A char stores letters and symbols in the Unicode format, a coding system developed to support a variety of world languages. Each char is two bytes (16 bits) in length and is distinguished by surrounding it with single quotes. Character escapes may also stored as a char. For example, the representation for the \"delete\" key is 127. The first time a variable is written, it must be declared with a statement expressing its datatype. Subsequent uses of this variable must not reference the datatype because Processing will think the variable is being declared again.\n",
    "syntax": "\nchar var\nchar var = value\n",
    "returns": "",
    "examples": ["\nchar m;      // Declare variable 'm' of type char\nm = 'A';     // Assign 'm' the value \"A\"\nint n = '&'; // Declare variable 'n' and assign it the value \"&\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "var",
        "description": "variable name referencing the value"
    }, {
        "name": "value",
        "description": "any character"
    }]
}, {
    "name": "matchAll()",
    "description": "\nThis function is used to apply a regular expression to a piece of text, and return a list of matching groups (elements found inside parentheses) as a two-dimensional String array. If there are no matches, a null value will be returned. If no groups are specified in the regular expression, but the sequence matches, a two dimensional array is still returned, but the second dimension is only of length one.\n\nTo use the function, first check to see if the result is null. If the result is null, then the sequence did not match at all. If the sequence did match, a 2D array is returned.\n\nIf there are groups (specified by sets of parentheses) in the regular expression, then the contents of each will be returned in the array. Assuming a loop with counter variable i, element [i][0] of a regular expression match returns the entire matching string, and the match groups start at element [i][1] (the first group is [i][1], the second [i][2], and so on).\n\nThe syntax can be found in the reference for Java's Pattern class. For regular expression syntax, read the Java Tutorial on the topic.\n",
    "syntax": "matchAll(str, regexp)",
    "returns": "String[][]",
    "examples": ["\nString s = \"Inside tags, you will find <tag>multiple</tag> \";\n       s += \"<tag>pieces</tag> of <tag>content</tag>.\";\n\nString[][] m = matchAll(s, \"<tag>(.*?)</tag>\");\nfor (int i = 0; i < m.length; i++) {\n  println(\"Found '\" + m[i][1] + \"' inside a tag.\");\n}\n\n// Prints to the console:\n// \"Found 'multiple' inside a tag.\"\n// \"Found 'pieces' inside a tag.\"\n// \"Found 'content' inside a tag.\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "str",
        "description": "String: the String to be searched"
    }, {
        "name": "regexp",
        "description": "String: the regexp to be used for matching"
    }]
}, {
    "name": ", (comma)",
    "description": "\nSeparates parameters in function calls and elements during assignment.\n",
    "syntax": "\nvalue1, ..., valueN\n",
    "returns": "",
    "examples": ["\n// Comma used to separate a list of variable declarations\nint a=20, b=30, c=80;\n\n// Comma used to separate a list of values assigned to an array\nint[] d = { 20, 60, 80 };\n\n// Comma used to separate a list of parameters passed to a function\nline(a, b, c, b);\nline(d[0], d[1], d[2], d[1]);\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1, ..., valueN",
        "description": "any int, float, byte, boolean, color, char, String"
    }]
}, {
    "name": "<< (left shift)",
    "description": "\nShifts bits to the left. The number to the left of the operator is shifted the number of places specified by the number to the right. Each shift to the left doubles the number, therefore each left shift multiplies the original number by 2. Use the left shift for fast multiplication or to pack a group of numbers together into one larger number. Left shifting only works with integers or numbers which automatically convert to an integer such at byte and char.\n",
    "syntax": "\nvalue << n\n",
    "returns": "",
    "examples": ["\nint m = 1 << 3;   // In binary: 1 to 1000\nprintln(m);  // Prints \"8\"\nint n = 1 << 8;   // In binary: 1 to 100000000\nprintln(n);  // Prints \"256\"\nint o = 2 << 3;   // In binary: 10 to 10000\nprintln(o);  // Prints \"16\"\nint p = 13 << 1;  // In binary: 1101 to 11010\nprintln(p);  // Prints \"26\"\n", "\n// Packs four 8 bit numbers into one 32 bit number\nint a = 255;  // Binary: 00000000000000000000000011111111\nint r = 204;  // Binary: 00000000000000000000000011001100\nint g = 204;  // Binary: 00000000000000000000000011001100\nint b = 51;   // Binary: 00000000000000000000000000110011\na = a << 24;  // Binary: 11111111000000000000000000000000\nr = r << 16;  // Binary: 00000000110011000000000000000000\ng = g << 8;   // Binary: 00000000000000001100110000000000\n\n// Equivalent to \"color argb = color(r, g, b, a)\" but faster\ncolor argb = a | r | g | b;\nfill(argb);\nrect(30, 20, 55, 55);\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value",
        "description": "int: the value to shift"
    }, {
        "name": "n",
        "description": "int: the number of places to shift left"
    }]
}, {
    "name": "PFont",
    "description": "\nPFont is the font class for Processing. To create a font to use with Processing, select \"Create Font...\" from the Tools menu. This will create a font in the format Processing requires and also adds it to the current sketch's data directory. Processing displays fonts using the .vlw font format, which uses images for each letter, rather than defining them through vector data. The loadFont() function constructs a new font and textFont() makes a font active. The list() method creates a list of the fonts installed on the computer, which is useful information to use with the createFont() function for dynamically converting fonts into a format to use with Processing.\n\nTo create a new font dynamically, use the createFont() function. Do not use the syntax new PFont(). \n",
    "syntax": "",
    "returns": "",
    "examples": ["\nPFont font;\n// The font must be located in the sketch's \n// \"data\" directory to load successfully\nfont = loadFont(\"LetterGothicStd-32.vlw\");\ntextFont(font, 32);\ntext(\"word\", 10, 50);\n"],
    "examples_img": ["https://www.processing.org/reference/images/PFont.png"],
    "parameters": []
}, {
    "name": "stroke()",
    "description": "\nSets the color used to draw lines and borders around shapes. This color is either specified in terms of the RGB or HSB color depending on the current colorMode() (the default color space is RGB, with each value in the range from 0 to 255). \n \nWhen using hexadecimal notation to specify a color, use \"#\" or \"0x\" before the values (e.g., #CCFFAA or 0xFFCCFFAA). The # syntax uses six digits to specify a color (just as colors are typically specified in HTML and CSS). When using the hexadecimal notation starting with \"0x\", the hexadecimal value must be specified with eight characters; the first two characters define the alpha component, and the remainder define the red, green, and blue components. \n \nThe value for the gray parameter must be less than or equal to the current maximum value as specified by colorMode(). The default maximum value is 255.\n \nWhen drawing in 2D with the default renderer, you may need hint(ENABLE_STROKE_PURE) to improve drawing quality (at the expense of performance). See the hint() documentation for more details.\n",
    "syntax": "stroke(rgb)\nstroke(rgb, alpha)\nstroke(gray)\nstroke(gray, alpha)\nstroke(v1, v2, v3)\nstroke(v1, v2, v3, alpha)",
    "returns": "void",
    "examples": ["\nstroke(153);\nrect(30, 20, 55, 55);\n", "\nstroke(204, 102, 0);\nrect(30, 20, 55, 55);\n"],
    "examples_img": ["https://www.processing.org/reference/images/stroke_0.png", "https://www.processing.org/reference/images/stroke_1.png"],
    "parameters": [{
        "name": "rgb",
        "description": "int: color value in hexadecimal notation"
    }, {
        "name": "alpha",
        "description": "float: opacity of the stroke"
    }, {
        "name": "gray",
        "description": "float: specifies a value between white and black"
    }, {
        "name": "v1",
        "description": "float: red or hue value (depending on current color mode)"
    }, {
        "name": "v2",
        "description": "float: green or saturation value (depending on current color mode)"
    }, {
        "name": "v3",
        "description": "float: blue or brightness value (depending on current color mode)"
    }]
}, {
    "name": "createFont()",
    "description": "\nDynamically converts a font to the format used by Processing from a .ttf or .otf file inside the sketch's \"data\" folder or a font that's installed elsewhere on the computer. If you want to use a font installed on your computer, use the PFont.list() method to first determine the names for the fonts recognized by the computer and are compatible with this function. Not all fonts can be used and some might work with one operating system and not others. When sharing a sketch with other people or posting it on the web, you may need to include a .ttf or .otf version of your font in the data directory of the sketch because other people might not have the font installed on their computer. Only fonts that can legally be distributed should be included with a sketch.\n\nThe size parameter states the font size you want to generate. The smooth parameter specifies if the font should be antialiased or not. The charset parameter is an array of chars that specifies the characters to generate.\n\nThis function allows Processing to work with the font natively in the default renderer, so the letters are defined by vector geometry and are rendered quickly. In the P2D and P3D renderers, the function sets the project to render the font as a series of small textures. For instance, when using the default renderer, the actual native version of the font will be employed by the sketch, improving drawing quality and performance. With the P2D and P3D renderers, the bitmapped version will be used to improve speed and appearance, but the results are poor when exporting if the sketch does not include the .otf or .ttf file, and the requested font is not available on the machine running the sketch. \n",
    "syntax": "createFont(name, size)\ncreateFont(name, size, smooth)\ncreateFont(name, size, smooth, charset)",
    "returns": "PFont",
    "examples": ["\nPFont myFont;\n\nvoid setup() {\n  size(200, 200);\n  // Uncomment the following two lines to see the available fonts \n  //String[] fontList = PFont.list();\n  //println(fontList);\n  myFont = createFont(\"Georgia\", 32);\n  textFont(myFont);\n  textAlign(CENTER, CENTER);\n  text(\"!@#$%\", width/2, height/2);\n}\n\n"],
    "examples_img": [],
    "parameters": [{
        "name": "name",
        "description": "String: name of the font to load"
    }, {
        "name": "size",
        "description": "float: point size of the font"
    }, {
        "name": "smooth",
        "description": "boolean: true for an antialiased font, false for aliased"
    }, {
        "name": "charset",
        "description": "char[]: array containing characters to be generated"
    }]
}, {
    "name": "texture()",
    "description": "\nSets a texture to be applied to vertex points. The texture() function must be called between beginShape() and endShape() and before any calls to vertex(). This function only works with the P2D and P3D renderers.\n\nWhen textures are in use, the fill color is ignored. Instead, use tint() to specify the color of the texture as it is applied to the shape.\n",
    "syntax": "texture(image)",
    "returns": "void",
    "examples": ["\nsize(100, 100, P3D);\nnoStroke();\nPImage img = loadImage(\"laDefense.jpg\");\nbeginShape();\ntexture(img);\nvertex(10, 20, 0, 0);\nvertex(80, 5, 100, 0);\nvertex(95, 90, 100, 100);\nvertex(40, 95, 0, 100);\nendShape();\n"],
    "examples_img": ["https://www.processing.org/reference/images/texture_.png"],
    "parameters": [{
        "name": "image",
        "description": "PImage: reference to a PImage object"
    }]
}, {
    "name": "blendMode()",
    "description": "\nBlends the pixels in the display window according to a defined mode. There is a choice of the following modes to blend the source pixels (A) with the ones of pixels already in the display window (B). A pixel's final color is the result of applying one of the above blend modes with each channel of (A) and (B) independently. For example, red is compared with red, green with green, and blue with blue.\n\nBLEND - linear interpolation of colours: C = A*factor + B. This is the default blending mode.\n\nADD - additive blending with white clip: C = min(A*factor + B, 255)\n\nSUBTRACT - subtractive blending with black clip: C = max(B - A*factor, 0)\n\nDARKEST - only the darkest colour succeeds: C = min(A*factor, B)\n\nLIGHTEST - only the lightest colour succeeds: C = max(A*factor, B)\n\nDIFFERENCE - subtract colors from underlying image.\n\nEXCLUSION - similar to DIFFERENCE, but less extreme.\n\nMULTIPLY - multiply the colors, result will always be darker.\n\nSCREEN - opposite multiply, uses inverse values of the colors.\n\nREPLACE - the pixels entirely replace the others and don't utilize alpha (transparency) values\n\nFor Processing 2.0, we recommend using blendMode() and not the previous blend() function. However, unlike blend(), the blendMode() function does not support the following: HARD_LIGHT, SOFT_LIGHT, OVERLAY, DODGE, BURN. On older hardware, the LIGHTEST, DARKEST, and DIFFERENCE modes might not be available as well. \n",
    "syntax": "blendMode(mode)",
    "returns": "void",
    "examples": ["\nsize(100, 100);\nbackground(0);\nblendMode(ADD);\nstroke(102);\nstrokeWeight(30);\nline(25, 25, 75, 75);\nline(75, 25, 25, 75);\n", "\nsize(100, 100, P2D);\nblendMode(MULTIPLY);\nstroke(51);\nstrokeWeight(30);\nline(25, 25, 75, 75);\nline(75, 25, 25, 75);\n"],
    "examples_img": [],
    "parameters": [{
        "name": "mode",
        "description": "int: the blending mode to use"
    }]
}, {
    "name": "keyPressed",
    "description": "\nThe boolean system variable keyPressed is true if any key is pressed and false if no keys are pressed.\n\nNote that there is a similarly named function called keyPressed().  See its reference page for more information.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\n// Click on the image to give it focus,\n// and then press any key.\n\n// Note: The rectangle in this example may \n// flicker as the operating system may \n// register a long key press as a repetition\n// of key presses.\n\nvoid draw() {\n  if (keyPressed == true) {\n    fill(0);\n  } else {\n    fill(255);\n  }\n  rect(25, 25, 50, 50);\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "lerp()",
    "description": "\nCalculates a number between two numbers at a specific increment. The amt parameter is the amount to interpolate between the two values where 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is half-way in between, etc. The lerp function is convenient for creating motion along a straight path and for drawing dotted lines.\n",
    "syntax": "lerp(start, stop, amt)",
    "returns": "float",
    "examples": ["\nfloat a = 20;\nfloat b = 80;\nfloat c = lerp(a, b, .2);\nfloat d = lerp(a, b, .5);\nfloat e = lerp(a, b, .8);\nbeginShape(POINTS);\nvertex(a, 50);\nvertex(b, 50);\nvertex(c, 50);\nvertex(d, 50);\nvertex(e, 50);\nendShape();\n", "\nint x1 = 15;\nint y1 = 10;\nint x2 = 80;\nint y2 = 90;\nline(x1, y1, x2, y2);\nfor (int i = 0; i "],
    "examples_img": ["https://www.processing.org/reference/images/lerp_0.png", "https://www.processing.org/reference/images/lerp_1.png"],
    "parameters": [{
        "name": "start",
        "description": "float: first value"
    }, {
        "name": "stop",
        "description": "float: second value"
    }, {
        "name": "amt",
        "description": "float: float between 0.0 and 1.0"
    }]
}, {
    "name": "abs()",
    "description": "\nCalculates the absolute value (magnitude) of a number. The absolute value of a number is always positive.\n",
    "syntax": "abs(n)",
    "returns": "float or int",
    "examples": ["\nint a = abs(153);      // Sets 'a' to 153\nint b = abs(-15);      // Sets 'b' to 15\nfloat c = abs(12.234); // Sets 'c' to 12.234\nfloat d = abs(-9.23);  // Sets 'd' to 9.23 \n"],
    "examples_img": [],
    "parameters": [{
        "name": "n",
        "description": "int, or float: number to compute"
    }]
}, {
    "name": "-= (subtract assign)",
    "description": "\nCombines subtraction with assignment. The expression a -= b is equivalent to a = a - b. \n",
    "syntax": "\nvalue1 -= value2\n",
    "returns": "",
    "examples": ["\nint a = 50;\nint b = 23;\na -= b;  // Sets 'a' to 27\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value1",
        "description": "int or float"
    }, {
        "name": "value2",
        "description": "int or float"
    }]
}, {
    "name": "pmouseX",
    "description": "\nThe system variable pmouseX always contains the horizontal position of the mouse in the frame previous to the current frame.\n\nYou may find that pmouseX and pmouseY have different values when referenced inside of draw() and inside of mouse events like mousePressed() and mouseMoved(). Inside draw(), pmouseX and pmouseY update only once per frame (once per trip through the draw() loop). But inside mouse events, they update each time the event is called. If these values weren't updated immediately during mouse events, then the mouse position would be read only once per frame, resulting in slight delays and choppy interaction. If the mouse variables were always updated multiple times per frame, then something like line(pmouseX, pmouseY, mouseX, mouseY) inside draw() would have lots of gaps, because pmouseX may have changed several times in between the calls to line().\nIf you want values relative to the previous frame, use pmouseX and pmouseY inside draw(). If you want continuous response, use pmouseX and pmouseY inside the mouse event functions.\n",
    "syntax": "",
    "returns": "",
    "examples": ["\n// Move the mouse quickly to see the difference \n// between the current and previous position \nvoid draw() { \n  background(204); \n  line(mouseX, 20, pmouseX, 80); \n  println(mouseX + \" : \" + pmouseX);\n} \n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "rect()",
    "description": "\nDraws a rectangle to the screen. A rectangle is a four-sided shape with every angle at ninety degrees. By default, the first two parameters set the location of the upper-left corner, the third sets the width, and the fourth sets the height. The way these parameters are interpreted, however, may be changed with the rectMode() function.\n\nTo draw a rounded rectangle, add a fifth parameter, which is used as the radius value for all four corners.\n\nTo use a different radius value for each corner, include eight parameters. When using eight parameters, the latter four set the radius of the arc at each corner separately, starting with the top-left corner and moving clockwise around the rectangle.\n\n\n",
    "syntax": "rect(a, b, c, d)\nrect(a, b, c, d, r)\nrect(a, b, c, d, tl, tr, br, bl)",
    "returns": "void",
    "examples": ["\nrect(30, 20, 55, 55);\n", "\nrect(30, 20, 55, 55, 7);\n", "\nrect(30, 20, 55, 55, 3, 6, 12, 18);\n"],
    "examples_img": ["https://www.processing.org/reference/images/rect_0.png", "https://www.processing.org/reference/images/rect_1.png", "https://www.processing.org/reference/images/rect_2.png"],
    "parameters": [{
        "name": "a",
        "description": "float: x-coordinate of the rectangle by default"
    }, {
        "name": "b",
        "description": "float: y-coordinate of the rectangle by default"
    }, {
        "name": "c",
        "description": "float: width of the rectangle by default"
    }, {
        "name": "d",
        "description": "float: height of the rectangle by default"
    }, {
        "name": "r",
        "description": "float: radii for all four corners"
    }, {
        "name": "tl",
        "description": "float: radius for top-left corner"
    }, {
        "name": "tr",
        "description": "float: radius for top-right corner"
    }, {
        "name": "br",
        "description": "float: radius for bottom-right corner"
    }, {
        "name": "bl",
        "description": "float: radius for bottom-left corner"
    }]
}, {
    "name": ">> (right shift)",
    "description": "\nShifts bits to the right. The number to the left of the operator is shifted the number of places specified by the number to the right. Each shift to the right halves the number, therefore each left shift divides the original number by 2. Use the right shift for fast divisions or to extract an individual number from a packed number. Right shifting only works with integers or numbers which automatically convert to an integer such at byte and char.\n \nBit shifting is helpful when using the color data type. A right shift can extract red, green, blue, and alpha values from a color. A left shift can be used to quickly reassemble a color value (more quickly than the color() function).\n",
    "syntax": "\nvalue >> n\n",
    "returns": "",
    "examples": ["\nint m = 8 >> 3;    // In binary: 1000 to 1\nprintln(m);  // Prints \"1\"\nint n = 256 >> 6;  // In binary: 100000000 to 100 \nprintln(n);  // Prints \"4\"\nint o = 16 >> 3;   // In binary: 10000 to 10 \nprintln(o);  // Prints \"2\"\nint p = 26 >> 1;   // In binary: 11010 to 1101 \nprintln(p);  // Prints \"13\"\n", "\n// Using \"right shift\" as a faster technique than red(), green(), and blue()\ncolor argb = color(204, 204, 51, 255);\nint a = (argb >> 24) & 0xFF;\nint r = (argb >> 16) & 0xFF;  // Faster way of getting red(argb)\nint g = (argb >> 8) & 0xFF;   // Faster way of getting green(argb)\nint b = argb & 0xFF;          // Faster way of getting blue(argb)\nfill(r, g, b, a);\nrect(30, 20, 55, 55);\n"],
    "examples_img": [],
    "parameters": [{
        "name": "value",
        "description": "int: the value to shift"
    }, {
        "name": "n",
        "description": "int: the number of places to shift right"
    }]
}, {
    "name": "constrain()",
    "description": "\nConstrains a value to not exceed a maximum and minimum value.\n",
    "syntax": "constrain(amt, low, high)",
    "returns": "float or int",
    "examples": ["\nvoid draw() \n{ \n  background(204);\n  float mx = constrain(mouseX, 30, 70);\n  rect(mx-10, 40, 20, 20);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "amt",
        "description": "int, or float: the value to constrain"
    }, {
        "name": "low",
        "description": "int, or float: minimum limit"
    }, {
        "name": "high",
        "description": "int, or float: maximum limit"
    }]
}, {
    "name": "createGraphics()",
    "description": "\nCreates and returns a new PGraphics object. Use this class if you need to draw into an off-screen graphics buffer. The first two parameters define the width and height in pixels. The third, optional parameter specifies the renderer. It can be defined as P2D, P3D, or PDF. If the third parameter isn't used, the default renderer is set. The PDF renderer requires the filename parameter. \n\nIt's important to consider the renderer used with createGraphics() in relation to the main renderer specified in size(). For example, it's only possible to use P2D or P3D with createGraphics() when one of them is defined in size(). Unlike Processing 1.0, P2D and P3D use OpenGL for drawing, and when using an OpenGL renderer it's necessary for the main drawing surface to be OpenGL-based. If P2D or P3D are used as the renderer in size(), then any of the options can be used with createGraphics(). If the default renderer is used in size(), then only the default or PDF can be used with createGraphics().\n\nIt's important to call any drawing functions between beginDraw() and endDraw() statements. This is also true for any functions that affect drawing, such as smooth() or colorMode(). \n\nUnlike the main drawing surface which is completely opaque, surfaces created with createGraphics() can have transparency. This makes it possible to draw into a graphics and maintain the alpha channel. By using save() to write a PNG or TGA file, the transparency of the graphics object will be honored.\n",
    "syntax": "createGraphics(w, h)\ncreateGraphics(w, h, renderer)\ncreateGraphics(w, h, renderer, path)",
    "returns": "PGraphics",
    "examples": ["\nPGraphics pg;\n\nvoid setup() {\n  size(200, 200);\n  pg = createGraphics(100, 100);\n}\n\nvoid draw() {\n  pg.beginDraw();\n  pg.background(102);\n  pg.stroke(255);\n  pg.line(pg.width*0.5, pg.height*0.5, mouseX, mouseY);\n  pg.endDraw();\n  image(pg, 50, 50); \n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "w",
        "description": "int: width in pixels"
    }, {
        "name": "h",
        "description": "int: height in pixels"
    }, {
        "name": "renderer",
        "description": "String: Either P2D, P3D, or PDF"
    }, {
        "name": "path",
        "description": "String: the name of the file (can be an absolute or relative path)"
    }]
}, {
    "name": "PGraphics",
    "description": "\nMain graphics and rendering context, as well as the base API implementation for processing \"core\". Use this class if you need to draw into an off-screen graphics buffer. A PGraphics object can be constructed with the createGraphics() function. The beginDraw() and endDraw() methods (see above example) are necessary to set up the buffer and to finalize it. The fields and methods for this class are extensive. For a complete list, visit the developer's reference.\n\nTo create a new graphics context, use the createGraphics() function. Do not use the syntax new PGraphics(). \n",
    "syntax": "",
    "returns": "",
    "examples": ["\nPGraphics pg;\n\nvoid setup() {\n  size(100, 100);\n  pg = createGraphics(40, 40);\n}\n\nvoid draw() {\n  pg.beginDraw();\n  pg.background(100);\n  pg.stroke(255);\n  pg.line(20, 20, mouseX, mouseY);\n  pg.endDraw();\n  image(pg, 9, 30); \n  image(pg, 51, 30);\n}\n"],
    "examples_img": [],
    "parameters": []
}, {
    "name": "shader()",
    "description": "\nApplies the shader specified by the parameters. It's compatible with the P2D and P3D renderers, but not with the default renderer.\n",
    "syntax": "shader(shader)\nshader(shader, kind)",
    "returns": "void",
    "examples": ["\nPShader edges;  \nPImage img;\n    \nvoid setup() {\n  size(640, 360, P2D);\n  img = loadImage(\"leaves.jpg\");      \n  edges = loadShader(\"edges.glsl\");\n}\n\nvoid draw() {\n  shader(edges);\n  image(img, 0, 0);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "shader",
        "description": "PShader: name of shader file"
    }, {
        "name": "kind",
        "description": "int: type of shader, either POINTS, LINES, or TRIANGLES"
    }]
}, {
    "name": "textAscent()",
    "description": "\nReturns ascent of the current font at its current size. This information is useful for determining the height of the font above the baseline. For example, adding the textAscent() and textDescent() values will give you the total height of the line.\n",
    "syntax": "textAscent()",
    "returns": "float",
    "examples": ["\nfloat base = height * 0.75;\nfloat scalar = 0.8; // Different for each font\n\ntextSize(32);  // Set initial text size\nfloat a = textAscent() * scalar;  // Calc ascent\nline(0, base-a, width, base-a);\ntext(\"dp\", 0, base);  // Draw text on baseline\n\ntextSize(64);  // Increase text size\na = textAscent() * scalar;  // Recalc ascent\nline(40, base-a, width, base-a);\ntext(\"dp\", 40, base);  // Draw text on baseline\n"],
    "examples_img": ["https://www.processing.org/reference/images/textAscent_.png"],
    "parameters": []
}, {
    "name": "loadShader()",
    "description": "\nLoads a shader into the PShader object. The shader file must be loaded in the sketch's \"data\" folder/directory to load correctly. Shaders are compatible with the P2D and P3D renderers, but not with the default renderer.\n\nAlternatively, the file maybe be loaded from anywhere on the local computer using an absolute path (something that starts with / on Unix and Linux, or a drive letter on Windows), or the filename parameter can be a URL for a file found on a network.\n\nIf the file is not available or an error occurs, null will be returned and an error message will be printed to the console. The error message does not halt the program, however the null value may cause a NullPointerException if your code does not check whether the value returned is null.\n",
    "syntax": "loadShader(fragFilename)\nloadShader(fragFilename, vertFilename)",
    "returns": "PShader",
    "examples": ["\nPShader blur;\n\nvoid setup() {\n  size(640, 360, P2D);\n  // Shaders files must be in the \"data\" folder to load correctly\n  blur = loadShader(\"blur.glsl\"); \n  stroke(0, 102, 153);\n  rectMode(CENTER);\n}\n\nvoid draw() {\n  filter(blur);  \n  rect(mouseX-75, mouseY, 150, 150); \n  ellipse(mouseX+75, mouseY, 150, 150);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "fragFilename",
        "description": "String: name of fragment shader file"
    }, {
        "name": "vertFilename",
        "description": "String: name of vertex shader file"
    }]
}, {
    "name": "image()",
    "description": "\nThe image() function draws an image to the display window. Images must be in the sketch's \"data\" directory to load correctly. Select \"Add file...\" from the \"Sketch\" menu to add the image to the data directory, or just drag the image file onto the sketch window. Processing currently works with GIF, JPEG, and PNG images. \n\nThe img parameter specifies the image to display and by default the a and b parameters define the location of its upper-left corner. The image is displayed at its original size unless the c and d parameters specify a different size. The imageMode() function can be used to change the way these parameters draw the image.\n\nThe color of an image may be modified with the tint() function. This function will maintain transparency for GIF and PNG images.\n",
    "syntax": "image(img, a, b)\nimage(img, a, b, c, d)",
    "returns": "void",
    "examples": ["\nPImage img;\n\nvoid setup() {\n  // Images must be in the \"data\" directory to load correctly\n  img = loadImage(\"laDefense.jpg\");\n}\n\nvoid draw() {\n  image(img, 0, 0);\n}\n", "\nPImage img;\n\nvoid setup() {\n  // Images must be in the \"data\" directory to load correctly\n  img = loadImage(\"laDefense.jpg\");\n}\n\nvoid draw() {\n  image(img, 0, 0);\n  image(img, 0, 0, width/2, height/2);\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/image_0.png", "https://www.processing.org/reference/images/image_1.png"],
    "parameters": [{
        "name": "img",
        "description": "PImage: the image to display"
    }, {
        "name": "a",
        "description": "float: x-coordinate of the image"
    }, {
        "name": "b",
        "description": "float: y-coordinate of the image"
    }, {
        "name": "c",
        "description": "float: width to display the image"
    }, {
        "name": "d",
        "description": "float: height to display the image"
    }]
}, {
    "name": "printArray()",
    "description": "\nThe printArray() function writes array data to the text area of the Processing environment's console. A new line is put between each element of the array. This function can only print one dimensional arrays.\n\nNote that the console is relatively slow. It works well for occasional messages, but does not support high-speed, real-time output (such as at 60 frames per second).\n",
    "syntax": "printArray(what)",
    "returns": "void",
    "examples": ["\nfloat[] f = { 0.3, 0.4, 0.5 };\nprintArray(f);\n\n// The above code prints:\n// [0] 0.3\n// [1] 0.4\n// [2] 0.5\n"],
    "examples_img": [],
    "parameters": [{
        "name": "what",
        "description": "Object: one-dimensional array"
    }]
}, {
    "name": "loadImage()",
    "description": "\nLoads an image into a variable of type PImage. Four types of images ( .gif, .jpg, .tga, .png) images may be loaded. To load correctly, images must be located in the data directory of the current sketch.\n\nIn most cases, load all images in setup() to preload them at the start of the program. Loading images inside draw() will reduce the speed of a program. Images cannot be loaded outside setup() unless they're inside a function that's called after setup() has already run.\n\nAlternatively, the file maybe be loaded from anywhere on the local computer using an absolute path (something that starts with / on Unix and Linux, or a drive letter on Windows), or the filename parameter can be a URL for a file found on a network.\n\nIf the file is not available or an error occurs, null will be returned and an error message will be printed to the console. The error message does not halt the program, however the null value may cause a NullPointerException if your code does not check whether the value returned is null.\n\nThe extension parameter is used to determine the image type in cases where the image filename does not end with a proper extension. Specify the extension as the second parameter to loadImage(), as shown in the third example on this page. Note that CMYK images are not supported. \n\nDepending on the type of error, a PImage object may still be returned, but the width and height of the image will be set to -1. This happens if bad image data is returned or cannot be decoded properly. Sometimes this happens with image URLs that produce a 403 error or that redirect to a password prompt, because loadImage() will attempt to interpret the HTML as image data.\n",
    "syntax": "loadImage(filename)\nloadImage(filename, extension)",
    "returns": "PImage",
    "examples": ["\nPImage img;\nimg = loadImage(\"laDefense.jpg\");\nimage(img, 0, 0);\n", "\nPImage img;\n\nvoid setup() {\n  img = loadImage(\"laDefense.jpg\");\n}\n\nvoid draw() {\n  image(img, 0, 0);\n}\n", "\nPImage webImg;\n\nvoid setup() {\n  String url = \"https://processing.org/img/processing-web.png\";\n  // Load image from a web server\n  webImg = loadImage(url, \"png\");\n}\n\nvoid draw() {\n  background(0);\n  image(webImg, 0, 0);\n}\n"],
    "examples_img": ["https://www.processing.org/reference/images/loadImage_0.png", "https://www.processing.org/reference/images/loadImage_1.png", "https://www.processing.org/reference/images/loadImage_2.png"],
    "parameters": [{
        "name": "filename",
        "description": "String: name of file to load, can be .gif, .jpg, .tga, or a handful of other image types depending on your platform"
    }, {
        "name": "extension",
        "description": "String: type of image to load, for example \"png\", \"gif\", \"jpg\""
    }]
}, {
    "name": "textDescent()",
    "description": "\nReturns descent of the current font at its current size. This information is useful for determining the height of the font below the baseline. For example, adding the textAscent() and textDescent() values will give you the total height of the line.\n",
    "syntax": "textDescent()",
    "returns": "float",
    "examples": ["\nfloat base = height * 0.75;\nfloat scalar = 0.8; // Different for each font\n\ntextSize(32);  // Set initial text size\nfloat a = textDescent() * scalar;  // Calc ascent\nline(0, base+a, width, base+a);\ntext(\"dp\", 0, base);  // Draw text on baseline\n\ntextSize(64);  // Increase text size\na = textDescent() * scalar;  // Recalc ascent\nline(40, base+a, width, base+a);\ntext(\"dp\", 40, base);  // Draw text on baseline\n"],
    "examples_img": ["https://www.processing.org/reference/images/textDescent_.png"],
    "parameters": []
}, {
    "name": "loadFont()",
    "description": "\nLoads a .vlw formatted font into a PFont object. Create a .vlw font by selecting \"Create Font...\" from the Tools menu. This tool creates a texture for each alphanumeric character and then adds them as a .vlw file to the current sketch's data folder. Because the letters are defined as textures (and not vector data) the size at which the fonts are created must be considered in relation to the size at which they are drawn. For example, load a 32pt font if the sketch displays the font at 32 pixels or smaller. Conversely, if a 12pt font is loaded and displayed at 48pts, the letters will be distorted because the program will be stretching a small graphic to a large size.\n\nLike loadImage() and other functions that load data, the loadFont() function should not be used inside draw(), because it will slow down the sketch considerably, as the font will be re-loaded from the disk (or network) on each frame. It's recommended to load files inside setup()\n\nTo load correctly, fonts must be located in the \"data\" folder of the current sketch. Alternatively, the file maybe be loaded from anywhere on the local computer using an absolute path (something that starts with / on Unix and Linux, or a drive letter on Windows), or the filename parameter can be a URL for a file found on a network.\n\nIf the file is not available or an error occurs, null will be returned and an error message will be printed to the console. The error message does not halt the program, however the null value may cause a NullPointerException if your code does not check whether the value returned is null.\n\nUse createFont() (instead of loadFont()) to enable vector data to be used with the default renderer setting. This can be helpful when many font sizes are needed, or when using any renderer based on the default renderer, such as the PDF library. \n",
    "syntax": "loadFont(filename)",
    "returns": "PFont",
    "examples": ["\nPFont font;\n// The font must be located in the sketch's \n// \"data\" directory to load successfully\nfont = loadFont(\"LetterGothicStd-32.vlw\");\ntextFont(font, 32);\ntext(\"word\", 10, 50);\n"],
    "examples_img": ["https://www.processing.org/reference/images/loadFont_.png"],
    "parameters": [{
        "name": "filename",
        "description": "String: name of the font to load"
    }]
}, {
    "name": "PShader",
    "description": "\nThis class encapsulates a GLSL shader program, including a vertex and a fragment shader. It's compatible with the P2D and P3D renderers, but not with the default renderer. Use the loadShader() function to load your shader code. [Note: It's strongly encouraged to use loadShader() to create a PShader object, rather than calling the PShader constructor manually.]\n",
    "syntax": "",
    "returns": "",
    "examples": ["\nPShader blur;\n\nvoid setup() {\n  size(640, 360, P2D);\n  // Shaders files must be in the \"data\" folder to load correctly\n  blur = loadShader(\"blur.glsl\"); \n  stroke(0, 102, 153);\n  rectMode(CENTER);\n}\n\nvoid draw() {\n  filter(blur);  \n  rect(mouseX-75, mouseY, 150, 150); \n  ellipse(mouseX+75, mouseY, 150, 150);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "parent",
        "description": "PApplet: the parent program"
    }, {
        "name": "vertFilename",
        "description": "String: name of the vertex shader"
    }, {
        "name": "fragFilename",
        "description": "String: name of the fragment shader"
    }, {
        "name": "vertURL",
        "description": "URL: network location of the vertex shader"
    }, {
        "name": "fragURL",
        "description": "URL: network location of the fragment shader"
    }]
}, {
    "name": "resetShader()",
    "description": "\nRestores the default shaders. Code that runs after resetShader() will not be affected by previously defined shaders.\n",
    "syntax": "resetShader()\nresetShader(kind)",
    "returns": "void",
    "examples": ["\nPShader edges;  \nPImage img;\n    \nvoid setup() {\n  size(640, 360, P2D);\n  img = loadImage(\"leaves.jpg\");      \n  edges = loadShader(\"edges.glsl\");\n}\n\nvoid draw() {\n  shader(edges);\n  image(img, 0, 0);\n  resetShader();\n  image(img, width/2, 0);\n}\n"],
    "examples_img": [],
    "parameters": [{
        "name": "kind",
        "description": "int: type of shader, either POINTS, LINES, or TRIANGLES"
    }]
}, {
    "name": "text()",
    "description": "\nDraws text to the screen. Displays the information specified in the first parameter on the screen in the position specified by the additional parameters. A default font will be used unless a font is set with the textFont() function and a default size will be used unless a font is set with textSize(). Change the color of the text with the fill() function. The text displays in relation to the textAlign() function, which gives the option to draw to the left, right, and center of the coordinates.\n\nThe x2 and y2 parameters define a rectangular area to display within and may only be used with string data. When these parameters are specified, they are interpreted based on the current rectMode() setting. Text that does not fit completely within the rectangle specified will not be drawn to the screen.\n\nNote that Processing now lets you call text() without first specifying a PFont with textFont(). In that case, a generic sans-serif font will be used instead. (See the third example above.)\n",
    "syntax": "text(c, x, y)\ntext(c, x, y, z)\ntext(str, x, y)\ntext(chars, start, stop, x, y)\ntext(str, x, y, z)\ntext(chars, start, stop, x, y, z)\ntext(str, x1, y1, x2, y2)\ntext(num, x, y)\ntext(num, x, y, z)",
    "returns": "void",
    "examples": ["\ntextSize(32);\ntext(\"word\", 10, 30); \nfill(0, 102, 153);\ntext(\"word\", 10, 60);\nfill(0, 102, 153, 51);\ntext(\"word\", 10, 90); \n", "\nsize(100, 100, P3D);\ntextSize(32);\nfill(0, 102, 153, 204);\ntext(\"word\", 12, 45, -30);  // Specify a z-axis value\ntext(\"word\", 12, 60);  // Default depth, no z-value specified\n", "\nString s = \"The quick brown fox jumped over the lazy dog.\";\nfill(50);\ntext(s, 10, 10, 70, 80);  // Text wraps within text box\n"],
    "examples_img": ["https://www.processing.org/reference/images/text_0.png", "https://www.processing.org/reference/images/text_1.png", "https://www.processing.org/reference/images/text_2.png"],
    "parameters": [{
        "name": "c",
        "description": "char: the alphanumeric character to be displayed"
    }, {
        "name": "x",
        "description": "float: x-coordinate of text"
    }, {
        "name": "y",
        "description": "float: y-coordinate of text"
    }, {
        "name": "z",
        "description": "float: z-coordinate of text"
    }, {
        "name": "chars",
        "description": "char[]: the alphanumberic symbols to be displayed"
    }, {
        "name": "start",
        "description": "int: array index at which to start writing characters"
    }, {
        "name": "stop",
        "description": "int: array index at which to stop writing characters"
    }, {
        "name": "x1",
        "description": "float: by default, the x-coordinate of text, see rectMode() for more info"
    }, {
        "name": "y1",
        "description": "float: by default, the x-coordinate of text, see rectMode() for more info"
    }, {
        "name": "x2",
        "description": "float: by default, the width of the text box, see rectMode() for more info"
    }, {
        "name": "y2",
        "description": "float: by default, the height of the text box, see rectMode() for more info"
    }, {
        "name": "num",
        "description": "int, or float: the numeric value to be displayed"
    }]
}, {
    "name": "print()",
    "description": "\nThe print() function writes to the console area, the black rectangle at the bottom of the Processing environment. This function is often helpful for looking at the data a program is producing. The companion function println() works like print(), but creates a new line of text for each call to the function. More than one parameter can be passed into the function by separating them with commas. Alternatively, individual elements can be separated with quotes (\"\") and joined with the addition operator (+).\n\nUsing print() on an object will output null, a memory location that may look like \"@10be08,\" or the result of the toString() method from the object that's being printed. Advanced users who want more useful output when calling print() on their own classes can add a toString() method to the class that returns a String.\n\nNote that the console is relatively slow. It works well for occasional messages, but does not support high-speed, real-time output (such as at 60 frames per second).\n",
    "syntax": "print(what)\nprint(variables)",
    "returns": "void",
    "examples": ["\nString s = \"The size is \";\nint w = 1920;\nint h = 1080;\nprint(s);\nprint(w, \"x\", h);\n\n// This program writes to the console:\n// The size is 1920 x 1080\n", "\nprint(\"begin- \");\nfloat f = 0.3;\nint i = 1024;\nprint(\"f is \" + f + \" and i is \" + 1024);\nString s = \" -end\";\nprintln(s);\n\n// This program writes to the console:\n// \"begin- f is 0.3 and i is 1024 -end\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "what",
        "description": "String, float, char, boolean, or byte: data to print to console"
    }, {
        "name": "variables",
        "description": "Object[]: list of data, separated by commas"
    }]
}, {
    "name": "println()",
    "description": "\nThe println() function writes to the console area, the black rectangle at the bottom of the Processing environment. This function is often helpful for looking at the data a program is producing. Each call to this function creates a new line of output. More than one parameter can be passed into the function by separating them with commas. Alternatively, individual elements can be separated with quotes (\"\") and joined with the addition operator (+).\n\nBefore Processing 2.1, println() was used to write array data to the console. Now, use printArray() to write array data to the console.\n\nNote that the console is relatively slow. It works well for occasional messages, but does not support high-speed, real-time output (such as at 60 frames per second).\n",
    "syntax": "println()\nprintln(what)\nprintln(variables)",
    "returns": "void",
    "examples": ["\nString s = \"The size is \";\nint w = 1920;\nint h = 1080;\nprintln(s);\nprintln(w, \"x\", h);\n\n// This program writes to the console:\n// The size is \n// 1920 x 1080\n", "\nprint(\"begin- \");\nfloat f = 0.3;\nint i = 1024;\nprint(\"f is \" + f + \" and i is \" + 1024);\nString s = \" -end\";\nprintln(s);\n\n// This program writes to the console:\n// \"begin- f is 0.3 and i is 1024 -end\"\n"],
    "examples_img": [],
    "parameters": [{
        "name": "what",
        "description": "Object, String, float, char, boolean, or byte: data to print to console"
    }, {
        "name": "variables",
        "description": "Object[]: list of data, separated by commas"
    }]
}, {
    "name": "shearX()",
    "description": "\nShears a shape around the x-axis the amount specified by the angle parameter. Angles should be specified in radians (values from 0 to PI*2) or converted to radians with the radians() function. Objects are always sheared around their relative position to the origin and positive numbers shear objects in a clockwise direction. Transformations apply to everything that happens after and subsequent calls to the function accumulates the effect. For example, calling shearX(PI/2) and then shearX(PI/2) is the same as shearX(PI). If shearX() is called within the draw(), the transformation is reset when the loop begins again.\n \nTechnically, shearX() multiplies the current transformation matrix by a rotation matrix. This function can be further controlled by the pushMatrix() and popMatrix() functions.\n",
    "syntax": "shearX(angle)",
    "returns": "void",
    "examples": ["\nsize(100, 100);\ntranslate(width/4, height/4);\nshearX(PI/4.0);\nrect(0, 0, 30, 30);\n"],
    "examples_img": ["https://www.processing.org/reference/images/shearX_.png"],
    "parameters": [{
        "name": "angle",
        "description": "float: angle of shear specified in radians"
    }]
}, {
    "name": "beginRecord()",
    "description": "\nOpens a new file and all subsequent drawing functions are echoed to this file as well as the display window. The beginRecord() function requires two parameters, the first is the renderer and the second is the file name. This function is always used with endRecord() to stop the recording process and close the file.\n \nNote that beginRecord() will only pick up any settings that happen after it has been called. For instance, if you call textFont() before beginRecord(), then that font will not be set for the file that you're recording to. \n",
    "syntax": "beginRecord(renderer, filename)",
    "returns": "PGraphics or void",
    "examples": ["\nimport processing.pdf.*;\n\nvoid setup() {\n  size(400, 400);\n  beginRecord(PDF, \"everything.pdf\");\n}\n\nvoid draw() {\n  ellipse(mouseX, mouseY, 10, 10);\n}\n\nvoid mousePressed() {\n  endRecord();\n  exit();\n} \n"],
    "examples_img": [],
    "parameters": [{
        "name": "renderer",
        "description": "String: for example, PDF"
    }, {
        "name": "filename",
        "description": "String: filename for output"
    }]
}]